<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Mon Nov 03 19:17:41 GMT 2014 -->
<TITLE>
Config
</TITLE>

<META NAME="keywords" CONTENT="com.threed.jpct.Config class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Config";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/CollisionEvent.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/DeSerializer.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Config.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class Config</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>com.threed.jpct.Config</B>
</PRE>
<HR>
<DL>
<DT>public final class <B>Config</B><DT>extends java.lang.Object</DL>

<P>
Config is used for configuring the engine. For faster access and to reduce
 code size, all important configuration variables are public and can be
 accessed directly.<br>
 For setting them programmatically, it may be more convenient to use the
 setParameterValue()-method instead.<br>
 Some will show effect directly after modifying them, some should be modified
 before doing the setup work for jPCT. This will be stated in the description
 of the setting.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#alwaysSort">alwaysSort</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces polygon sorting regardsless of transparency or the software
 renderer being used. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#autoBuild">autoBuild</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Usually, one have to call build() on all objects that have to be
 rendered. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#autoMaintainAspectRatio">autoMaintainAspectRatio</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ensures that the aspect ratio doesn't change when changing framebuffer
 size. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#blendAlphaIfOversampling">blendAlphaIfOversampling</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, alpha values will be blended just as colors do when using
 oversampling in the software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#blur">blur</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#collideEdgeMul">collideEdgeMul</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When using the sphere-polygon collision detection for the camera, it may
 be useful to use a lower sphere radius for sphere-edge-collisions to
 ensure that the camera slides around corners in a more realistic way. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#collideEllipsoidSmoothing">collideEllipsoidSmoothing</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this is enabled, the ellipsoid collision detection will use a kind of
 workaround to prevent the detection from producing jerky movement in some
 cases. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#collideEllipsoidThreshold">collideEllipsoidThreshold</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A threshold that limits recursion for ellipsoid collision detection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#collideOffset">collideOffset</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number in world units a polygon's corner and/or axis aligned
 bounding box/octree-node (is used) may have from a position vector to be
 taken into account as a potential collider in the collision detection
 methods.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#collideSectorOffset">collideSectorOffset</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of units a position vector may be placed outside of a sector
 and still be considered as part of it as far as collision detection is
 concerned. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#defaultCameraFOV">defaultCameraFOV</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default FOV for the camera. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#doPortalHsr">doPortalHsr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use portals and sectors to perform visibility determination. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#doSorting">doSorting</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Perform a front-to-back sorting of polygons before rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#fadeoutLight">fadeoutLight</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lightsourcing may depend on distance (or not). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#farPlane">farPlane</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The far clipping plane. jPCT's software renderer doesn't clip but culls
 on this plane. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glAdditionalConfiguration">glAdditionalConfiguration</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows for giving additional configuration information to the OpenGL
 renderers, i.e. to bypass the actual configuration jPCT is currently
 using. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glAnisotropy">glAnisotropy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the level of anisotropic filtering used by OpenGL. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glAvoidTextureCopies">glAvoidTextureCopies</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When in OpenGL mode, a texture's image data will be transfered to the
 graphics card and a copy will be kept in the Texture object in case that
 software rendering will be re-enabled, for applying texture effects or
 for multiple uploads into multiple contexts. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glAWTCommandQueueCleanup">glAWTCommandQueueCleanup</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Number of buffer switches before the AWT command queue used by the
 AWTGLRenderer gets a clean up. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glAWTCommandQueueSize">glAWTCommandQueueSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial size of the command queue that is used by the AWTGLRenderer, i.e.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glBatchSize">glBatchSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When compiling an Object3D, the renderer has to assume an ideal batch
 size for the underlying hardware. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glBlendingAffectsAlpha">glBlendingAffectsAlpha</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, the texture blending mode when using multi texturing
 affects the alpha channel too. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glBufferedBlits">glBufferedBlits</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If enabled, jPCT will aggregate blitting commands and execute them later
 in one call. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glColorDepth">glColorDepth</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The colordepth that the OpenGL framebuffer should have at least. jPCT
 will use any videomode that offers a colordepth equal to or larger than
 this value (but prefers equality). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glDynamicBatchSize">glDynamicBatchSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to glBatchSize but for dynamically compiled objects. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glFixedBlitting">glFixedBlitting</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Some graphics cards/drivers are having problems with jPCT's 2D-blitting
 when Zbuffer-depth is only 16bit. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glFlipRenderTargets">glFlipRenderTargets</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, textures that are used as a render target will be
 flipped, which is default for the software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glForceEnvMapToSecondStage">glForceEnvMapToSecondStage</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By default, an environment map will be applied to the first texture stage
 if environment mapping is used on an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glForceFinish">glForceFinish</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces the renderer to do GLFinish at the end of each frame. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glFullscreen">glFullscreen</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL output may be shown in a window (default, but doesn't work well on
 some setups) and fullscreen. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glIgnoreAlphaBlendingFBO">glIgnoreAlphaBlendingFBO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When using shadow mapping on transparent polygons in combination with
 FBOs, some NVidia drivers are having performance problems. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glIgnoreNearPlane">glIgnoreNearPlane</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, the OpenGL renderers will ignore the configured near
 plane for creating the frustum and use a default value instead. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glMipmap">glMipmap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lets jPCT generate (and use) mipmaps for all textures when using an
 OpenGL renderer.This has to be set before enabling the OpenGL renderer to
 have an effect. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glMultiPassSorting">glMultiPassSorting</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a special sorting to increase performance when doing multi pass
 rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glOverrideStageCount">glOverrideStageCount</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A switch to override the maximum number of texture stages available. -1
 means no override. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glRefresh">glRefresh</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The refresh rate in Hz the desired videomode should have at least (but
 equality is prefered). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glRevertADDtoMODULATE">glRevertADDtoMODULATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When setting this to true, every texture blending operation that uses the
 additive mode will be treated as if it were using modulation instead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glShadowZBias">glShadowZBias</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The depth bias used for shadow mapping. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glSkipInitialization">glSkipInitialization</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Setting this to true, makes jPCT skip any display initialization code in
 the OpenGL renderers. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glTextureDepth">glTextureDepth</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the color-depth of the textures that should by used for OpenGL.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glTransparencyMul">glTransparencyMul</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transparency in OpenGL is implemented in a way that tries to mimic the
 software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glTransparencyOffset">glTransparencyOffset</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transparency in OpenGL is implemented in a way that tries to mimic the
 software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glTriangleStrips">glTriangleStrips</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT can render objects (or parts of objects) as triangle-strips when
 using OpenGL. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glTrilinear">glTrilinear</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lets jPCT generate Mipmaps for all textures and enables trilinear
 filtering between them. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseCaches">glUseCaches</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The OpenGL renderer makes use of some simple caches to speed up
 framebuffer and texture access and to keep memory usage as low as
 possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseDynamicVBO">glUseDynamicVBO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Experimental, not always faster. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseFBO">glUseFBO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes jPCT use frame buffer objects (FBOs) if possible and applicable. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseIgnorantBlits">glUseIgnorantBlits</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces the OpenGL renderer to skip the texture conversion from the
 FrameBuffer's blit(int[]...)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseUnappropriateModes">glUseUnappropriateModes</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, the mode selection will relax the requirements one step
 below the step that usually makes sense. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glUseVBO">glUseVBO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Makes jPCT use vertex buffer objects (VBOs) if possible and applicable.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glVerbose">glVerbose</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces the GL-Renderer to talk to you about what he's doing when looking
 for videomodes and uploading textures. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glVertexArrays">glVertexArrays</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT can use VertexArrays to render objects. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glVSync">glVSync</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, vertical sync will be used if the driver supports this
 setting and doesn't override it itself. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glWindowName">glWindowName</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The name of the window when OpenGL is used. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glZBufferDepth">glZBufferDepth</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The bit-depth the OpenGL z-buffer should have. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#gouraud">gouraud</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Misleading name! </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#isIndoor">isIndoor</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables some optimizations for indoor scenes (like not clearing the
 framebuffer for every frame). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#lightDiscardDistance">lightDiscardDistance</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A vertex will only be lit by a lightsource if its distance from the light
 is lower than this value (in world units). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#lightMul">lightMul</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An "amplifier"-value for the lightsources. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#linearDiv">linearDiv</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How fast a lightsource's intensity fades out with distance. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#loadBalancingStrategy">loadBalancingStrategy</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If useMultipleThreads is used on the software renderer, you can choose
 the load balancing strategy with this setting. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#lockingTimer">lockingTimer</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;While waiting for a lock to be released, the waiting thread will be
 either paused (if lockingTimer is greater zero) for "lockingTimer"
 milliseconds or Thread.yield() will be called (if lockingTimer is zero).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxAnimationSubSequences">maxAnimationSubSequences</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of sub-sequences an Animation may contain. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxLights">maxLights</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of lightsources that the Lights instance of a World
 may handle. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxNumberOfCores">maxNumberOfCores</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of cores/cpus jPCT may use for multi-threaded code.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxParentObjects">maxParentObjects</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of parent objects every object may have. usually, an
 object has only one parent object anyway. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxPolysVisible">maxPolysVisible</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum size of the VisList. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxPortalCoords">maxPortalCoords</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of coordinates a single portal may consist of (Portals
 in jPCT doesn't have to be triangles or quads, they may have any shape).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxPortals">maxPortals</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of portals an instance of World can handle. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxTextureLayers">maxTextureLayers</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum number of texture layers jPCT can handle. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#maxTextures">maxTextures</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The inital number of textures the texture-manager can handle. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#mipmap">mipmap</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lets jPCT generate (and use) mipmaps for all textures when using the
 software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#mtDebug">mtDebug</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Debugging switch for multi threading...will most likely go away
 sometimes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#nativeBufferSize">nativeBufferSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The size in kb of the native buffer cache. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#nearPlane">nearPlane</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The near clipping plane. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#neverUseBufferedImage">neverUseBufferedImage</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When JAVA2 or higher is detected, jPCT uses a BufferedImage to render
 into. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#oldStyle3DSLoader">oldStyle3DSLoader</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT 1.11+ features a fixed 3DS-loader, but the fix is based on
 experience, not on file format specs, because they were all different and
 inconsistent. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#oldStyleBillBoarding">oldStyleBillBoarding</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT 1.15+ features a fixed bill boarding approach for
 child/parent-relations between objects. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#optimizeNormalCalcTH">optimizeNormalCalcTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT has two different methods for calculating the vertex-normals. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#optiZ">optiZ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use OptiZ optimization to speed up z-buffer access. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#polygonBufferSize">polygonBufferSize</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initial value for an internal polygon buffer of the World. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#polygonIDLimit">polygonIDLimit</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A value that defines how many polygon IDs that were part of a collision
 will be stored before additional polygon IDs will be rejected. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#saveMemory">saveMemory</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this is enabled, jPCT will reserve potentially needed memory only if
 it's REALLY needed. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#sectorRange">sectorRange</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A value used for sector detection similar to collideOffset. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#shareVisibilityList">shareVisibilityList</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If this is set to true, each instance of World will use the same instance
 of VisList and will use the same polygon buffer object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#spanBasedHsr">spanBasedHsr</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use a hidden surface removal method based on spans and sub-spans. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#specPow">specPow</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The sharpness of specular highlights. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#specTerm">specTerm</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An "amplifier"-value for specular highlights. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#synchronizedRendering">synchronizedRendering</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only applies to multi-threaded renderers. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#texelFilter">texelFilter</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use texel-filtering to avoid the blocky look of point sampling. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useBB">useBB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use the bounding box every Object3D has for faster clipping and culling.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useFastCollisionDetection">useFastCollisionDetection</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uses the axis aligned bounding box every object has (should have...) to
 optimize collision detection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useFastSpecular">useFastSpecular</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use fast specular lighting (if it's used at all). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useFramebufferWithAlpha">useFramebufferWithAlpha</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A software renderer only setting. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useFrustumCulling">useFrustumCulling</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use frustum culling to speed up geometry calculations. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useLocking">useLocking</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT may use locking for the rotation and translation matrices when
 rendering the objects. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useMultipassStriping">useMultipassStriping</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT offers a method to rebuild an object so that it consists of triangle
 strips instead of single triangles. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useMultipleThreads">useMultipleThreads</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An switch to make jPCT use multi-threading for some operations. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useMultiThreadedBlitting">useMultiThreadedBlitting</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only serves a purpose when useMultipleThreads is set to true and software
 rendering is being used. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useNormalsFromOBJ">useNormalsFromOBJ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By default, jPCT calculates normals based on the mesh's geometry when
 calling build(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#useRotationPivotFrom3DS">useRotationPivotFrom3DS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;By default, jPCT calculates a rotation pivot based on the mesh's geometry
 when calling build(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#VERSION">VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#viewportOffsetAffectsRenderTarget">viewportOffsetAffectsRenderTarget</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set to true, any offset to the viewport will affect the render target
 as well. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#viewportOffsetX">viewportOffsetX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shifts the (normalized) viewport into x-direction, i.e. a value of 0.5
 lets the rendering start in the middle of the framebuffer so that only
 the leftmost half of the image is visible in the right half of the
 framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#viewportOffsetY">viewportOffsetY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shifts the (normalized) viewport into y-direction, i.e. a value of 0.5
 lets the rendering start in the middle of the Framebuffer so that only
 the uppermost half of the image is visible in the bottom of the
 framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#zTrick">zTrick</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use zTrick to avoid clearing the z-buffer. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#getParameterNames()">getParameterNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the names of all public fields in Config, all configuration
 options.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#getParameterValue(java.lang.String)">getParameterValue</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current value of the parameter with the given name. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#getVersion()">getVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the version of this release. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glSetDesiredVideoMode(int, int, int, boolean)">glSetDesiredVideoMode</A></B>(int&nbsp;colorDepth,
                      int&nbsp;zDepth,
                      int&nbsp;refresh,
                      boolean&nbsp;fullscreen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method should help to set the desired video-mode for OpenGL.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#glSetDesiredVideoMode(com.threed.jpct.VideoMode, boolean)">glSetDesiredVideoMode</A></B>(<A HREF="../../../com/threed/jpct/VideoMode.html" title="class in com.threed.jpct">VideoMode</A>&nbsp;vm,
                      boolean&nbsp;fullscreen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This static method should help to set the desired video-mode for OpenGL.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#setParameterValue(java.lang.String, java.lang.Object)">setParameterValue</A></B>(java.lang.String&nbsp;name,
                  java.lang.Object&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a parameter with the given name to a value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#tuneForIndoor()">tuneForIndoor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a preset configuration for indoor-rendering. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Config.html#tuneForOutdoor()">tuneForOutdoor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a preset configuration for outdoor-rendering. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="VERSION"><!-- --></A><H3>
VERSION</H3>
<PRE>
public static final java.lang.String <B>VERSION</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>&nbsp;
<P>
<DD>The version of this release
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#getVersion()"><CODE>getVersion()</CODE></A>, 
<A HREF="../../../constant-values.html#com.threed.jpct.Config.VERSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="saveMemory"><!-- --></A><H3>
saveMemory</H3>
<PRE>
public static boolean <B>saveMemory</B></PRE>
<DL>
<DD>If this is enabled, jPCT will reserve potentially needed memory only if
 it's REALLY needed. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="shareVisibilityList"><!-- --></A><H3>
shareVisibilityList</H3>
<PRE>
public static boolean <B>shareVisibilityList</B></PRE>
<DL>
<DD>If this is set to true, each instance of World will use the same instance
 of VisList and will use the same polygon buffer object. It's initialized
 when the first instance of World is initialized with the current value of
 maxPolysVisible. This can help to save some memory if multiple Worlds are
 used. But be careful when working with different Worlds in different
 Threads or when rendering more then one world in a frame ot one world
 into multiple frames.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#decoupleVisibilityList()"><CODE>World.decoupleVisibilityList()</CODE></A></DL>
</DL>
<HR>

<A NAME="polygonBufferSize"><!-- --></A><H3>
polygonBufferSize</H3>
<PRE>
public static int <B>polygonBufferSize</B></PRE>
<DL>
<DD>Initial value for an internal polygon buffer of the World. This buffer
 this automatically resized if needed, but that may take some time. Choose
 a low value to keep memory usage low, choose a higher value to minimize
 resizing. Default is -1, which means that this buffer has the same size
 as the VisList (which is usually not needed). This is a tribute to
 versions prior to 1.05, who did this by default. The OpenGL renderer
 doesn't use this buffer, so you can safely set it to 1 if no software
 rendering is used at all.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useLocking"><!-- --></A><H3>
useLocking</H3>
<PRE>
public static boolean <B>useLocking</B></PRE>
<DL>
<DD>jPCT may use locking for the rotation and translation matrices when
 rendering the objects. See the corresponding methods in World for more
 details. Default is false.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#lockMatrices()"><CODE>World.lockMatrices()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#unlockMatrices()"><CODE>World.unlockMatrices()</CODE></A></DL>
</DL>
<HR>

<A NAME="lockingTimer"><!-- --></A><H3>
lockingTimer</H3>
<PRE>
public static int <B>lockingTimer</B></PRE>
<DL>
<DD>While waiting for a lock to be released, the waiting thread will be
 either paused (if lockingTimer is greater zero) for "lockingTimer"
 milliseconds or Thread.yield() will be called (if lockingTimer is zero).
 Default is 0 (Thread.yield()).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#lockMatrices()"><CODE>World.lockMatrices()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#unlockMatrices()"><CODE>World.unlockMatrices()</CODE></A></DL>
</DL>
<HR>

<A NAME="defaultCameraFOV"><!-- --></A><H3>
defaultCameraFOV</H3>
<PRE>
public static float <B>defaultCameraFOV</B></PRE>
<DL>
<DD>The default FOV for the camera. Takes effect at startup and when a new
 camera is created. Default is 1.25.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoMaintainAspectRatio"><!-- --></A><H3>
autoMaintainAspectRatio</H3>
<PRE>
public static boolean <B>autoMaintainAspectRatio</B></PRE>
<DL>
<DD>Ensures that the aspect ratio doesn't change when changing framebuffer
 size. Setting this to false causes xFOV and yFOV to be both set to FOV.
 If it's set to true, only xFOV will be set to FOV and yFOV will
 automatically be adjusted to a FOV-value that maintains the aspect ratio.
 If yFOV is set explicitly in the camera, this setting will be ignored.
 Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="neverUseBufferedImage"><!-- --></A><H3>
neverUseBufferedImage</H3>
<PRE>
public static boolean <B>neverUseBufferedImage</B></PRE>
<DL>
<DD>When JAVA2 or higher is detected, jPCT uses a BufferedImage to render
 into. If neverUseBufferedImage is set to true, this optimization won't be
 made when creating a new framebuffer and MemoryImageSource will be used
 instead. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useFramebufferWithAlpha"><!-- --></A><H3>
useFramebufferWithAlpha</H3>
<PRE>
public static boolean <B>useFramebufferWithAlpha</B></PRE>
<DL>
<DD>A software renderer only setting. By enabling this, the BufferedImage (if
 available) for the framebuffer supports an alpha channel. Everything
 rendered by jPCT will get an alpha value of 255. Default is false. If you
 set this to true, be sure that you really have to.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxTextures"><!-- --></A><H3>
maxTextures</H3>
<PRE>
public static int <B>maxTextures</B></PRE>
<DL>
<DD>The inital number of textures the texture-manager can handle. The manager
 wil increase the value if needed. This is in for historical reaons. No
 need to adjust it. Default is 256.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxPolysVisible"><!-- --></A><H3>
maxPolysVisible</H3>
<PRE>
public static int <B>maxPolysVisible</B></PRE>
<DL>
<DD>The maximum size of the VisList. This represents the number of polygons
 jPCT can display on screen per frame. If the polygon number surpasses
 this value, all additional polygons will be rejected and not drawn. This
 value has to be modified before instanciating a world. Default is 20000.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxLights"><!-- --></A><H3>
maxLights</H3>
<PRE>
public static int <B>maxLights</B></PRE>
<DL>
<DD>The maximum number of lightsources that the Lights instance of a World
 may handle. Has to be modified before constructing the World to take
 effect. Default is 32.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxTextureLayers"><!-- --></A><H3>
maxTextureLayers</H3>
<PRE>
public static int <B>maxTextureLayers</B></PRE>
<DL>
<DD>The maximum number of texture layers jPCT can handle. This feature is
 supported by the OpenGL renderer only. This has nothing to do (at least
 not directly) with the number of texture stages that the used hardware
 supports. If you are adding more than the hardware allows to, jPCT will
 switch from multi texturing to multi pass rendering. Default is 16.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxAnimationSubSequences"><!-- --></A><H3>
maxAnimationSubSequences</H3>
<PRE>
public static int <B>maxAnimationSubSequences</B></PRE>
<DL>
<DD>The maximum number of sub-sequences an Animation may contain. The default
 is 20 (for most MD2).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="collideOffset"><!-- --></A><H3>
collideOffset</H3>
<PRE>
public static float <B>collideOffset</B></PRE>
<DL>
<DD>The maximum number in world units a polygon's corner and/or axis aligned
 bounding box/octree-node (is used) may have from a position vector to be
 taken into account as a potential collider in the collision detection
 methods.<br>
 A polygon will be considered as a potential collider if its first corner
 falls within a box with the length of 2*collideOffset and the position
 vector used in the detection as midpoint.<br>
 This value may has be adjusted if the scaling of the world changes or the
 movement speed of the camera is set to a very value high. Setting this to
 a unnecessary high value reduces performance of collision detection while
 setting it to a too low value can cause the collision detection to fail.<br>
 If the automated collision detection optimization is used on an object,
 this value won't affect performance that much anymore. Anyway, it's taken
 as an upper bound for the algorithm and for bounding box/octree-node
 processing, so it may still be required to adjust it. Default is 40.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCollisionOptimization(boolean)"><CODE>Object3D.setCollisionOptimization(boolean)</CODE></A></DL>
</DL>
<HR>

<A NAME="collideEdgeMul"><!-- --></A><H3>
collideEdgeMul</H3>
<PRE>
public static float <B>collideEdgeMul</B></PRE>
<DL>
<DD>When using the sphere-polygon collision detection for the camera, it may
 be useful to use a lower sphere radius for sphere-edge-collisions to
 ensure that the camera slides around corners in a more realistic way. On
 the other hand, this may also cause some "bouncing" in other areas.
 Therefor, if the radius should be lowered, this value has to be adjusted.
 A value of 1f means, that the same radius is used for sphere-edge and
 sphere-polygon intersections. A lower value will lower the radius for
 sphere-edge and higher values than 1f are possible, but don't make much
 sense. Negative values will result in undefined behaviour. Default is 1f.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="collideSectorOffset"><!-- --></A><H3>
collideSectorOffset</H3>
<PRE>
public static float <B>collideSectorOffset</B></PRE>
<DL>
<DD>The number of units a position vector may be placed outside of a sector
 and still be considered as part of it as far as collision detection is
 concerned. This value is important for detecting the collision with parts
 of the sector the direction vector points to (in other words: where the
 entity moves into). A value too high may cause unnecessary checsk while a
 value too low may cause collision detection to fail at sector borders.
 Default is 3.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="collideEllipsoidThreshold"><!-- --></A><H3>
collideEllipsoidThreshold</H3>
<PRE>
public static float <B>collideEllipsoidThreshold</B></PRE>
<DL>
<DD>A threshold that limits recursion for ellipsoid collision detection. If
 the lenght of the current velocity (after collision) is lower than the
 initial velocity multiplied by with value, the recursion will stop.
 Setting this to the very low value will make the collision detection more
 accurate, but may also result in accuracy problems where collisions are
 detected that don't happen. Default is 0.1f.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="collideEllipsoidSmoothing"><!-- --></A><H3>
collideEllipsoidSmoothing</H3>
<PRE>
public static boolean <B>collideEllipsoidSmoothing</B></PRE>
<DL>
<DD>If this is enabled, the ellipsoid collision detection will use a kind of
 workaround to prevent the detection from producing jerky movement in some
 cases. On the other hand, this may cause problems on high polygon objects
 (in theory...i never experienced it). It's enabled by default.<br>
 1.04+ should fix the problem by applying a bugfix to the ellipsoid
 collision detection. So this setting will most likely be deprecated in
 future versions.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useFastCollisionDetection"><!-- --></A><H3>
useFastCollisionDetection</H3>
<PRE>
public static boolean <B>useFastCollisionDetection</B></PRE>
<DL>
<DD>Uses the axis aligned bounding box every object has (should have...) to
 optimize collision detection. There should be not need to set this to
 false (maybe in a very special situation where there is always a
 collision between objects...but even then...well...). Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nearPlane"><!-- --></A><H3>
nearPlane</H3>
<PRE>
public static float <B>nearPlane</B></PRE>
<DL>
<DD>The near clipping plane. Software and OpenGL renderer will behave
 different for values other than 1f. jPCT culls on this plane, it doesn't
 really clip... Default is 1.<br>
 The OpenGL renderers are ignoring this value for frustum creation unless
 you set glIgnoreNearPlane to false.<br>
 You may as well override this value in an instance of World.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#setClippingPlanes(float, float)"><CODE>World.setClippingPlanes(float, float)</CODE></A></DL>
</DL>
<HR>

<A NAME="farPlane"><!-- --></A><H3>
farPlane</H3>
<PRE>
public static float <B>farPlane</B></PRE>
<DL>
<DD>The far clipping plane. jPCT's software renderer doesn't clip but culls
 on this plane. Default is 1000.<br>
 You may as well override this value in an instance of World.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#setClippingPlanes(float, float)"><CODE>World.setClippingPlanes(float, float)</CODE></A></DL>
</DL>
<HR>

<A NAME="viewportOffsetX"><!-- --></A><H3>
viewportOffsetX</H3>
<PRE>
public static float <B>viewportOffsetX</B></PRE>
<DL>
<DD>Shifts the (normalized) viewport into x-direction, i.e. a value of 0.5
 lets the rendering start in the middle of the framebuffer so that only
 the leftmost half of the image is visible in the right half of the
 framebuffer. Useful for implementing sidebars and similar stuff. When
 using software rendering, the polygons are culled but not clipped against
 the viewport's boundaries for performance/implementation reasons.
 Possible values are in the range of ]-1;1[, default is 0. This setting
 has NO influence on blitting into the framebuffer but the methods in
 Interact2D take it into account.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="viewportOffsetY"><!-- --></A><H3>
viewportOffsetY</H3>
<PRE>
public static float <B>viewportOffsetY</B></PRE>
<DL>
<DD>Shifts the (normalized) viewport into y-direction, i.e. a value of 0.5
 lets the rendering start in the middle of the Framebuffer so that only
 the uppermost half of the image is visible in the bottom of the
 framebuffer. Useful for implementing sidebars and similar stuff. When
 using software rendering, the polygons are culled but not clipped against
 the viewport's boundaries for performance/implementation reasons.
 Possible values are in the range of ]-1;1[, default is 0. This setting
 has NO influence on blitting into the framebuffer but the methods in
 Interact2D take it into account.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="viewportOffsetAffectsRenderTarget"><!-- --></A><H3>
viewportOffsetAffectsRenderTarget</H3>
<PRE>
public static boolean <B>viewportOffsetAffectsRenderTarget</B></PRE>
<DL>
<DD>If set to true, any offset to the viewport will affect the render target
 as well. If false, it won't. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxPortalCoords"><!-- --></A><H3>
maxPortalCoords</H3>
<PRE>
public static int <B>maxPortalCoords</B></PRE>
<DL>
<DD>The maximum number of coordinates a single portal may consist of (Portals
 in jPCT doesn't have to be triangles or quads, they may have any shape).
 This value has to be modified before constructing a World. Default is 8.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxPortals"><!-- --></A><H3>
maxPortals</H3>
<PRE>
public static int <B>maxPortals</B></PRE>
<DL>
<DD>The maximum number of portals an instance of World can handle. This value
 has to be modified before constructing a world. Default is 0.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxParentObjects"><!-- --></A><H3>
maxParentObjects</H3>
<PRE>
public static int <B>maxParentObjects</B></PRE>
<DL>
<DD>The maximum number of parent objects every object may have. usually, an
 object has only one parent object anyway. Default is 2.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="sectorRange"><!-- --></A><H3>
sectorRange</H3>
<PRE>
public static float <B>sectorRange</B></PRE>
<DL>
<DD>A value used for sector detection similar to collideOffset. Normally,
 there should be no need to modify this value. Default is 30.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#collideOffset"><CODE>collideOffset</CODE></A></DL>
</DL>
<HR>

<A NAME="useFastSpecular"><!-- --></A><H3>
useFastSpecular</H3>
<PRE>
public static boolean <B>useFastSpecular</B></PRE>
<DL>
<DD>Use fast specular lighting (if it's used at all). Fast specular is
 calculated using Schlick's method instead of Blinn's. Schlick's is faster
 while Blinn's is more "specular". Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="gouraud"><!-- --></A><H3>
gouraud</H3>
<PRE>
public static boolean <B>gouraud</B></PRE>
<DL>
<DD>Misleading name! This doesn't toogle gouraud shading (that's not possible
 anyway in jPCT) but it disables all lighting but ambient if set to false.
 Default is true
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="fadeoutLight"><!-- --></A><H3>
fadeoutLight</H3>
<PRE>
public static boolean <B>fadeoutLight</B></PRE>
<DL>
<DD>Lightsourcing may depend on distance (or not). This value can be
 overriden in World. Default is true.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#setLightAttenuation(int, float)"><CODE>World.setLightAttenuation(int, float)</CODE></A></DL>
</DL>
<HR>

<A NAME="lightMul"><!-- --></A><H3>
lightMul</H3>
<PRE>
public static int <B>lightMul</B></PRE>
<DL>
<DD>An "amplifier"-value for the lightsources. The intensity of every
 lightsource will be multiplied with this value to get the final
 intensity. For compiled objects, this has no meaning. They will always be
 rendered with an implicit value of 1. Default is 10.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="linearDiv"><!-- --></A><H3>
linearDiv</H3>
<PRE>
public static float <B>linearDiv</B></PRE>
<DL>
<DD>How fast a lightsource's intensity fades out with distance. A higher
 value lets the lightsource fade out slower while a lower value lets the
 lightsource fade out faster. This value can be overriden for a light
 source in World. Default is 50.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#setLightAttenuation(int, float)"><CODE>World.setLightAttenuation(int, float)</CODE></A></DL>
</DL>
<HR>

<A NAME="specTerm"><!-- --></A><H3>
specTerm</H3>
<PRE>
public static float <B>specTerm</B></PRE>
<DL>
<DD>An "amplifier"-value for specular highlights. Specular lighting has to be
 used on objects for this setting to take effect. Default is 10.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="specPow"><!-- --></A><H3>
specPow</H3>
<PRE>
public static float <B>specPow</B></PRE>
<DL>
<DD>The sharpness of specular highlights. Specular lighting has to be used on
 objects for this setting to take effect. Default is 6.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="lightDiscardDistance"><!-- --></A><H3>
lightDiscardDistance</H3>
<PRE>
public static float <B>lightDiscardDistance</B></PRE>
<DL>
<DD>A vertex will only be lit by a lightsource if its distance from the light
 is lower than this value (in world units). A value of -1 means, that all
 lightsources will influence a vertex regardless of their distance. If
 many lightsources are being used, this may improve lighting performance.
 This value can be overriden for a light source in World. Default is -1.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#setLightDiscardDistance(int, float)"><CODE>World.setLightDiscardDistance(int, float)</CODE></A></DL>
</DL>
<HR>

<A NAME="blur"><!-- --></A><H3>
blur</H3>
<PRE>
public static boolean <B>blur</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>&nbsp;
<P>
<DD>Enables/Disables motion blur. Motion blur requires that the objects to
 blur are rendered in front of the background color. This setting is
 ignored by the OpenGL-renderer.<br>
 This setting will go away in future versions. Deprecating it is the first
 step. If you really need this feature, please let me know and i might
 change my mind...
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="optiZ"><!-- --></A><H3>
optiZ</H3>
<PRE>
public static boolean <B>optiZ</B></PRE>
<DL>
<DD>Use OptiZ optimization to speed up z-buffer access. This setting is
 ignored by the OpenGL-renderer. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="zTrick"><!-- --></A><H3>
zTrick</H3>
<PRE>
public static boolean <B>zTrick</B></PRE>
<DL>
<DD>Use zTrick to avoid clearing the z-buffer. This reduces z-buffer accuracy
 from 32 to 31 bits. zTrick works only if the whole screen is filled with
 polygons every frame (like when using indoor rendering) and
 Config.isIndoor is set to true. Otherwise, z-buffer errors will occur.
 This setting is ignored by the OpenGL-renderer. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="spanBasedHsr"><!-- --></A><H3>
spanBasedHsr</H3>
<PRE>
public static boolean <B>spanBasedHsr</B></PRE>
<DL>
<DD>Use a hidden surface removal method based on spans and sub-spans. This
 may help and won't hurt, so it shouldn't be required to disable it. This
 setting is ignored by the OpenGL-renderer. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="texelFilter"><!-- --></A><H3>
texelFilter</H3>
<PRE>
public static boolean <B>texelFilter</B></PRE>
<DL>
<DD>Use texel-filtering to avoid the blocky look of point sampling. Texel
 filtering does cost some performance (but not much) and may introduce
 artifacts in some cases. Filtering is only applied to texels that are "in
 need of" and ignored when using OpenGL. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="isIndoor"><!-- --></A><H3>
isIndoor</H3>
<PRE>
public static boolean <B>isIndoor</B></PRE>
<DL>
<DD>Enables some optimizations for indoor scenes (like not clearing the
 framebuffer for every frame). Should be enabled if indoor rendering is
 performed. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="doPortalHsr"><!-- --></A><H3>
doPortalHsr</H3>
<PRE>
public static boolean <B>doPortalHsr</B></PRE>
<DL>
<DD>Use portals and sectors to perform visibility determination. Portals and
 sectors need to be set up correctly for this option to be enabled. Refer
 to the documentation of portals and objects for further information about
 this topic. Don't enable portal rendering when octrees are being used.
 It's not possible to combine the two in JPCT and doing so will result in
 an unpredictable behaviour! Default is false.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct"><CODE>Object3D</CODE></A>, 
<A HREF="../../../com/threed/jpct/Portals.html" title="class in com.threed.jpct"><CODE>Portals</CODE></A></DL>
</DL>
<HR>

<A NAME="doSorting"><!-- --></A><H3>
doSorting</H3>
<PRE>
public static boolean <B>doSorting</B></PRE>
<DL>
<DD>Perform a front-to-back sorting of polygons before rendering. Albeit the
 sorting costs some performance, it helps OptiZ and the span based HSR
 approach to perform well. This setting is ignored by the OpenGL-renderer.
 Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="alwaysSort"><!-- --></A><H3>
alwaysSort</H3>
<PRE>
public static boolean <B>alwaysSort</B></PRE>
<DL>
<DD>Forces polygon sorting regardsless of transparency or the software
 renderer being used. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useFrustumCulling"><!-- --></A><H3>
useFrustumCulling</H3>
<PRE>
public static boolean <B>useFrustumCulling</B></PRE>
<DL>
<DD>Use frustum culling to speed up geometry calculations. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useBB"><!-- --></A><H3>
useBB</H3>
<PRE>
public static boolean <B>useBB</B></PRE>
<DL>
<DD>Use the bounding box every Object3D has for faster clipping and culling.
 No need to disable this. Default is true
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="optimizeNormalCalcTH"><!-- --></A><H3>
optimizeNormalCalcTH</H3>
<PRE>
public static int <B>optimizeNormalCalcTH</B></PRE>
<DL>
<DD>jPCT has two different methods for calculating the vertex-normals. One is
 faster for smaller objects while the other is (much!) faster for more
 complex ones. For objects with a triangle-count below this value, the
 first method will be used and for objects with a higher triangle count,
 the second method will be used. Default is 500.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useMultipleThreads"><!-- --></A><H3>
useMultipleThreads</H3>
<PRE>
public static boolean <B>useMultipleThreads</B></PRE>
<DL>
<DD>An switch to make jPCT use multi-threading for some operations. This
 affects the GLRenderer (The AWTGLRenderer is multi-threaded anyway) and
 the software renderer but in different ways. It can only make sense when
 the system has 2 or more cores/cpus. A hyper threading system will most
 likely not benefit from it.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useMultiThreadedBlitting"><!-- --></A><H3>
useMultiThreadedBlitting</H3>
<PRE>
public static boolean <B>useMultiThreadedBlitting</B></PRE>
<DL>
<DD>Only serves a purpose when useMultipleThreads is set to true and software
 rendering is being used. Then, you can enable multi threaded blitting of
 the rendered image to screen. This usually isn't worth it, which is why
 it defaults to false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="loadBalancingStrategy"><!-- --></A><H3>
loadBalancingStrategy</H3>
<PRE>
public static int <B>loadBalancingStrategy</B></PRE>
<DL>
<DD>If useMultipleThreads is used on the software renderer, you can choose
 the load balancing strategy with this setting. Currently available are <br>
 0 = static balancing (default), good for scenes where geometry and
 coverage are equally distributed. 1 = dynamic balancing, good for scenes
 that don't cover the whole screen or that change often.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="maxNumberOfCores"><!-- --></A><H3>
maxNumberOfCores</H3>
<PRE>
public static int <B>maxNumberOfCores</B></PRE>
<DL>
<DD>The maximum number of cores/cpus jPCT may use for multi-threaded code.
 This affects the software renderer only ATM and only if
 useMultipleThreads is set to true. Default is 4, which matches a quad
 core.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="mtDebug"><!-- --></A><H3>
mtDebug</H3>
<PRE>
public static boolean <B>mtDebug</B></PRE>
<DL>
<DD>Debugging switch for multi threading...will most likely go away
 sometimes.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glTransparencyOffset"><!-- --></A><H3>
glTransparencyOffset</H3>
<PRE>
public static float <B>glTransparencyOffset</B></PRE>
<DL>
<DD>Transparency in OpenGL is implemented in a way that tries to mimic the
 software renderer. If one is using OpenGL only or can live with different
 output, the offset in the formula used to calculate the actual
 transparency from an object's transparency value can be changed to
 broaden the range. The actual formula is trans=offset+objTrans*mul,
 default for offset is 0.7f. This setting is ignored by the software
 renderer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glTransparencyMul"><!-- --></A><H3>
glTransparencyMul</H3>
<PRE>
public static float <B>glTransparencyMul</B></PRE>
<DL>
<DD>Transparency in OpenGL is implemented in a way that tries to mimic the
 software renderer. If one is using OpenGL only or can live with different
 output, the multiplicator in the formula used to calculate the actual
 transparency from an object's transparency value can be changed to
 broaden the range. The actual formula is trans=offset+objTrans*mul,
 default for mul is 0.06f. This setting is ignored by the software
 renderer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glShadowZBias"><!-- --></A><H3>
glShadowZBias</H3>
<PRE>
public static float <B>glShadowZBias</B></PRE>
<DL>
<DD>The depth bias used for shadow mapping. Default is 0.5f, which is quite
 small. This value will be added to the z-value of polygons used for
 rendering a shadow map. If you are experiencing shadowing artifacts on
 polygons, play around with this setting.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glFullscreen"><!-- --></A><H3>
glFullscreen</H3>
<PRE>
public static boolean <B>glFullscreen</B></PRE>
<DL>
<DD>OpenGL output may be shown in a window (default, but doesn't work well on
 some setups) and fullscreen. This has to be set before enabling the
 OpenGL-renderer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glColorDepth"><!-- --></A><H3>
glColorDepth</H3>
<PRE>
public static int <B>glColorDepth</B></PRE>
<DL>
<DD>The colordepth that the OpenGL framebuffer should have at least. jPCT
 will use any videomode that offers a colordepth equal to or larger than
 this value (but prefers equality). The software renderer always uses
 24bit. On a current graphics adapter, 32bit should be fine for Windows.
 On Linux, there are no 32bit modes reported by the driver. Use 24bit
 instead. Default is 32.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)"><CODE>FrameBuffer.getVideoModes(int)</CODE></A></DL>
</DL>
<HR>

<A NAME="glZBufferDepth"><!-- --></A><H3>
glZBufferDepth</H3>
<PRE>
public static int <B>glZBufferDepth</B></PRE>
<DL>
<DD>The bit-depth the OpenGL z-buffer should have. The software renderer
 always uses 32bit. Default is 24.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)"><CODE>FrameBuffer.getVideoModes(int)</CODE></A></DL>
</DL>
<HR>

<A NAME="glRefresh"><!-- --></A><H3>
glRefresh</H3>
<PRE>
public static int <B>glRefresh</B></PRE>
<DL>
<DD>The refresh rate in Hz the desired videomode should have at least (but
 equality is prefered). This value is only of interest if fullscreen mode
 is being used. If it's set to 0, jPCT will pick a mode regardless of the
 refresh rate. Default is 60.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)"><CODE>FrameBuffer.getVideoModes(int)</CODE></A></DL>
</DL>
<HR>

<A NAME="glOverrideStageCount"><!-- --></A><H3>
glOverrideStageCount</H3>
<PRE>
public static int <B>glOverrideStageCount</B></PRE>
<DL>
<DD>A switch to override the maximum number of texture stages available. -1
 means no override. Other valid values are 1 to 4. Can be useful to
 simulate the results that a 2 (or even 1) texture stage device may create
 when jPCT is running on a hardware that actually supports more. Has to be
 set before enabling the renderer to show an effect. Default is -1.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glMultiPassSorting"><!-- --></A><H3>
glMultiPassSorting</H3>
<PRE>
public static boolean <B>glMultiPassSorting</B></PRE>
<DL>
<DD>Enables a special sorting to increase performance when doing multi pass
 rendering. This may create slightly different results when using
 transparency on a multi pass object, but that isn't a good idea anyway,
 so...<br>
 Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glAdditionalConfiguration"><!-- --></A><H3>
glAdditionalConfiguration</H3>
<PRE>
public static java.lang.Object[] <B>glAdditionalConfiguration</B></PRE>
<DL>
<DD>Allows for giving additional configuration information to the OpenGL
 renderers, i.e. to bypass the actual configuration jPCT is currently
 using. Currently, the array may contain a org.lwjgl.opengl.PixelFormat
 and/or org.lwjgl.opengl.DisplayMode. If provided, jPCT will use those
 instead of trying to determine its own one. How to create these instances
 is up to you.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glMipmap"><!-- --></A><H3>
glMipmap</H3>
<PRE>
public static boolean <B>glMipmap</B></PRE>
<DL>
<DD>Lets jPCT generate (and use) mipmaps for all textures when using an
 OpenGL renderer.This has to be set before enabling the OpenGL renderer to
 have an effect. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="mipmap"><!-- --></A><H3>
mipmap</H3>
<PRE>
public static boolean <B>mipmap</B></PRE>
<DL>
<DD>Lets jPCT generate (and use) mipmaps for all textures when using the
 software renderer. Mipmaps are applied per polygon in the software
 renderer (like the old Riva 128 chip was doing it too...:-)), not per
 pixel.<br/>
 Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glTrilinear"><!-- --></A><H3>
glTrilinear</H3>
<PRE>
public static boolean <B>glTrilinear</B></PRE>
<DL>
<DD>Lets jPCT generate Mipmaps for all textures and enables trilinear
 filtering between them. This has to be set before enabling the OpenGL
 renderer to have an effect. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glAnisotropy"><!-- --></A><H3>
glAnisotropy</H3>
<PRE>
public static int <B>glAnisotropy</B></PRE>
<DL>
<DD>Sets the level of anisotropic filtering used by OpenGL. Default is 0,
 which means that nothing will be set and the driver presets will be used.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glTextureDepth"><!-- --></A><H3>
glTextureDepth</H3>
<PRE>
public static int <B>glTextureDepth</B></PRE>
<DL>
<DD>Specifies the color-depth of the textures that should by used for OpenGL.
 Possible values are 32 for a 8/8/8/8, 16 for a 4/4/4/4 format and -1 for
 a "best fit" setting determined by the OpenGL implementation (= GL_RGBA).
 Default is 32.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glTriangleStrips"><!-- --></A><H3>
glTriangleStrips</H3>
<PRE>
public static boolean <B>glTriangleStrips</B></PRE>
<DL>
<DD>jPCT can render objects (or parts of objects) as triangle-strips when
 using OpenGL. This is usually faster (but not as much as one may think)
 and so it's enabled by default. If problems occur, this setting may be
 changed to false to see if the strips are causing the problem. Triangle
 strips won't be used, if the software renderer is enabled (even when
 using the OpenGL renderer in addition). Default is true.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips()"><CODE>Object3D.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#createTriangleStrips()"><CODE>World.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#useMultipassStriping"><CODE>useMultipassStriping</CODE></A></DL>
</DL>
<HR>

<A NAME="glVertexArrays"><!-- --></A><H3>
glVertexArrays</H3>
<PRE>
public static boolean <B>glVertexArrays</B></PRE>
<DL>
<DD>jPCT can use VertexArrays to render objects. This is usually faster for
 scenes with quite a lot of triangles. When using VertexArrays, the
 glTriangleStrip setting will be ignored. However, creating
 triangle-strips for the object may still increase performance. Default is
 true.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips()"><CODE>Object3D.createTriangleStrips()</CODE></A></DL>
</DL>
<HR>

<A NAME="glWindowName"><!-- --></A><H3>
glWindowName</H3>
<PRE>
public static java.lang.String <B>glWindowName</B></PRE>
<DL>
<DD>The name of the window when OpenGL is used. Default is "jPCT".
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glForceFinish"><!-- --></A><H3>
glForceFinish</H3>
<PRE>
public static boolean <B>glForceFinish</B></PRE>
<DL>
<DD>Forces the renderer to do GLFinish at the end of each frame. This is
 slower and usually not needed. It's advised to leave this setting to
 default, which is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glForceEnvMapToSecondStage"><!-- --></A><H3>
glForceEnvMapToSecondStage</H3>
<PRE>
public static boolean <B>glForceEnvMapToSecondStage</B></PRE>
<DL>
<DD>By default, an environment map will be applied to the first texture stage
 if environment mapping is used on an object. When combining it with multi
 texturung, this may not always be want one wants, because the lighting
 calculations of OpenGL may give you undesired results by applying the
 lighting to the environment map instead of the base map. To work around
 this problem, you can force jPCT to use the second texture stage for
 environment mapping, if (and only if) the object uses multiple stages.
 However, jPCT doesn't check if a particular polygon uses multiple stages.
 So if you are forcing environment mapping to stage 2, make sure that your
 multi textured object all have that stage for all polygons and that the
 correct textures are assigned. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glFixedBlitting"><!-- --></A><H3>
glFixedBlitting</H3>
<PRE>
public static boolean <B>glFixedBlitting</B></PRE>
<DL>
<DD>Some graphics cards/drivers are having problems with jPCT's 2D-blitting
 when Zbuffer-depth is only 16bit. Setting this to true, enables a fix for
 this problem but may cause very subtle artifacts (i never experienced one
 but you never know...). Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glBufferedBlits"><!-- --></A><H3>
glBufferedBlits</H3>
<PRE>
public static boolean <B>glBufferedBlits</B></PRE>
<DL>
<DD>If enabled, jPCT will aggregate blitting commands and execute them later
 in one call. In theory, this should be faster than the default method. In
 practice, it isn't (at least not in my tests). However, it may be faster
 on some machines, which why it can be enabled here. Anyway, default is
 false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glVerbose"><!-- --></A><H3>
glVerbose</H3>
<PRE>
public static boolean <B>glVerbose</B></PRE>
<DL>
<DD>Forces the GL-Renderer to talk to you about what he's doing when looking
 for videomodes and uploading textures. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glAvoidTextureCopies"><!-- --></A><H3>
glAvoidTextureCopies</H3>
<PRE>
public static boolean <B>glAvoidTextureCopies</B></PRE>
<DL>
<DD>When in OpenGL mode, a texture's image data will be transfered to the
 graphics card and a copy will be kept in the Texture object in case that
 software rendering will be re-enabled, for applying texture effects or
 for multiple uploads into multiple contexts. If this is not required, you
 can get rid of this copy by setting this to true. This may save some
 memory, but it's likely to produce errors and crashes in case your
 expectations aren't correct on how the textures are used. Take care!
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glAWTCommandQueueSize"><!-- --></A><H3>
glAWTCommandQueueSize</H3>
<PRE>
public static int <B>glAWTCommandQueueSize</B></PRE>
<DL>
<DD>Initial size of the command queue that is used by the AWTGLRenderer, i.e.
 when rendering into an AWTGLCanvas. The queue will be expanded if needed
 by this amount. Default is 1000.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glAWTCommandQueueCleanup"><!-- --></A><H3>
glAWTCommandQueueCleanup</H3>
<PRE>
public static int <B>glAWTCommandQueueCleanup</B></PRE>
<DL>
<DD>Number of buffer switches before the AWT command queue used by the
 AWTGLRenderer gets a clean up. This is an internal process that should
 remain unnoticed and there is usually no need to change this setting.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glSkipInitialization"><!-- --></A><H3>
glSkipInitialization</H3>
<PRE>
public static boolean <B>glSkipInitialization</B></PRE>
<DL>
<DD>Setting this to true, makes jPCT skip any display initialization code in
 the OpenGL renderers. This can be useful to make jPCT render into an SWT
 component (for example). Initializing the display is totally up to you in
 this case. For normal use of jPCT, this isn't needed. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseIgnorantBlits"><!-- --></A><H3>
glUseIgnorantBlits</H3>
<PRE>
public static boolean <B>glUseIgnorantBlits</B></PRE>
<DL>
<DD>Forces the OpenGL renderer to skip the texture conversion from the
 FrameBuffer's blit(int[]...)-method except for the first time. In other
 words: If this is set to true, an int[]-array that should be used for
 blitting will be converted into a texture exactly one time and this
 texture will be used from there on as long as the size of the int[]-array
 to blit doesn't change. This is much faster, but depending on the
 application, it may blit nonsense. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseCaches"><!-- --></A><H3>
glUseCaches</H3>
<PRE>
public static boolean <B>glUseCaches</B></PRE>
<DL>
<DD>The OpenGL renderer makes use of some simple caches to speed up
 framebuffer and texture access and to keep memory usage as low as
 possible. If, for whatever reason, these caches seem to cause trouble...
 here is the option to disable them. But don't disable them without need,
 because it may hurt performance tremendously. Default is true.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseFBO"><!-- --></A><H3>
glUseFBO</H3>
<PRE>
public static boolean <B>glUseFBO</B></PRE>
<DL>
<DD>Makes jPCT use frame buffer objects (FBOs) if possible and applicable. In
 case of compability problems with render to texture and/or shadow
 mapping, try setting this to false. It will hurt performance though. Set
 this before enabling a renderer. Default is true.<br>
 NOTE: This value will be adjusted by jPCT after initializing an
 OpenGL-renderer to the actually used state.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseVBO"><!-- --></A><H3>
glUseVBO</H3>
<PRE>
public static boolean <B>glUseVBO</B></PRE>
<DL>
<DD>Makes jPCT use vertex buffer objects (VBOs) if possible and applicable.
 If set to false, jPCT will revert to display lists instead. Set this
 before enabling a renderer. Default is true.<br>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseDynamicVBO"><!-- --></A><H3>
glUseDynamicVBO</H3>
<PRE>
public static boolean <B>glUseDynamicVBO</B></PRE>
<DL>
<DD>Experimental, not always faster. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glIgnoreAlphaBlendingFBO"><!-- --></A><H3>
glIgnoreAlphaBlendingFBO</H3>
<PRE>
public static boolean <B>glIgnoreAlphaBlendingFBO</B></PRE>
<DL>
<DD>When using shadow mapping on transparent polygons in combination with
 FBOs, some NVidia drivers are having performance problems. Setting this
 to true treats transparent as opaque polygons and the problems are gone.
 However, the shadows may suck visually. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glRevertADDtoMODULATE"><!-- --></A><H3>
glRevertADDtoMODULATE</H3>
<PRE>
public static boolean <B>glRevertADDtoMODULATE</B></PRE>
<DL>
<DD>When setting this to true, every texture blending operation that uses the
 additive mode will be treated as if it were using modulation instead.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glFlipRenderTargets"><!-- --></A><H3>
glFlipRenderTargets</H3>
<PRE>
public static boolean <B>glFlipRenderTargets</B></PRE>
<DL>
<DD>If set to true, textures that are used as a render target will be
 flipped, which is default for the software renderer. This works only with
 FBOs disabled. Default is now false (was true in version prior to 1.15).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glBlendingAffectsAlpha"><!-- --></A><H3>
glBlendingAffectsAlpha</H3>
<PRE>
public static boolean <B>glBlendingAffectsAlpha</B></PRE>
<DL>
<DD>If set to true, the texture blending mode when using multi texturing
 affects the alpha channel too. If set to false, this won't happen, which
 was the default in 1.15 and lower. This doesn't affect multi pass
 rendering. Default is true. NOTE: This value will be adjusted by jPCT
 after initializing an OpenGL-renderer to the actually used state.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glVSync"><!-- --></A><H3>
glVSync</H3>
<PRE>
public static boolean <B>glVSync</B></PRE>
<DL>
<DD>If set to true, vertical sync will be used if the driver supports this
 setting and doesn't override it itself. Enabling vertical sync may reduce
 performance but prevents tearing. Default is false (=off). Set this
 before enabling an OpenGL renderer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glUseUnappropriateModes"><!-- --></A><H3>
glUseUnappropriateModes</H3>
<PRE>
public static boolean <B>glUseUnappropriateModes</B></PRE>
<DL>
<DD>If set to true, the mode selection will relax the requirements one step
 below the step that usually makes sense. This can be required if the
 driver has some problems to report a correct mode albeit he could enable
 it anyway. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glBatchSize"><!-- --></A><H3>
glBatchSize</H3>
<PRE>
public static int <B>glBatchSize</B></PRE>
<DL>
<DD>When compiling an Object3D, the renderer has to assume an ideal batch
 size for the underlying hardware. If that size is too small or too large,
 performance may suffer or polygons are missing. The default is 8000. If
 you are experiencing problems or crashes, try if it helps to lower this
 value (and post your findings in the forum!).
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glDynamicBatchSize"><!-- --></A><H3>
glDynamicBatchSize</H3>
<PRE>
public static int <B>glDynamicBatchSize</B></PRE>
<DL>
<DD>Similar to glBatchSize but for dynamically compiled objects. This value
 is significantly lower than the one for static object by default, because
 there were some problems with some NVidia drivers if the value is too
 high. Default is 2000.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="glIgnoreNearPlane"><!-- --></A><H3>
glIgnoreNearPlane</H3>
<PRE>
public static boolean <B>glIgnoreNearPlane</B></PRE>
<DL>
<DD>If set to true, the OpenGL renderers will ignore the configured near
 plane for creating the frustum and use a default value instead. If it's
 false, the near plane will be used. Default is true.<br/>
 Don't set this to false when using the software renderer.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="polygonIDLimit"><!-- --></A><H3>
polygonIDLimit</H3>
<PRE>
public static int <B>polygonIDLimit</B></PRE>
<DL>
<DD>A value that defines how many polygon IDs that were part of a collision
 will be stored before additional polygon IDs will be rejected. Default is
 50.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useMultipassStriping"><!-- --></A><H3>
useMultipassStriping</H3>
<PRE>
public static boolean <B>useMultipassStriping</B></PRE>
<DL>
<DD>jPCT offers a method to rebuild an object so that it consists of triangle
 strips instead of single triangles. This may be useful when using the
 OpenGL renderer, because it may increase performance in geometry limited
 situations. Using a multipass-approach for this is slower but usually
 generates better strips. Default is true.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips()"><CODE>Object3D.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#createTriangleStrips()"><CODE>World.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glTriangleStrips"><CODE>glTriangleStrips</CODE></A></DL>
</DL>
<HR>

<A NAME="oldStyle3DSLoader"><!-- --></A><H3>
oldStyle3DSLoader</H3>
<PRE>
public static boolean <B>oldStyle3DSLoader</B></PRE>
<DL>
<DD>jPCT 1.11+ features a fixed 3DS-loader, but the fix is based on
 experience, not on file format specs, because they were all different and
 inconsistent. If you are getting wrong object colors or an error message,
 adjust this to true and see if it helps.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useRotationPivotFrom3DS"><!-- --></A><H3>
useRotationPivotFrom3DS</H3>
<PRE>
public static boolean <B>useRotationPivotFrom3DS</B></PRE>
<DL>
<DD>By default, jPCT calculates a rotation pivot based on the mesh's geometry
 when calling build(). However, you might as well take the rotation pivot
 from the 3DS file. Setting this to true will force jPCT to use that pivot
 instead. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="useNormalsFromOBJ"><!-- --></A><H3>
useNormalsFromOBJ</H3>
<PRE>
public static boolean <B>useNormalsFromOBJ</B></PRE>
<DL>
<DD>By default, jPCT calculates normals based on the mesh's geometry when
 calling build(). However, you might as well take the normals from an
 OBJ-file. Setting this to true will force jPCT to use these normals
 instead. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="oldStyleBillBoarding"><!-- --></A><H3>
oldStyleBillBoarding</H3>
<PRE>
public static boolean <B>oldStyleBillBoarding</B></PRE>
<DL>
<DD>jPCT 1.15+ features a fixed bill boarding approach for
 child/parent-relations between objects. However, an application may rely
 on the former approach. By setting this to true, you can mimic the old
 behaviour. Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoBuild"><!-- --></A><H3>
autoBuild</H3>
<PRE>
public static boolean <B>autoBuild</B></PRE>
<DL>
<DD>Usually, one have to call build() on all objects that have to be
 rendered. By setting this to true, jPCT will do this automatically if you
 omit it. However, this may cause problems with applications that rely
 (for whatever reason) on unbuild objects. Therefore, it's false by
 default.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="blendAlphaIfOversampling"><!-- --></A><H3>
blendAlphaIfOversampling</H3>
<PRE>
public static boolean <B>blendAlphaIfOversampling</B></PRE>
<DL>
<DD>If set to true, alpha values will be blended just as colors do when using
 oversampling in the software renderer. When set to false, they won't.
 Default is false.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="nativeBufferSize"><!-- --></A><H3>
nativeBufferSize</H3>
<PRE>
public static int <B>nativeBufferSize</B></PRE>
<DL>
<DD>The size in kb of the native buffer cache. Setting this to 0 will turn
 native buffer caching off. Setting this to a very high value may lead,
 depending on the application, to a kind of memory leak. Default is 1024.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="synchronizedRendering"><!-- --></A><H3>
synchronizedRendering</H3>
<PRE>
public static boolean <B>synchronizedRendering</B></PRE>
<DL>
<DD>Only applies to multi-threaded renderers. If set to true, each buffer has
 to be rendered before being filled with data again. If false, the
 rendering might skip buffers if filling is much faster than rendering.
 Default is false.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getVersion()"><!-- --></A><H3>
getVersion</H3>
<PRE>
public static java.lang.String <B>getVersion</B>()</PRE>
<DL>
<DD>Returns the version of this release. Use this instead of VERSION.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current version</DL>
</DD>
</DL>
<HR>

<A NAME="setParameterValue(java.lang.String, java.lang.Object)"><!-- --></A><H3>
setParameterValue</H3>
<PRE>
public static void <B>setParameterValue</B>(java.lang.String&nbsp;name,
                                     java.lang.Object&nbsp;value)</PRE>
<DL>
<DD>Sets a parameter with the given name to a value. This method can be used
 to access the configuration variables via their names instead of setting
 them directly. This is more suitable for setting them from some
 configuration file's data, but its slower than direct access, because it
 uses reflection.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name<DD><CODE>value</CODE> - the value</DL>
</DD>
</DL>
<HR>

<A NAME="getParameterValue(java.lang.String)"><!-- --></A><H3>
getParameterValue</H3>
<PRE>
public static java.lang.Object <B>getParameterValue</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Gets the current value of the parameter with the given name. Because if
 type of the value is unknown, this method simply returns an Object. It's
 up to you to convert it correctly.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name
<DT><B>Returns:</B><DD>the value</DL>
</DD>
</DL>
<HR>

<A NAME="getParameterNames()"><!-- --></A><H3>
getParameterNames</H3>
<PRE>
public static java.lang.String[] <B>getParameterNames</B>()</PRE>
<DL>
<DD>Returns the names of all public fields in Config, all configuration
 options.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the names in no particular order</DL>
</DD>
</DL>
<HR>

<A NAME="tuneForIndoor()"><!-- --></A><H3>
tuneForIndoor</H3>
<PRE>
public static void <B>tuneForIndoor</B>()</PRE>
<DL>
<DD>Enables a preset configuration for indoor-rendering. This method assumes
 that portal rendering should be used too, so it sets this to true. Keep
 this in mind when using this method in applications that don't use portal
 rendering. This method doesn't do anything more than setting the
 configuration variables to the most common indoor settings. Not all
 variables are affected by this.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="tuneForOutdoor()"><!-- --></A><H3>
tuneForOutdoor</H3>
<PRE>
public static void <B>tuneForOutdoor</B>()</PRE>
<DL>
<DD>Enables a preset configuration for outdoor-rendering. This method doesn't
 do anything more than setting the configuration variables to the most
 common outdoor settings. Not all variables are affected by this.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glSetDesiredVideoMode(int, int, int, boolean)"><!-- --></A><H3>
glSetDesiredVideoMode</H3>
<PRE>
public static void <B>glSetDesiredVideoMode</B>(int&nbsp;colorDepth,
                                         int&nbsp;zDepth,
                                         int&nbsp;refresh,
                                         boolean&nbsp;fullscreen)</PRE>
<DL>
<DD>This static method should help to set the desired video-mode for OpenGL.
 All this method does is to set glXXXX-Parameters accordingly but it may
 look cleaner in an application to use this method instead of accessing
 all four configuration parameters directly. These settings have to be
 changed before enabling the OpenGL renderer to have an effect. Setting
 the values does in no way guarantee that a mode with these settings is
 available. The resolution is not set here but taken from the dimensions
 of the framebuffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>colorDepth</CODE> - the colordepth in bits<DD><CODE>zDepth</CODE> - the depth of the z-buffer in bits<DD><CODE>refresh</CODE> - the refresh rate<DD><CODE>fullscreen</CODE> - fullscreen should be used (true) or not (false)</DL>
</DD>
</DL>
<HR>

<A NAME="glSetDesiredVideoMode(com.threed.jpct.VideoMode, boolean)"><!-- --></A><H3>
glSetDesiredVideoMode</H3>
<PRE>
public static void <B>glSetDesiredVideoMode</B>(<A HREF="../../../com/threed/jpct/VideoMode.html" title="class in com.threed.jpct">VideoMode</A>&nbsp;vm,
                                         boolean&nbsp;fullscreen)</PRE>
<DL>
<DD>This static method should help to set the desired video-mode for OpenGL.
 All this method does is to set glXXXX-Parameters accordingly but it may
 look cleaner in an application to use this method instead of accessing
 all four configuration parameters directly. These settings have to be
 changed before enabling the OpenGL renderer to have an effect. Setting
 the values does in no way guarantee that a mode with these settings is
 available. The resolution is not set here but taken from the dimensions
 of the framebuffer.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vm</CODE> - the video-mode to be set<DD><CODE>fullscreen</CODE> - fullscreen should be used (true) or not (false)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)"><CODE>FrameBuffer.getVideoModes(int)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/CollisionEvent.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/DeSerializer.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Config.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
