<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Mon Nov 03 19:17:41 GMT 2014 -->
<TITLE>
FrameBuffer
</TITLE>

<META NAME="keywords" CONTENT="com.threed.jpct.FrameBuffer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="FrameBuffer";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/DeSerializer.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/GenericVertexController.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FrameBuffer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class FrameBuffer</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>com.threed.jpct.FrameBuffer</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public class <B>FrameBuffer</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>

<P>
The FrameBuffer class provides a buffer into which jPCT renders the scene.
 The result is basically an Image which could be displayed or modified even
 further using some post-processing. The FrameBuffer's constructor
 automatically distinguishes between JAVA2 and earlier versions. JAVA2 and
 higher will use a BufferedImage as FrameBuffer while JAVA1.1 will use a
 MemoryImageSource. When using support for OpenGL hardware rendering only, the
 image is not rendered into the FrameBuffer's internal pixel-array but
 directly into the video-RAM of the graphics card. Therefor, some methods
 within this class will execute quite slow if they have to access the VRAM.
 This will be mentioned in these methods.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#com.threed.jpct.FrameBuffer">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BLITTING_TARGET_BACK">BLITTING_TARGET_BACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blitting is done into the back buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BLITTING_TARGET_FRONT">BLITTING_TARGET_FRONT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blitting is done into the front buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BOUNDINGBOX_NOT_USED">BOUNDINGBOX_NOT_USED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Don't use a 2D bounding box. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BOUNDINGBOX_USED">BOUNDINGBOX_USED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use a 2D bounding box for speeding up blitting (only useful when the
 rendered scene doesn't cover the whole framebuffer)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFER_ACCESS_COMBINED">BUFFER_ACCESS_COMBINED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access the framebuffer in one way (default)...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFER_ACCESS_SPLITTED">BUFFER_ACCESS_SPLITTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access the framebuffer in another way)...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFEREDIMAGE">BUFFEREDIMAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The type of this FrameBuffer is a BufferedImage (JAVA2)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#MEMORYIMAGESOURCE">MEMORYIMAGESOURCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The type of this FrameBuffer is a MemoryImageSource (JAVA1.1)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING">OPAQUE_BLITTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D texture-blitting into the framebuffer is done by copying the source
 1-to-1 into the destination bitmap</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_2X">SAMPLINGMODE_GL_AA_2X</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use 2x anti aliasing when using the OpenGL renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_4X">SAMPLINGMODE_GL_AA_4X</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use 4x anti aliasing when using the OpenGL renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_HARDWARE_ONLY">SAMPLINGMODE_HARDWARE_ONLY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A special sampling mode that indicates, that no software rendering will
 be used on this framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_NORMAL">SAMPLINGMODE_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normal sampling mode (1-to-1)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS">SAMPLINGMODE_OGSS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use 2x2 oriented grid oversampling (FSAA using supersampling) for the
 software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS_FAST">SAMPLINGMODE_OGSS_FAST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use 1.5x1.5 oriented grid oversampling (FSAA using supersampling) for the
 software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGUS">SAMPLINGMODE_OGUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use 0.5x0.5 oriented grid undersampling (to upsample an image rendered at
 a lower resolution)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SUPPORT_FOR_RGB_SCALING">SUPPORT_FOR_RGB_SCALING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use this to check if all the currently enabled renderers support
 RGB-scaling</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SUPPORT_FOR_SHADOW_MAPPING">SUPPORT_FOR_SHADOW_MAPPING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use this to check if all the currently enabled renderers support shadow
 mapping</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#SYNCHRONIZER">SYNCHRONIZER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An Object to which jPCT synchronizes all critical calls to Display, Mouse
 and Keyboard from LWJGL to. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING">TRANSPARENT_BLITTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D texture-blitting into the framebuffer is done by copying the source
 into the destination bitmap only at places where the sources bitmap has
 none-zero color-values.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#FrameBuffer(int, int, int)">FrameBuffer</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;oversample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new framebuffer with a width of x and a height of y using the
 given samplingmode. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#addPostProcessor(com.threed.jpct.IPostProcessor)">addPostProcessor</A></B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an IPostProcessor to run a post processing on the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(int[], int, int, int, int, int, int, int, int, boolean)">blit</A></B>(int[]&nbsp;src,
     int&nbsp;srcWidth,
     int&nbsp;srcHeight,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;width,
     int&nbsp;height,
     boolean&nbsp;transparent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a part of a bitmap (taken from an int[] containing pixels in
 RGB-format and with no alpha) into the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;width,
     int&nbsp;height,
     boolean&nbsp;transparent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a part of a bitmap (taken from a Texture in this case) into the
 framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;sourceWidth,
     int&nbsp;sourceHeight,
     int&nbsp;destWidth,
     int&nbsp;destHeight,
     int&nbsp;transValue,
     boolean&nbsp;additive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, java.awt.Color)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;sourceWidth,
     int&nbsp;sourceHeight,
     int&nbsp;destWidth,
     int&nbsp;destHeight,
     int&nbsp;transValue,
     boolean&nbsp;additive,
     java.awt.Color&nbsp;addColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, com.threed.jpct.RGBColor)">blit</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
     int&nbsp;srcX,
     int&nbsp;srcY,
     int&nbsp;destX,
     int&nbsp;destY,
     int&nbsp;sourceWidth,
     int&nbsp;sourceHeight,
     int&nbsp;destWidth,
     int&nbsp;destHeight,
     int&nbsp;transValue,
     boolean&nbsp;additive,
     <A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;addColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method to maintain compatibility with jPCT-AE. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the framebuffer, the optiZ-buffer, the hsr-buffer and the regular
 z-buffer if required. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clear(java.awt.Color)">clear</A></B>(java.awt.Color&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the framebuffer, the optiZ-buffer, the hsr-buffer and the regular
 z-buffer if required. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clear(int)">clear</A></B>(int&nbsp;rgb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The same as clear(&lt;Color&gt;) but with an int-value instead of a color
 instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clearColorBufferOnly(java.awt.Color)">clearColorBufferOnly</A></B>(java.awt.Color&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears only the color bufferr, not the depth buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#clearZBufferOnly()">clearZBufferOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears only the ZBuffer, not the color buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#disableRenderer(int)">disableRenderer</A></B>(int&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables a renderer for this framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#display()">display</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The same as displayGLOnly. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#display(java.awt.Graphics)">display</A></B>(java.awt.Graphics&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the output Image onto the component with the given Graphics
 context. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#display(java.awt.Graphics, int)">display</A></B>(java.awt.Graphics&nbsp;g,
        int&nbsp;yOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the output Image onto the component with the given Graphics
 context. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#display(java.awt.Graphics, int, int)">display</A></B>(java.awt.Graphics&nbsp;g,
        int&nbsp;xOffset,
        int&nbsp;yOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the output Image onto the component with the given Graphics
 context. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#displayGLOnly()">displayGLOnly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Displays the output image produced by OpenGL compatible hardware if
 OpenGL rendering is in use. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Has to be called before this FrameBuffer won't be used anymore to do some
 clean up work. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Canvas</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#enableGLCanvasRenderer()">enableGLCanvasRenderer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables an OpenGL renderer that will render into a canvas. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#enableRenderer(int)">enableRenderer</A></B>(int&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a renderer (OpenGL or software) in OpenGL-lighting mode.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#enableRenderer(int, int)">enableRenderer</A></B>(int&nbsp;renderer,
               int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a renderer (OpenGL or software) in the desired mode. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#flush()">flush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does nothing. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Graphics</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getGraphics()">getGraphics</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Graphics object of the output buffer to allow the use of
 JAVA's standard graphic methods on the rendered image (like drawString).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getHeight()">getHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The same as getOutputHeight(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getID()">getID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a unique ID for this FrameBuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getLock()">getLock</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the lock object for the frame buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getMaxTextureSize()">getMaxTextureSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the maximum texture size that the current renderers support.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getMiddleX()">getMiddleX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-coord of the midpoint of the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getMiddleY()">getMiddleY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-coord of the midpoint of the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Image</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputBuffer()">getOutputBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Image that represents the output-buffer of the framebuffer.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputHeight()">getOutputHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height of the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputWidth()">getOutputWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width of the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels()">getPixels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the raw pixel-data. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getSamplingMode()">getSamplingMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the used sampling mode for this framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getType()">getType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the type of this FrameBuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/VideoMode.html" title="class in com.threed.jpct">VideoMode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)">getVideoModes</A></B>(int&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method to get the video modes a renderer (i.e. the hardware it's
 running on) supports. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#getWidth()">getWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The same as getOutputWidth(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#isInitialized()">isInitialized</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the FrameBuffer and all its enabled renderers have been
 initialized correctly. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#optimizeBufferAccess()">optimizeBufferAccess</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method tries to pick the most optimal buffer access mode for the
 system jPCT is currently running on. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#refresh()">refresh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forces the framebuffer to update its content with what's in the
 pixels-array. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removeAllPostProcessors()">removeAllPostProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all post processors from the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removeClippingPlane(int)">removeClippingPlane</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an additional clipping plane.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removePostProcessor(com.threed.jpct.IPostProcessor)">removePostProcessor</A></B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a post processor from the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#removeRenderTarget()">removeRenderTarget</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the render target from the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#resize(int, int)">resize</A></B>(int&nbsp;width,
       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does a resize of the FrameBuffer in case that the output window's size
 has changed. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#runPostProcessors()">runPostProcessors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Runs all post processors that have been added to this framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBlittingTarget(int)">setBlittingTarget</A></B>(int&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the blitting target to either the front (default) or the back
 buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBoundingBoxMode(boolean)">setBoundingBoxMode</A></B>(boolean&nbsp;bmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the bounding box mode for the framebuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBufferAccess(int)">setBufferAccess</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When using the software renderer, the framebuffer can be accessed in
 different ways. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setClippingPlane(int, com.threed.jpct.Plane)">setClippingPlane</A></B>(int&nbsp;number,
                 <A HREF="../../../com/threed/jpct/Plane.html" title="class in com.threed.jpct">Plane</A>&nbsp;plane)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an additional clipping plane. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setPaintListener(com.threed.jpct.IPaintListener)">setPaintListener</A></B>(<A HREF="../../../com/threed/jpct/IPaintListener.html" title="interface in com.threed.jpct">IPaintListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a listener to all currently used renderers. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setPaintListenerState(boolean)">setPaintListenerState</A></B>(boolean&nbsp;isActive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the state of the paint listener. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(int)">setRenderTarget</A></B>(int&nbsp;texID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(int, int, int, int, int, boolean)">setRenderTarget</A></B>(int&nbsp;texID,
                int&nbsp;left,
                int&nbsp;top,
                int&nbsp;right,
                int&nbsp;bottom,
                boolean&nbsp;clearAll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(com.threed.jpct.Texture)">setRenderTarget</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setRenderTarget(com.threed.jpct.Texture, int, int, int, int, boolean)">setRenderTarget</A></B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex,
                int&nbsp;left,
                int&nbsp;top,
                int&nbsp;right,
                int&nbsp;bottom,
                boolean&nbsp;clearAll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the render target of the framebuffer to a texture. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#setVirtualDimensions(int, int)">setVirtualDimensions</A></B>(int&nbsp;width,
                     int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This has a meaning only if a render target has been set. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#supports(java.lang.String)">supports</A></B>(java.lang.String&nbsp;feature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a feature is supported by all the renderers of this
 framebuffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#sync()">sync</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does nothing. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#update()">update</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Updates the output buffer of the framebuffer with the new data from the
 backbuffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/FrameBuffer.html#usesRenderer(int)">usesRenderer</A></B>(int&nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests if the given renderer is used by this framebuffer.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MEMORYIMAGESOURCE"><!-- --></A><H3>
MEMORYIMAGESOURCE</H3>
<PRE>
public static final int <B>MEMORYIMAGESOURCE</B></PRE>
<DL>
<DD>The type of this FrameBuffer is a MemoryImageSource (JAVA1.1)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.MEMORYIMAGESOURCE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUFFEREDIMAGE"><!-- --></A><H3>
BUFFEREDIMAGE</H3>
<PRE>
public static final int <B>BUFFEREDIMAGE</B></PRE>
<DL>
<DD>The type of this FrameBuffer is a BufferedImage (JAVA2)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BUFFEREDIMAGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_GL_AA_4X"><!-- --></A><H3>
SAMPLINGMODE_GL_AA_4X</H3>
<PRE>
public static final int <B>SAMPLINGMODE_GL_AA_4X</B></PRE>
<DL>
<DD>Use 4x anti aliasing when using the OpenGL renderer. Don't use this on a
 framebuffer that's supposed to be used by the software renderer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_GL_AA_4X">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_GL_AA_2X"><!-- --></A><H3>
SAMPLINGMODE_GL_AA_2X</H3>
<PRE>
public static final int <B>SAMPLINGMODE_GL_AA_2X</B></PRE>
<DL>
<DD>Use 2x anti aliasing when using the OpenGL renderer. Don't use this on a
 framebuffer that's supposed to be used by the software renderer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_GL_AA_2X">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_OGSS"><!-- --></A><H3>
SAMPLINGMODE_OGSS</H3>
<PRE>
public static final int <B>SAMPLINGMODE_OGSS</B></PRE>
<DL>
<DD>Use 2x2 oriented grid oversampling (FSAA using supersampling) for the
 software renderer. This mode shouldn't be used for the OpenGL renderer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_OGSS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_OGSS_FAST"><!-- --></A><H3>
SAMPLINGMODE_OGSS_FAST</H3>
<PRE>
public static final int <B>SAMPLINGMODE_OGSS_FAST</B></PRE>
<DL>
<DD>Use 1.5x1.5 oriented grid oversampling (FSAA using supersampling) for the
 software renderer. This mode shouldn't be used for the OpenGL renderer.
 This mode is faster then "normal" 2x2 oversampling, but image quality is
 a bit lower.<br>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_OGSS_FAST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_OGUS"><!-- --></A><H3>
SAMPLINGMODE_OGUS</H3>
<PRE>
public static final int <B>SAMPLINGMODE_OGUS</B></PRE>
<DL>
<DD>Use 0.5x0.5 oriented grid undersampling (to upsample an image rendered at
 a lower resolution)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_OGUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_NORMAL"><!-- --></A><H3>
SAMPLINGMODE_NORMAL</H3>
<PRE>
public static final int <B>SAMPLINGMODE_NORMAL</B></PRE>
<DL>
<DD>Normal sampling mode (1-to-1)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_NORMAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SAMPLINGMODE_HARDWARE_ONLY"><!-- --></A><H3>
SAMPLINGMODE_HARDWARE_ONLY</H3>
<PRE>
public static final int <B>SAMPLINGMODE_HARDWARE_ONLY</B></PRE>
<DL>
<DD>A special sampling mode that indicates, that no software rendering will
 be used on this framebuffer. OpenGL support will work with any other
 sampling mode though (but the sampling modes may not affect the OpenGL
 output).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SAMPLINGMODE_HARDWARE_ONLY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BOUNDINGBOX_USED"><!-- --></A><H3>
BOUNDINGBOX_USED</H3>
<PRE>
public static final boolean <B>BOUNDINGBOX_USED</B></PRE>
<DL>
<DD>Use a 2D bounding box for speeding up blitting (only useful when the
 rendered scene doesn't cover the whole framebuffer)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BOUNDINGBOX_USED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BOUNDINGBOX_NOT_USED"><!-- --></A><H3>
BOUNDINGBOX_NOT_USED</H3>
<PRE>
public static final boolean <B>BOUNDINGBOX_NOT_USED</B></PRE>
<DL>
<DD>Don't use a 2D bounding box. This mode should be used for indoor
 rendering.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BOUNDINGBOX_NOT_USED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OPAQUE_BLITTING"><!-- --></A><H3>
OPAQUE_BLITTING</H3>
<PRE>
public static final boolean <B>OPAQUE_BLITTING</B></PRE>
<DL>
<DD>2D texture-blitting into the framebuffer is done by copying the source
 1-to-1 into the destination bitmap
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.OPAQUE_BLITTING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENT_BLITTING"><!-- --></A><H3>
TRANSPARENT_BLITTING</H3>
<PRE>
public static final boolean <B>TRANSPARENT_BLITTING</B></PRE>
<DL>
<DD>2D texture-blitting into the framebuffer is done by copying the source
 into the destination bitmap only at places where the sources bitmap has
 none-zero color-values.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.TRANSPARENT_BLITTING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SUPPORT_FOR_RGB_SCALING"><!-- --></A><H3>
SUPPORT_FOR_RGB_SCALING</H3>
<PRE>
public static final java.lang.String <B>SUPPORT_FOR_RGB_SCALING</B></PRE>
<DL>
<DD>Use this to check if all the currently enabled renderers support
 RGB-scaling
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Lights.html#setRGBScale(int)"><CODE>Lights.setRGBScale(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#supports(java.lang.String)"><CODE>supports(java.lang.String)</CODE></A>, 
<A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SUPPORT_FOR_RGB_SCALING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SUPPORT_FOR_SHADOW_MAPPING"><!-- --></A><H3>
SUPPORT_FOR_SHADOW_MAPPING</H3>
<PRE>
public static final java.lang.String <B>SUPPORT_FOR_SHADOW_MAPPING</B></PRE>
<DL>
<DD>Use this to check if all the currently enabled renderers support shadow
 mapping
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#supports(java.lang.String)"><CODE>supports(java.lang.String)</CODE></A>, 
<A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.SUPPORT_FOR_SHADOW_MAPPING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUFFER_ACCESS_COMBINED"><!-- --></A><H3>
BUFFER_ACCESS_COMBINED</H3>
<PRE>
public static final int <B>BUFFER_ACCESS_COMBINED</B></PRE>
<DL>
<DD>Access the framebuffer in one way (default)...
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBufferAccess(int)"><CODE>setBufferAccess(int)</CODE></A>, 
<A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BUFFER_ACCESS_COMBINED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUFFER_ACCESS_SPLITTED"><!-- --></A><H3>
BUFFER_ACCESS_SPLITTED</H3>
<PRE>
public static final int <B>BUFFER_ACCESS_SPLITTED</B></PRE>
<DL>
<DD>Access the framebuffer in another way)...
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBufferAccess(int)"><CODE>setBufferAccess(int)</CODE></A>, 
<A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BUFFER_ACCESS_SPLITTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BLITTING_TARGET_FRONT"><!-- --></A><H3>
BLITTING_TARGET_FRONT</H3>
<PRE>
public static final int <B>BLITTING_TARGET_FRONT</B></PRE>
<DL>
<DD>Blitting is done into the front buffer. This is default
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BLITTING_TARGET_FRONT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BLITTING_TARGET_BACK"><!-- --></A><H3>
BLITTING_TARGET_BACK</H3>
<PRE>
public static final int <B>BLITTING_TARGET_BACK</B></PRE>
<DL>
<DD>Blitting is done into the back buffer. This only affects blitting when
 the software renderer is used with over-/undersampling. For any other
 configuration, is the same as BLITTING_TARGET_FRONT.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.FrameBuffer.BLITTING_TARGET_BACK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SYNCHRONIZER"><!-- --></A><H3>
SYNCHRONIZER</H3>
<PRE>
public static final java.lang.Object <B>SYNCHRONIZER</B></PRE>
<DL>
<DD>An Object to which jPCT synchronizes all critical calls to Display, Mouse
 and Keyboard from LWJGL to. These classes are not thread safe, therefor
 it's required to avoid creating the Keyboard while creating the display
 (for example). If you ever do such things from other threads or are using
 jPCT's AWTGLRenderer or its build-in multithreading support, make sure to
 synchronize to this object when you are calling critical Keyboard-,
 Mouse- or Diplay-methods.<br>
 Of course, all this only applies to the hardware renderers.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="FrameBuffer(int, int, int)"><!-- --></A><H3>
FrameBuffer</H3>
<PRE>
public <B>FrameBuffer</B>(int&nbsp;x,
                   int&nbsp;y,
                   int&nbsp;oversample)</PRE>
<DL>
<DD>Creates a new framebuffer with a width of x and a height of y using the
 given samplingmode. For software rendering, the framebuffer can be of any
 size. For OpenGL, a size supported by the OpenGL compatible hardware one
 is using is required.
<P>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the width of the framebuffer<DD><CODE>y</CODE> - the height of the framebuffer<DD><CODE>oversample</CODE> - the samplingmode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS"><CODE>SAMPLINGMODE_OGSS</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS_FAST"><CODE>SAMPLINGMODE_OGSS_FAST</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGUS"><CODE>SAMPLINGMODE_OGUS</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_NORMAL"><CODE>SAMPLINGMODE_NORMAL</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_HARDWARE_ONLY"><CODE>SAMPLINGMODE_HARDWARE_ONLY</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_2X"><CODE>SAMPLINGMODE_GL_AA_2X</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_4X"><CODE>SAMPLINGMODE_GL_AA_4X</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#getVideoModes(int)"><CODE>getVideoModes(int)</CODE></A></DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="getID()"><!-- --></A><H3>
getID</H3>
<PRE>
public java.lang.Long <B>getID</B>()</PRE>
<DL>
<DD>Returns a unique ID for this FrameBuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Long the ID</DL>
</DD>
</DL>
<HR>

<A NAME="getVideoModes(int)"><!-- --></A><H3>
getVideoModes</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/VideoMode.html" title="class in com.threed.jpct">VideoMode</A>[] <B>getVideoModes</B>(int&nbsp;renderer)</PRE>
<DL>
<DD>Static method to get the video modes a renderer (i.e. the hardware it's
 running on) supports. This is useful for initializing the OpenGL renderer
 and the FrameBuffer. The z-buffer depth of the returned modes is taken
 from the z-buffer setting in Config and NOT from the driver of the video
 card, because the used OpenGL binding doesn't return this value
 anymore...so it's basically 'guessing' here... The software renderer
 doesn't have video modes, so it will return an empty array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer (only IRenderer.RENDERER_OPENGL makes sense at
            the moment)
<DT><B>Returns:</B><DD>the supported video modes<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IRenderer.html" title="interface in com.threed.jpct"><CODE>IRenderer</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glColorDepth"><CODE>Config.glColorDepth</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glZBufferDepth"><CODE>Config.glZBufferDepth</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glRefresh"><CODE>Config.glRefresh</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isInitialized()"><!-- --></A><H3>
isInitialized</H3>
<PRE>
public boolean <B>isInitialized</B>()</PRE>
<DL>
<DD>Checks if the FrameBuffer and all its enabled renderers have been
 initialized correctly. This is useful to check if OpenGL support has been
 enabled succesfully and if the desired videomode has been set.<br>
 When using the AWTGLRenderer, this method will return false until the
 first drawing (attempt) took place.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true, if the FrameBuffer is fine. Otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="setBlittingTarget(int)"><!-- --></A><H3>
setBlittingTarget</H3>
<PRE>
public void <B>setBlittingTarget</B>(int&nbsp;target)</PRE>
<DL>
<DD>Sets the blitting target to either the front (default) or the back
 buffer. This is required to allow blitting into the background of an
 over- or undersampled frame buffer. Any other configuration doesn't need
 this.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - the blitting target<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#BLITTING_TARGET_FRONT"><CODE>BLITTING_TARGET_FRONT</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#BLITTING_TARGET_BACK"><CODE>BLITTING_TARGET_BACK</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="enableRenderer(int)"><!-- --></A><H3>
enableRenderer</H3>
<PRE>
public void <B>enableRenderer</B>(int&nbsp;renderer)</PRE>
<DL>
<DD>Enables a renderer (OpenGL or software) in OpenGL-lighting mode.
 OpenGL-lighting mode is the recommended mode for the software as well as
 for the hardware renderer. However, jPCT constructs every new FrameBuffer
 as software/legacy for compatibility reasons. It is possible to use the
 software renderer as well as the OpenGL renderer on a single framebuffer
 at the same time, but it's not advised to do so, because this will
 disable some optimizations that are else made in case OpenGL is used
 (like T&L optimizations and triangle strips). To enable OpenGL without
 supporting the software renderer, the software renderer has to be
 disabled after enabling OpenGL.<br>
 <br>
 Important: NEVER change the renderer from outside the thread that is
 doing the rendering if you intend to use the OpenGL renderer, because
 this will cause your application to crash. This is a "feature" of LWJGL,
 so there's nothing jPCT can do about it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer that should be used to render this framebuffer<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#disableRenderer(int)"><CODE>disableRenderer(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#enableRenderer(int, int)"><CODE>enableRenderer(int, int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/IRenderer.html" title="interface in com.threed.jpct"><CODE>IRenderer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="enableGLCanvasRenderer()"><!-- --></A><H3>
enableGLCanvasRenderer</H3>
<PRE>
public java.awt.Canvas <B>enableGLCanvasRenderer</B>()</PRE>
<DL>
<DD>Enables an OpenGL renderer that will render into a canvas. For
 compatibility reasons, jPCT constructs every new FrameBuffer as
 software/legacy. It is possible to use the software renderer as well as
 the OpenGL renderer on a single framebuffer at the same time, but it's
 not advised to do so, because this will disable some optimizations that
 are else made in case OpenGL is used (like T&L optimizations and triangle
 strips). To enable OpenGL without supporting the software renderer, the
 software renderer has to be disabled after enabling OpenGL.<br>
 Using this renderer affects the behaviour of getPixels() and supports(),
 which will only return after the Canvas has been repainted. If this never
 happens for whatever reason, they'll never return! <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the Canvas<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#disableRenderer(int)"><CODE>disableRenderer(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#enableRenderer(int)"><CODE>enableRenderer(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#enableGLCanvasRenderer()"><CODE>enableGLCanvasRenderer()</CODE></A>, 
<A HREF="../../../com/threed/jpct/AWTGLRenderer.html" title="class in com.threed.jpct"><CODE>AWTGLRenderer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="enableRenderer(int, int)"><!-- --></A><H3>
enableRenderer</H3>
<PRE>
public void <B>enableRenderer</B>(int&nbsp;renderer,
                           int&nbsp;mode)</PRE>
<DL>
<DD>Enables a renderer (OpenGL or software) in the desired mode. For
 compatibility reasons, jPCT constructs every new FrameBuffer as
 software/opengl-alike. It is possible to use the software renderer as
 well as the OpenGL renderer on a single framebuffer at the same time, but
 it's not advised to do so, because this will disable some optimizations
 that are else made in case OpenGL is used (like T&L optimizations and
 triangle strips). To enable OpenGL without supporting the software
 renderer, the software renderer has to be disabled after enabling OpenGL.<br>
 <br>
 Important: NEVER change the renderer from outside the thread that is
 doing the rendering if you intend to use the OpenGL renderer, because
 this will cause your application to crash. This is a "feature" of LWJGL,
 so there's nothing jPCT can do about it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer that should be used to render this framebuffer<DD><CODE>mode</CODE> - the mode the renderer should use<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#disableRenderer(int)"><CODE>disableRenderer(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#enableRenderer(int)"><CODE>enableRenderer(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/IRenderer.html" title="interface in com.threed.jpct"><CODE>IRenderer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(int)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(int&nbsp;texID)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer, when FBO are
 not used/available. Rendering into a texture can be slow on some hardware
 like Intel onboard chipsets.<br>
 While the software renderer do support render targets, it can't run a
 post processor on them.<br>
 Make sure that the texture you are using as render target doesn't use mip
 mapping. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texID</CODE> - the ID of the texture to render into.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glUseFBO"><CODE>Config.glUseFBO</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFlipRenderTargets"><CODE>Config.glFlipRenderTargets</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(int, int, int, int, int, boolean)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(int&nbsp;texID,
                            int&nbsp;left,
                            int&nbsp;top,
                            int&nbsp;right,
                            int&nbsp;bottom,
                            boolean&nbsp;clearAll)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer, when FBO are
 not used/available. Rendering into a texture can be slow on some hardware
 like Intel onboard chipsets.<br>
 This is a special purpose version of this method that allows to define a
 border that isn't affected by the rendering. The software renderer
 doesn't support this border and ignores it.<br>
 Make sure that the texture you are using as render target doesn't use mip
 mapping. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texID</CODE> - the ID of the texture to render into.<DD><CODE>left</CODE> - the width of the left border<DD><CODE>top</CODE> - the width of the upper border<DD><CODE>right</CODE> - the width of the right border<DD><CODE>bottom</CODE> - the width of the lower border<DD><CODE>clearAll</CODE> - if true, the border won't affect the clearing of texture. If
            set to false, it will.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glUseFBO"><CODE>Config.glUseFBO</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFlipRenderTargets"><CODE>Config.glFlipRenderTargets</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(com.threed.jpct.Texture)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer, when FBO are
 not used/available. Rendering into a texture can be slow on some hardware
 like Intel onboard chipsets. While the software renderer do support
 render targets, it can't run a post processor on them.<br>
 Make sure that the texture you are using as render target doesn't use mip
 mapping. <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tex</CODE> - the texture to render into<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glUseFBO"><CODE>Config.glUseFBO</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFlipRenderTargets"><CODE>Config.glFlipRenderTargets</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setRenderTarget(com.threed.jpct.Texture, int, int, int, int, boolean)"><!-- --></A><H3>
setRenderTarget</H3>
<PRE>
public void <B>setRenderTarget</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;tex,
                            int&nbsp;left,
                            int&nbsp;top,
                            int&nbsp;right,
                            int&nbsp;bottom,
                            boolean&nbsp;clearAll)</PRE>
<DL>
<DD>Sets the render target of the framebuffer to a texture. From here on, all
 rendering is done into that texture instead of the actual framebuffer.
 The texture has to be smaller or equal to the framebuffer, when FBO are
 not used/available. Rendering into a texture can be slow on some hardware
 like Intel onboard chipsets. While the software renderer do support
 render targets, it can't run a post processor on them. A texture assigned
 as a render target will automatically treated as non-mipmapped. This is a
 special purpose version of this method that allows to define a border
 that isn't affected by the rendering. The software renderer doesn't
 support this border and ignores it.<br>
 <br>
 While possible, it's not recommended to blit into a render target.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tex</CODE> - the texture to render into<DD><CODE>left</CODE> - the width of the left border<DD><CODE>top</CODE> - the width of the upper border<DD><CODE>right</CODE> - the width of the right border<DD><CODE>bottom</CODE> - the width of the lower border<DD><CODE>clearAll</CODE> - if true, the border won't affect the clearing of texture. If
            set to false, it will.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glUseFBO"><CODE>Config.glUseFBO</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFlipRenderTargets"><CODE>Config.glFlipRenderTargets</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeRenderTarget()"><!-- --></A><H3>
removeRenderTarget</H3>
<PRE>
public void <B>removeRenderTarget</B>()</PRE>
<DL>
<DD>Removes the render target from the framebuffer. After this, all rendering
 is done into the framebuffer again. If no render target has been set,
 this method does nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setVirtualDimensions(int, int)"><!-- --></A><H3>
setVirtualDimensions</H3>
<PRE>
public void <B>setVirtualDimensions</B>(int&nbsp;width,
                                 int&nbsp;height)</PRE>
<DL>
<DD>This has a meaning only if a render target has been set. By default the
 fov calculations will use the render target's dimensions. With this, you
 can set some other dimensions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - the virtual width of the render target<DD><CODE>height</CODE> - the virtual height of the render target</DL>
</DD>
</DL>
<HR>

<A NAME="addPostProcessor(com.threed.jpct.IPostProcessor)"><!-- --></A><H3>
addPostProcessor</H3>
<PRE>
public void <B>addPostProcessor</B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</PRE>
<DL>
<DD>Adds an IPostProcessor to run a post processing on the framebuffer. This
 isn't done automatically but has to be triggered by the application by
 calling runPostProcessors() on this framebuffer. Enabling or disabling
 renderers on this framebuffer causes all post processors to be disposed
 and then removed from this framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>proc</CODE> - the post processor<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#runPostProcessors()"><CODE>runPostProcessors()</CODE></A>, 
<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removePostProcessor(com.threed.jpct.IPostProcessor)"><!-- --></A><H3>
removePostProcessor</H3>
<PRE>
public void <B>removePostProcessor</B>(<A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct">IPostProcessor</A>&nbsp;proc)</PRE>
<DL>
<DD>Removes a post processor from the framebuffer. The processor will be
 disposed and then removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>proc</CODE> - The post processor to be removed<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeAllPostProcessors()"><!-- --></A><H3>
removeAllPostProcessors</H3>
<PRE>
public void <B>removeAllPostProcessors</B>()</PRE>
<DL>
<DD>Removes all post processors from the framebuffer. The processors will be
 disposed and then removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="runPostProcessors()"><!-- --></A><H3>
runPostProcessors</H3>
<PRE>
public void <B>runPostProcessors</B>()</PRE>
<DL>
<DD>Runs all post processors that have been added to this framebuffer. A post
 processor is an implementation of the IPostProcessor interface and may or
 may not support hardware and software renderer. The processing is done on
 the framebuffer's back buffer in its current state, i.e. if you run it
 before blitting, the blitting won't be affected. If you run it
 afterwards, it will.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IPostProcessor.html" title="interface in com.threed.jpct"><CODE>IPostProcessor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setPaintListener(com.threed.jpct.IPaintListener)"><!-- --></A><H3>
setPaintListener</H3>
<PRE>
public void <B>setPaintListener</B>(<A HREF="../../../com/threed/jpct/IPaintListener.html" title="interface in com.threed.jpct">IPaintListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Adds a listener to all currently used renderers. The listener will be
 notified before the renderer starts to paint polygons and after it has
 finished.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - IPaintListener the listener or null to clear it</DL>
</DD>
</DL>
<HR>

<A NAME="setPaintListenerState(boolean)"><!-- --></A><H3>
setPaintListenerState</H3>
<PRE>
public void <B>setPaintListenerState</B>(boolean&nbsp;isActive)</PRE>
<DL>
<DD>Sets the state of the paint listener. If set to false, it won't be called
 even if assigned. The setting applies to all paint listeners on the
 currently acitve renderers. If you change a renderer, the new one will
 start with an active state regardless of this setting.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isActive</CODE> - is it active or sleeping?</DL>
</DD>
</DL>
<HR>

<A NAME="disableRenderer(int)"><!-- --></A><H3>
disableRenderer</H3>
<PRE>
public void <B>disableRenderer</B>(int&nbsp;renderer)</PRE>
<DL>
<DD>Disables a renderer for this framebuffer. Disabling all renderers doesn't
 make much sense, so usually one will disable the renderer that is not in
 use at the moment (software if OpenGL is used and vice versa). After
 enabling OpenGL, it is advised to disable the software renderer. While it
 is possible to enable both, the software renderer will disable some
 optimization that may be used in case of "OpenGL only" (like T&L
 optimizations and triangle strips).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IRenderer.html" title="interface in com.threed.jpct"><CODE>IRenderer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>Has to be called before this FrameBuffer won't be used anymore to do some
 clean up work. For example, if you are reusing a buffer variable to
 assign a new FrameBuffer for it, dispose the former one before doing so.
 Java2 would allow to use a weak reference to handle this better, but jPCT
 is 1.1 compatible, so...
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="usesRenderer(int)"><!-- --></A><H3>
usesRenderer</H3>
<PRE>
public boolean <B>usesRenderer</B>(int&nbsp;renderer)</PRE>
<DL>
<DD>Tests if the given renderer is used by this framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderer</CODE> - the renderer to test
<DT><B>Returns:</B><DD>true if it's in use, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IRenderer.html" title="interface in com.threed.jpct"><CODE>IRenderer</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMaxTextureSize()"><!-- --></A><H3>
getMaxTextureSize</H3>
<PRE>
public int <B>getMaxTextureSize</B>()</PRE>
<DL>
<DD>Gets the maximum texture size that the current renderers support.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the size</DL>
</DD>
</DL>
<HR>

<A NAME="supports(java.lang.String)"><!-- --></A><H3>
supports</H3>
<PRE>
public boolean <B>supports</B>(java.lang.String&nbsp;feature)</PRE>
<DL>
<DD>Checks if a feature is supported by all the renderers of this
 framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>feature</CODE> - the feature that may be supported
<DT><B>Returns:</B><DD>is the feature supported<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#SUPPORT_FOR_RGB_SCALING"><CODE>SUPPORT_FOR_RGB_SCALING</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SUPPORT_FOR_SHADOW_MAPPING"><CODE>SUPPORT_FOR_SHADOW_MAPPING</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSamplingMode()"><!-- --></A><H3>
getSamplingMode</H3>
<PRE>
public int <B>getSamplingMode</B>()</PRE>
<DL>
<DD>Returns the used sampling mode for this framebuffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sampling mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_NORMAL"><CODE>SAMPLINGMODE_NORMAL</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS"><CODE>SAMPLINGMODE_OGSS</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGSS_FAST"><CODE>SAMPLINGMODE_OGSS_FAST</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_OGUS"><CODE>SAMPLINGMODE_OGUS</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_HARDWARE_ONLY"><CODE>SAMPLINGMODE_HARDWARE_ONLY</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_2X"><CODE>SAMPLINGMODE_GL_AA_2X</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#SAMPLINGMODE_GL_AA_4X"><CODE>SAMPLINGMODE_GL_AA_4X</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOutputWidth()"><!-- --></A><H3>
getOutputWidth</H3>
<PRE>
public int <B>getOutputWidth</B>()</PRE>
<DL>
<DD>Returns the width of the framebuffer. This method is called
 getOutputWidth(), because it returns the actual width used for output
 which is not always the internally used width.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the width of the framebuffer</DL>
</DD>
</DL>
<HR>

<A NAME="getOutputHeight()"><!-- --></A><H3>
getOutputHeight</H3>
<PRE>
public int <B>getOutputHeight</B>()</PRE>
<DL>
<DD>Returns the height of the framebuffer. This method is called
 getOutputHeight(), because it returns the height actual used for output
 which is not always the internally used height.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the height of the framebuffer</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A><H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD>The same as getOutputHeight(). Mainly here to increase compatibility with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the height</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A><H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD>The same as getOutputWidth(). Mainly here to increase compatibility with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the width</DL>
</DD>
</DL>
<HR>

<A NAME="getMiddleX()"><!-- --></A><H3>
getMiddleX</H3>
<PRE>
public float <B>getMiddleX</B>()</PRE>
<DL>
<DD>Returns the x-coord of the midpoint of the framebuffer. This value
 represents the internally used width/2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-coord</DL>
</DD>
</DL>
<HR>

<A NAME="getMiddleY()"><!-- --></A><H3>
getMiddleY</H3>
<PRE>
public float <B>getMiddleY</B>()</PRE>
<DL>
<DD>Returns the y-coord of the midpoint of the framebuffer. This value
 represents the internally used height/2.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-coord</DL>
</DD>
</DL>
<HR>

<A NAME="setBoundingBoxMode(boolean)"><!-- --></A><H3>
setBoundingBoxMode</H3>
<PRE>
public void <B>setBoundingBoxMode</B>(boolean&nbsp;bmode)</PRE>
<DL>
<DD>Sets the bounding box mode for the framebuffer. This has nothing to do
 with 3d bounding boxes. The framebuffer's bounding box may help to speed
 up blitting when parts of the framebuffer remain empty in a scene. It's
 rather useless when doing indoor rendering. Default is BOUNDINGBOX_USED.
 The bounding box is (apart from this setting) only used if the
 framebuffer works with an MemoryImageSource. If it uses BufferedImage
 (for JAVA2 or higher) and/or OpenGL support, the bounding box won't be
 used at all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bmode</CODE> - the bounding box mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#BOUNDINGBOX_NOT_USED"><CODE>BOUNDINGBOX_NOT_USED</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#BOUNDINGBOX_USED"><CODE>BOUNDINGBOX_USED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clears the framebuffer, the optiZ-buffer, the hsr-buffer and the regular
 z-buffer if required. Depending on the used configuration, not all of
 these steps are required.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearZBufferOnly()"><!-- --></A><H3>
clearZBufferOnly</H3>
<PRE>
public void <B>clearZBufferOnly</B>()</PRE>
<DL>
<DD>Clears only the ZBuffer, not the color buffer. Can be useful for special
 effects like rendering two worlds into one frame buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearColorBufferOnly(java.awt.Color)"><!-- --></A><H3>
clearColorBufferOnly</H3>
<PRE>
public void <B>clearColorBufferOnly</B>(java.awt.Color&nbsp;col)</PRE>
<DL>
<DD>Clears only the color bufferr, not the depth buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - the fill color</DL>
</DD>
</DL>
<HR>

<A NAME="clear(java.awt.Color)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(java.awt.Color&nbsp;col)</PRE>
<DL>
<DD>Clears the framebuffer, the optiZ-buffer, the hsr-buffer and the regular
 z-buffer if required. Depending on the used configuration, not all of
 these steps are required. Addionally, the framebuffer is filled with the
 given color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - the color the framebuffer is filled with</DL>
</DD>
</DL>
<HR>

<A NAME="clear(int)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(int&nbsp;rgb)</PRE>
<DL>
<DD>The same as clear(&lt;Color&gt;) but with an int-value instead of a color
 instance.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgb</CODE> - the color the framebuffer is filled with</DL>
</DD>
</DL>
<HR>

<A NAME="update()"><!-- --></A><H3>
update</H3>
<PRE>
public void <B>update</B>()</PRE>
<DL>
<DD>Updates the output buffer of the framebuffer with the new data from the
 backbuffer. This method should be called before actually displaying the
 rendered image to make sure that the latest changes to the image are
 recognized. Depending on the configuration, some post-processing may take
 place here too.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBufferAccess(int)"><!-- --></A><H3>
setBufferAccess</H3>
<PRE>
public void <B>setBufferAccess</B>(int&nbsp;mode)</PRE>
<DL>
<DD>When using the software renderer, the framebuffer can be accessed in
 different ways. One is faster on one cpu/VM while the other may be faster
 on another one. You may want to play around with this setting to get the
 best possible performance on your system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the buffer access mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#optimizeBufferAccess()"><CODE>optimizeBufferAccess()</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFER_ACCESS_COMBINED"><CODE>BUFFER_ACCESS_COMBINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFER_ACCESS_SPLITTED"><CODE>BUFFER_ACCESS_SPLITTED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="optimizeBufferAccess()"><!-- --></A><H3>
optimizeBufferAccess</H3>
<PRE>
public void <B>optimizeBufferAccess</B>()</PRE>
<DL>
<DD>This method tries to pick the most optimal buffer access mode for the
 system jPCT is currently running on. This method will run for a second
 and sets the buffer mode to the fastest possible based on that
 measurement.<br>
 There are two problems with this: Hotspot may interfere and renders the
 measurement useless and some VMs on some machines (like the 1.4.2 on a
 P4HT) will start fast with method A but performance will drop after some
 seconds (for whatever reason) and suddenly, method B would be (much!)
 faster. This bug in some VMs (i assume that it is one) is the reason why
 this method exists at all.<br>
 This method is useful for software rendering only.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#setBufferAccess(int)"><CODE>setBufferAccess(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOutputBuffer()"><!-- --></A><H3>
getOutputBuffer</H3>
<PRE>
public java.awt.Image <B>getOutputBuffer</B>()</PRE>
<DL>
<DD>Returns the Image that represents the output-buffer of the framebuffer.
 This could be used for further processing, displaying etc. It is meant as
 an alternative to display(). One don't have to get this image from the
 framebuffer every frame as it remains the same instance as long as the
 framebuffer instance exists.<br>
 When using OpenGL only, this method is very slow because it requires
 reads from VRAM. When using OpenGL and software rendering together (this
 is not advised, but it's possible), this method returns the software
 rendered buffer as if OpenGL wouldn't be used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the output image<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#display(java.awt.Graphics)"><CODE>display(java.awt.Graphics g)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPixels()"><!-- --></A><H3>
getPixels</H3>
<PRE>
public int[] <B>getPixels</B>()</PRE>
<DL>
<DD>Returns the raw pixel-data. This can be useful, if one wants to copy
 parts of the FrameBuffer into an Image out of jPCT's focus. getPixels()
 should be called after calling update(), because otherwise it is not
 guaranteed that the returned array contains the most current pixels. If
 you want to modify this array directly in your code (to apply some
 post-processing for example) keep two things in mind: This is ugly (but
 who cares...) and make sure to call refresh() afterwards. The returned
 array contains the pixel-data in RGB-format and with no alpha
 information.<br>
 When using OpenGL only, this method is very slow, because it has to read
 all the pixels out of the VRAM and write them into the FrameBuffer's
 internal pixel-buffer. When using OpenGL and software rendering together
 (this is not advised, but it's possible), this method returns the
 software rendered pixel-data as if OpenGL wouldn't be used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the pixels-array<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#update()"><CODE>update()</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#refresh()"><CODE>refresh()</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)"><CODE>blit(com.threed.jpct.Texture src, int srcX, int srcY, int destX,
      int destY, int width, int height, boolean transparent)</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#blit(int[], int, int, int, int, int, int, int, int, boolean)"><CODE>blit(int[] src, int srcWidth, int srcHeight, int srcX, int srcY,
      int destX, int destY, int width, int height, boolean transparent)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="refresh()"><!-- --></A><H3>
refresh</H3>
<PRE>
public void <B>refresh</B>()</PRE>
<DL>
<DD>Forces the framebuffer to update its content with what's in the
 pixels-array. This can be used to modify the framebuffer's content "from
 the outside". If you are not modifying the pixels-array in your code,
 there's no need to call this method.<br>
 Currently, this method works only when software rendering is being used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels()"><CODE>getPixels()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resize(int, int)"><!-- --></A><H3>
resize</H3>
<PRE>
public void <B>resize</B>(int&nbsp;width,
                   int&nbsp;height)</PRE>
<DL>
<DD>Does a resize of the FrameBuffer in case that the output window's size
 has changed. This isn't supported by the software renderer ATM and will
 be silently ignored if called for it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - the new width<DD><CODE>height</CODE> - the new height</DL>
</DD>
</DL>
<HR>

<A NAME="getLock()"><!-- --></A><H3>
getLock</H3>
<PRE>
public java.lang.Object <B>getLock</B>()</PRE>
<DL>
<DD>Returns the lock object for the frame buffer. When using a multi threaded
 renderer (like the AWTGLRenderer) in combination with dynamically
 compiled objects, it is advised to synchronize changes to the object's
 mesh data and/or texture data to this object to avoid to render inbetween
 states of the changes.<br>
 If this is called on a frame buffer using a single threaded renderer, it
 will return an Object too and you can still synchronize on it...just no
 other code inside jPCT will.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the lock object</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphics()"><!-- --></A><H3>
getGraphics</H3>
<PRE>
public java.awt.Graphics <B>getGraphics</B>()</PRE>
<DL>
<DD>Returns the Graphics object of the output buffer to allow the use of
 JAVA's standard graphic methods on the rendered image (like drawString).
 This works only for BufferedImage (using JAVA1.2 or higher) but not for
 the MemoryImageSource that is used for JAVA1.1. In this case, null will
 be returned. When using OpenGL support, this value is rather meaningless
 (but still valid).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the Graphics object (or null for MemoryImageSource)</DL>
</DD>
</DL>
<HR>

<A NAME="getType()"><!-- --></A><H3>
getType</H3>
<PRE>
public int <B>getType</B>()</PRE>
<DL>
<DD>Returns the type of this FrameBuffer. This value doesn't reflect the fact
 that OpenGL is used or not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the type<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#MEMORYIMAGESOURCE"><CODE>MEMORYIMAGESOURCE</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#BUFFEREDIMAGE"><CODE>BUFFEREDIMAGE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, boolean)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;width,
                 int&nbsp;height,
                 boolean&nbsp;transparent)</PRE>
<DL>
<DD>Copies a part of a bitmap (taken from a Texture in this case) into the
 framebuffer. If you want your blitted content to lay on top of the
 rendered image, it has to be applied after calling update() on the
 buffer. This method is useful to copy 2D-GUI elements into the rendered
 image (or for similar tasks). Blitting in OpenGL mode requires that the
 current world has been rendered at least once into the framebuffer where
 the blitting should be applied to (for doing some intialization work).
 Usually, that shouldn't be a problem unless you are abusing jPCT as a
 "blitting engine" only. When using OpenGL, be sure that the texture's
 height is 2^x. Everything else might produce unpredictable results. This
 method should be prefered over the int[]-array-blit whenever possible.<br>
 Some graphics cards/drivers are having problems when blitting using a
 16bit z-buffer (albeit the z-buffer is not used for blitting). Have a
 look at Config.glFixedBlitting for a workaround.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>transparent</CODE> - black (or at least almost black) pixels won't be copied if
            this is set to TRANSPARENT_BLITTING. Any color-value which
            leads to a result of zero when "anded" with #f0f0f0 will be
            taken as black.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING"><CODE>TRANSPARENT_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING"><CODE>OPAQUE_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFixedBlitting"><CODE>Config.glFixedBlitting</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;sourceWidth,
                 int&nbsp;sourceHeight,
                 int&nbsp;destWidth,
                 int&nbsp;destHeight,
                 int&nbsp;transValue,
                 boolean&nbsp;additive)</PRE>
<DL>
<DD>Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale. In addition, it offers support
 for transparency, a different blending mode and an additional color. If
 you want your blitted content to lay on top of the rendered image, it has
 to be applied after calling update() on the buffer. This method is useful
 to copy 2D-GUI elements into the rendered image (or for similar tasks).
 Blitting in OpenGL mode requires that the current world has been rendered
 at least once into the framebuffer where the blitting should be applied
 to (for doing some intialization work). Usually, that shouldn't be a
 problem unless you are abusing jPCT as a "blitting engine" only. There is
 no int[]-array-version of this method.<br>
 Using this method is quite to similar to using the Overlay-class. In
 fact, using this method on a software rendered framebuffer results in an
 Overlay being used internally. The difference is, that Overlay takes care
 of itself and that it has a real depth.<br>
 Some graphics cards/drivers are having problems when blitting using a
 16bit z-buffer (albeit the z-buffer is not used for blitting). Have a
 look at Config.glFixedBlitting for a workaround.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>sourceWidth</CODE> - the width of the source region to copy<DD><CODE>sourceHeight</CODE> - the height of the source region to copy<DD><CODE>destWidth</CODE> - the width of the copied region in the destination bitmap<DD><CODE>destHeight</CODE> - the height of the copied region in the destination bitmap<DD><CODE>transValue</CODE> - the transparency value, -1 is none, 0 is highest transparency.
            Higher values mean less transparency.<DD><CODE>additive</CODE> - if true, the blending is additive, otherwise default<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glFixedBlitting"><CODE>Config.glFixedBlitting</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, java.awt.Color)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;sourceWidth,
                 int&nbsp;sourceHeight,
                 int&nbsp;destWidth,
                 int&nbsp;destHeight,
                 int&nbsp;transValue,
                 boolean&nbsp;additive,
                 java.awt.Color&nbsp;addColor)</PRE>
<DL>
<DD>Special version of blit() that allows for scaling, i.e. it doesn't make
 1-to-1 copies but can up- or down-scale. In addition, it offers support
 for transparency, a different blending mode and an additional color. If
 you want your blitted content to lay on top of the rendered image, it has
 to be applied after calling update() on the buffer. This method is useful
 to copy 2D-GUI elements into the rendered image (or for similar tasks).
 Blitting in OpenGL mode requires that the current world has been rendered
 at least once into the framebuffer where the blitting should be applied
 to (for doing some intialization work). Usually, that shouldn't be a
 problem unless you are abusing jPCT as a "blitting engine" only. There is
 no int[]-array-version of this method.<br>
 Using this method is quite to similar to using the Overlay-class. In
 fact, using this method on a software rendered framebuffer results in an
 Overlay being used internally. The difference is, that Overlay takes care
 of itself and that it has a real depth.<br>
 Some graphics cards/drivers are having problems when blitting using a
 16bit z-buffer (albeit the z-buffer is not used for blitting). Have a
 look at Config.glFixedBlitting for a workaround.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>sourceWidth</CODE> - the width of the source region to copy<DD><CODE>sourceHeight</CODE> - the height of the source region to copy<DD><CODE>destWidth</CODE> - the width of the copied region in the destination bitmap<DD><CODE>destHeight</CODE> - the height of the copied region in the destination bitmap<DD><CODE>transValue</CODE> - the transparency value, -1 is none, 0 is highest transparency.
            Higher values mean less transparency.<DD><CODE>additive</CODE> - if true, the blending is additive, otherwise default<DD><CODE>addColor</CODE> - an additional color. If null, Color.WHITE is taken instead<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glFixedBlitting"><CODE>Config.glFixedBlitting</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="blit(com.threed.jpct.Texture, int, int, int, int, int, int, int, int, int, boolean, com.threed.jpct.RGBColor)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(<A HREF="../../../com/threed/jpct/Texture.html" title="class in com.threed.jpct">Texture</A>&nbsp;src,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;sourceWidth,
                 int&nbsp;sourceHeight,
                 int&nbsp;destWidth,
                 int&nbsp;destHeight,
                 int&nbsp;transValue,
                 boolean&nbsp;additive,
                 <A HREF="../../../com/threed/jpct/RGBColor.html" title="class in com.threed.jpct">RGBColor</A>&nbsp;addColor)</PRE>
<DL>
<DD>Method to maintain compatibility with jPCT-AE. Functional identical to
 the variant that takes java.awt.Color instead of RGBColor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the texture that contains the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>sourceWidth</CODE> - the width of the source region to copy<DD><CODE>sourceHeight</CODE> - the height of the source region to copy<DD><CODE>destWidth</CODE> - the width of the copied region in the destination bitmap<DD><CODE>destHeight</CODE> - the height of the copied region in the destination bitmap<DD><CODE>transValue</CODE> - the transparency value, -1 is none, 0 is highest transparency.
            Higher values mean less transparency.<DD><CODE>additive</CODE> - if true, the blending is additive, otherwise default<DD><CODE>addColor</CODE> - an additional color. If null, RGBColor.WHITE is taken instead</DL>
</DD>
</DL>
<HR>

<A NAME="blit(int[], int, int, int, int, int, int, int, int, boolean)"><!-- --></A><H3>
blit</H3>
<PRE>
public void <B>blit</B>(int[]&nbsp;src,
                 int&nbsp;srcWidth,
                 int&nbsp;srcHeight,
                 int&nbsp;srcX,
                 int&nbsp;srcY,
                 int&nbsp;destX,
                 int&nbsp;destY,
                 int&nbsp;width,
                 int&nbsp;height,
                 boolean&nbsp;transparent)</PRE>
<DL>
<DD>Copies a part of a bitmap (taken from an int[] containing pixels in
 RGB-format and with no alpha) into the framebuffer. If you want your
 blitted content to lay on top of the rendered image, it has to be applied
 after calling update() on the buffer. Can be combined with getPixels() to
 achieve some special effects with the framebuffer.<br>
 Blitting in OpenGL mode requires that the current world has been rendered
 at least once into the framebuffer where the blitting should be applied
 to (for doing some intialization work). Usually, that shouldn't be a
 problem unless you are abusing jPCT as a "blitting engine" only. When in
 OpenGL-mode, this method is very slow, because the int[] has to be
 converted and uploaded to the graphics card every time. To avoid this in
 some cases, Config.glUseIgnorantBlits can be set to true...but one should
 be aware of the consequences. As a rule of thumb: If it's possible to
 avoid this method and use a texture-based-blit instead...do it!<br>
 Some graphics cards/drivers are having problems when blitting using a
 16bit z-buffer (albeit the z-buffer is not used for blitting). Have a
 look at Config.glFixedBlitting for a workaround.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the int-array that contains the source bitmap<DD><CODE>srcWidth</CODE> - the width of the source bitmap<DD><CODE>srcHeight</CODE> - the height of the source bitmap<DD><CODE>srcX</CODE> - the starting x-position in the source bitmap<DD><CODE>srcY</CODE> - the starting y-position in the source bitmap<DD><CODE>destX</CODE> - the starting x-position in the destination bitmap<DD><CODE>destY</CODE> - the starting y-position in the destination bitmap<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>transparent</CODE> - black (or at least almost black) pixels won't be copied if
            this is set to TRANSPARENT_BLITTING. Any color-value which
            leads to a result of zero when "anded" with #f0f0f0 will be
            taken as black.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getPixels()"><CODE>getPixels()</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#TRANSPARENT_BLITTING"><CODE>TRANSPARENT_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/FrameBuffer.html#OPAQUE_BLITTING"><CODE>OPAQUE_BLITTING</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glUseIgnorantBlits"><CODE>Config.glUseIgnorantBlits</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glFixedBlitting"><CODE>Config.glFixedBlitting</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="display(java.awt.Graphics)"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>(java.awt.Graphics&nbsp;g)</PRE>
<DL>
<DD>Displays the output Image onto the component with the given Graphics
 context. If one wants to have further control about the drawing,
 getOutputBuffer() can be used instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the Graphics context of the compontent onto which the Image
            should be drawn (ignored when using OpenGL only)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputBuffer()"><CODE>getOutputBuffer()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="display(java.awt.Graphics, int)"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>(java.awt.Graphics&nbsp;g,
                    int&nbsp;yOffset)</PRE>
<DL>
<DD>Displays the output Image onto the component with the given Graphics
 context. If one wants to have further control about the drawing,
 getOutputBuffer() can be used instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the Graphics context of the compontent onto which the Image
            should be drawn (ignored when using OpenGL only)<DD><CODE>yOffset</CODE> - the offset in y-direction (ignored when using OpenGL)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputBuffer()"><CODE>getOutputBuffer()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="display(java.awt.Graphics, int, int)"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>(java.awt.Graphics&nbsp;g,
                    int&nbsp;xOffset,
                    int&nbsp;yOffset)</PRE>
<DL>
<DD>Displays the output Image onto the component with the given Graphics
 context. If one wants to have further control about the drawing,
 getOutputBuffer() can be used instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the Graphics context of the compontent onto which the Image
            should be drawn (ignored when using OpenGL only)<DD><CODE>xOffset</CODE> - the offset in x-direction (ignored when using OpenGL)<DD><CODE>yOffset</CODE> - the offset in y-direction (ignored when using OpenGL)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/FrameBuffer.html#getOutputBuffer()"><CODE>getOutputBuffer()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="displayGLOnly()"><!-- --></A><H3>
displayGLOnly</H3>
<PRE>
public void <B>displayGLOnly</B>()</PRE>
<DL>
<DD>Displays the output image produced by OpenGL compatible hardware if
 OpenGL rendering is in use. If a software renderer is enabled, this
 method will print out a warning message only. It's not required to
 display the OpenGL rendered image by using this method, the normal
 display()-method will work too, but the Graphics parameter will be
 ignored in this case (can even be null).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="display()"><!-- --></A><H3>
display</H3>
<PRE>
public void <B>display</B>()</PRE>
<DL>
<DD>The same as displayGLOnly. This method exists for compatibility with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setClippingPlane(int, com.threed.jpct.Plane)"><!-- --></A><H3>
setClippingPlane</H3>
<PRE>
public void <B>setClippingPlane</B>(int&nbsp;number,
                             <A HREF="../../../com/threed/jpct/Plane.html" title="class in com.threed.jpct">Plane</A>&nbsp;plane)</PRE>
<DL>
<DD>Sets an additional clipping plane. This will show an effect only if a
 hardware renderer has been enabled. The plane has to be defined in camera
 space.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the clipping plane (0..5)<DD><CODE>plane</CODE> - the plane</DL>
</DD>
</DL>
<HR>

<A NAME="removeClippingPlane(int)"><!-- --></A><H3>
removeClippingPlane</H3>
<PRE>
public void <B>removeClippingPlane</B>(int&nbsp;number)</PRE>
<DL>
<DD>Removes an additional clipping plane.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the plane</DL>
</DD>
</DL>
<HR>

<A NAME="sync()"><!-- --></A><H3>
sync</H3>
<PRE>
public void <B>sync</B>()</PRE>
<DL>
<DD>Does nothing. This method exists only for increased compatibility with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A><H3>
flush</H3>
<PRE>
public void <B>flush</B>()</PRE>
<DL>
<DD>Does nothing. This method exists only for increased compatibility with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/DeSerializer.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/GenericVertexController.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FrameBuffer.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
