<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Mon Nov 03 19:17:42 GMT 2014 -->
<TITLE>
World
</TITLE>

<META NAME="keywords" CONTENT="com.threed.jpct.World class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="World";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/WaterTextureEffect.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/WorldProcessor.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="World.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class World</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>com.threed.jpct.World</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public class <B>World</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>

<P>
The World class is the most important class in jPCT. It's like the "glue"
 that holds everything together. The world contains objects and light sources
 that define the scene for jPCT.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../serialized-form.html#com.threed.jpct.World">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#FOGGING_DISABLED">FOGGING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No linear distance fogging will be used (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#FOGGING_ENABLED">FOGGING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linear distance fogging will be used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_PIXEL">FOGGING_PER_PIXEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fogging will be applied per pixel. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_VERTEX">FOGGING_PER_VERTEX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fogging will be applied per vertex by jPCT (default). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#MAIN_OBJECT_NOT_SET">MAIN_OBJECT_NOT_SET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The main object (used for portal rendering only) is not set.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#World()">World</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new "world". </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#addLight(com.threed.jpct.SimpleVector, java.awt.Color)">addLight</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos,
         java.awt.Color&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a light source to the World. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#addLight(com.threed.jpct.SimpleVector, float, float, float)">addLight</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos,
         float&nbsp;r,
         float&nbsp;g,
         float&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a light source to the World. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)">addObject</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an object to the World's object collection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#addObjects(com.threed.jpct.Object3D[])">addObjects</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds all objects from the given array to the world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#addPolyline(com.threed.jpct.Polyline)">addPolyline</A></B>(<A HREF="../../../com/threed/jpct/Polyline.html" title="class in com.threed.jpct">Polyline</A>&nbsp;line)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a new Polyline to the world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#buildAllObjects()">buildAllObjects</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calls build() for every object in the world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">calcMinDistance</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;orig,
                <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                float&nbsp;ignoreIfLarger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the world's objects (have
 to be colliders) from a particular position vector looking into a
 specific direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#calcMinDistanceAndObject3D(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">calcMinDistanceAndObject3D</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;orig,
                           <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                           float&nbsp;ignoreIfLarger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the world's objects (have
 to be colliders) from a particular position vector looking into a
 specific direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollision(int, float)">checkCameraCollision</A></B>(int&nbsp;mode,
                     float&nbsp;moveSpeed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollision(int, float, boolean)">checkCameraCollision</A></B>(int&nbsp;mode,
                     float&nbsp;moveSpeed,
                     boolean&nbsp;slideMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollision(int, float, float, boolean)">checkCameraCollision</A></B>(int&nbsp;mode,
                     float&nbsp;moveSpeed,
                     float&nbsp;distance,
                     boolean&nbsp;slideMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollision(com.threed.jpct.SimpleVector, float, float, boolean)">checkCameraCollision</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                     float&nbsp;moveSpeed,
                     float&nbsp;distance,
                     boolean&nbsp;slideMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollisionEllipsoid(int, com.threed.jpct.SimpleVector, float, int)">checkCameraCollisionEllipsoid</A></B>(int&nbsp;mode,
                              <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                              float&nbsp;moveSpeed,
                              int&nbsp;recursionDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float, int)">checkCameraCollisionEllipsoid</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                              <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                              float&nbsp;moveSpeed,
                              int&nbsp;recursionDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollisionSpherical(int, float, float, boolean)">checkCameraCollisionSpherical</A></B>(int&nbsp;mode,
                              float&nbsp;radius,
                              float&nbsp;moveSpeed,
                              boolean&nbsp;slideMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCameraCollisionSpherical(com.threed.jpct.SimpleVector, float, float, boolean)">checkCameraCollisionSpherical</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                              float&nbsp;radius,
                              float&nbsp;moveSpeed,
                              boolean&nbsp;slideMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCollision(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">checkCollision</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
               float&nbsp;step)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)">checkCollisionEllipsoid</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                        <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                        <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                        int&nbsp;recursionDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#checkCollisionSpherical(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">checkCollisionSpherical</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                        <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                        float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#createTriangleStrips()">createTriangleStrips</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to rebuild all objects of this world in a way that they can be
 rendered by using triangle strips in the most optimal way. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#decoupleVisibilityList()">decoupleVisibilityList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a non-shared visibility list for this World even if
 Config.shareVisibilityList is set to true. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disposes the world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#draw(com.threed.jpct.FrameBuffer)">draw</A></B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the current scene that has been generated geometry wise by
 renderScene(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#draw(com.threed.jpct.FrameBuffer, int, int)">draw</A></B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer,
     int&nbsp;start,
     int&nbsp;end)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the current scene that has been generated geometry wise by
 renderScene(). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#drawWireframe(com.threed.jpct.FrameBuffer, java.awt.Color)">drawWireframe</A></B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer,
              java.awt.Color&nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the current scene as a single-colored wireframe. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getAmbientLight()">getAmbientLight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the ambient light's intensities in an int[]-array in r,g,b order.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getBounds(boolean)">getBounds</A></B>(boolean&nbsp;visibleOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the world space bounds of all (optional only the visible) objects
 that belong to this world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getCamera()">getCamera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current camera.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getCameraSector()">getCameraSector</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the sector-number of the sector the current camera is in. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Thread</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getDefaultThread()">getDefaultThread</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the default thread or null if none has been set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getFogging()">getFogging</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if fogging is being used or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getFoggingMode()">getFoggingMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current fogging mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getFrameCounter()">getFrameCounter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of frames rendered since startup.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getGlobalShader()">getGlobalShader</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the global shader or null if none has been set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLightAttenuation(int)">getLightAttenuation</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the attenuation of a light source, if it has be set before. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLightDiscardDistance(int)">getLightDiscardDistance</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the discard distance of a light source, if it has be set before. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLightDistanceOverride(int)">getLightDistanceOverride</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the overriden distance. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLightIntensity(int)">getLightIntensity</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the intensity of a light source.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLightPosition(int)">getLightPosition</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the position of a light source in world space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Lights.html" title="class in com.threed.jpct">Lights</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getLights()">getLights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Lights instance used by this instance of World to illuminate
 the scene. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getMainObject()">getMainObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the main object or null if none is set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getMainObjectID()">getMainObjectID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the ID of the main object or MAIN_OBJECT_NOT_SET, if it's not set.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getObject(int)">getObject</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object with the given ID from the World's object collection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getObjectByName(java.lang.String)">getObjectByName</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object named "name" from the World's object collection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Enumeration</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getObjects()">getObjects</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an Enumeration of all user defined objects in this world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Portals.html" title="class in com.threed.jpct">Portals</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getPortals()">getPortals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the Portals instance used by this world</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getSize()">getSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of user defined objects in this World.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/VisList.html" title="class in com.threed.jpct">VisList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#getVisibilityList()">getVisibilityList</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the visibility list of the last rendered frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#invertCulling(boolean)">invertCulling</A></B>(boolean&nbsp;inv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts culling for all objects in the world at once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#lockMatrices()">lockMatrices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The rotations and translations of 3D objects in jPCT are not thread-safe
 because of performance reasons (and because it is not required in most
 cases). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#newCamera()">newCamera</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the camera to origin looking along the z-axis. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeAll()">removeAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all lights and objects from the world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeAllLights()">removeAllLights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all lights from the world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeAllObjects()">removeAllObjects</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all but the internal objects from the world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeAllPolylines()">removeAllPolylines</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all Polylines.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeLight(int)">removeLight</A></B>(int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a light from the world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeObject(int)">removeObject</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the object with the specified ID from the World's object
 collection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removeObject(com.threed.jpct.Object3D)">removeObject</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the given object from the World's object collection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#removePolyline(com.threed.jpct.Polyline)">removePolyline</A></B>(<A HREF="../../../com/threed/jpct/Polyline.html" title="class in com.threed.jpct">Polyline</A>&nbsp;line)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a Polyline from a world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#renderScene(com.threed.jpct.FrameBuffer)">renderScene</A></B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms and lights all the polygons. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setAmbientLight(int, int, int)">setAmbientLight</A></B>(int&nbsp;r,
                int&nbsp;g,
                int&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the light intensity for the ambient light source.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setCameraTo(com.threed.jpct.Camera)">setCameraTo</A></B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;cam)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the camera to another one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setClippingPlanes(float, float)">setClippingPlanes</A></B>(float&nbsp;near,
                  float&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If set, this overrides the settings in Config for the near and the far
 clipping plane for this world. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setDefaultThread(java.lang.Thread)">setDefaultThread</A></B>(java.lang.Thread&nbsp;def)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT's methods can be called from within different threads. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setFogging(int)">setFogging</A></B>(int&nbsp;fog)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables linear distance-fogging</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setFoggingMode(int)">setFoggingMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the fogging mode (per pixel or per polygon). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setFogParameters(float, float, float, float)">setFogParameters</A></B>(float&nbsp;distance,
                 float&nbsp;red,
                 float&nbsp;green,
                 float&nbsp;blue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the linear distance fog (if enabled). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setFogParameters(float, float, float, float, float)">setFogParameters</A></B>(float&nbsp;start,
                 float&nbsp;distance,
                 float&nbsp;red,
                 float&nbsp;green,
                 float&nbsp;blue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the linear distance fog (if enabled). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setGlobalShader(com.threed.jpct.GLSLShader)">setGlobalShader</A></B>(<A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A>&nbsp;globalShader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a global shader. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightAttenuation(int, float)">setLightAttenuation</A></B>(int&nbsp;number,
                    float&nbsp;at)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overrides the setting from Config.linearDiv and Config.fadeoutLight for
 the given light.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightDiscardDistance(int, float)">setLightDiscardDistance</A></B>(int&nbsp;number,
                        float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overrides the setting from Config.discardDistance for the given light
 number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightDistanceOverride(int, float)">setLightDistanceOverride</A></B>(int&nbsp;number,
                         float&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overrides the distance that is usually calculated by taking the distance
 between the light source and an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightIntensity(int, float, float, float)">setLightIntensity</A></B>(int&nbsp;number,
                  float&nbsp;r,
                  float&nbsp;g,
                  float&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the intensity for a light source (the "color" of the light source).
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightPosition(int, com.threed.jpct.SimpleVector)">setLightPosition</A></B>(int&nbsp;number,
                 <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Moves a light source to a new position in worldspace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightRotation(int, float, float, float)">setLightRotation</A></B>(int&nbsp;number,
                 float&nbsp;rx,
                 float&nbsp;ry,
                 float&nbsp;rz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current rotation behaviour of the light source with this number.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightRotation(int, com.threed.jpct.SimpleVector, float, float, float)">setLightRotation</A></B>(int&nbsp;number,
                 <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;rotPos,
                 float&nbsp;rx,
                 float&nbsp;ry,
                 float&nbsp;rz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current rotation behaviour of the light source with this number.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setLightVisibility(int, boolean)">setLightVisibility</A></B>(int&nbsp;number,
                   boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the light to be visible (default) or invisible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setMainObjectID(int)">setMainObjectID</A></B>(int&nbsp;objectID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the ID of the main object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setObjectsVisibility(boolean)">setObjectsVisibility</A></B>(boolean&nbsp;visible)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the visibility for objects that belong to a world.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#setWorldProcessor(com.threed.jpct.WorldProcessor)">setWorldProcessor</A></B>(<A HREF="../../../com/threed/jpct/WorldProcessor.html" title="class in com.threed.jpct">WorldProcessor</A>&nbsp;proc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new world processor. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#toXML()">toXML</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Serializes the world to XML. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/World.html#unlockMatrices()">unlockMatrices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unlocks the matrices so that another thread that is waiting to lock them
 may do so and continue with his normal operation. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MAIN_OBJECT_NOT_SET"><!-- --></A><H3>
MAIN_OBJECT_NOT_SET</H3>
<PRE>
public static final int <B>MAIN_OBJECT_NOT_SET</B></PRE>
<DL>
<DD>The main object (used for portal rendering only) is not set.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.World.MAIN_OBJECT_NOT_SET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FOGGING_DISABLED"><!-- --></A><H3>
FOGGING_DISABLED</H3>
<PRE>
public static final int <B>FOGGING_DISABLED</B></PRE>
<DL>
<DD>No linear distance fogging will be used (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.World.FOGGING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FOGGING_ENABLED"><!-- --></A><H3>
FOGGING_ENABLED</H3>
<PRE>
public static final int <B>FOGGING_ENABLED</B></PRE>
<DL>
<DD>Linear distance fogging will be used.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.World.FOGGING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FOGGING_PER_VERTEX"><!-- --></A><H3>
FOGGING_PER_VERTEX</H3>
<PRE>
public static final int <B>FOGGING_PER_VERTEX</B></PRE>
<DL>
<DD>Fogging will be applied per vertex by jPCT (default). It's fast but
 doesn't allow for a target color except black (which is default too).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.World.FOGGING_PER_VERTEX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FOGGING_PER_PIXEL"><!-- --></A><H3>
FOGGING_PER_PIXEL</H3>
<PRE>
public static final int <B>FOGGING_PER_PIXEL</B></PRE>
<DL>
<DD>Fogging will be applied per pixel. This is slower in software mode but
 more accurate and it allows for a target color. Using "per pixel" fog in
 hardware will use OpenGL's fog, which is per vertex too but looks
 different from jPCT's per vertex fogging (see above).<br>
 The software renderer implements this feature using a post processing
 based on the depth buffer's data. This may lead to problems with
 transparent objects, because they don't affect the depth buffer...keep
 this in mind when using this kind of fog.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.World.FOGGING_PER_PIXEL">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="World()"><!-- --></A><H3>
World</H3>
<PRE>
public <B>World</B>()</PRE>
<DL>
<DD>Creates a new "world". A world is like an empty room that has to be
 filled with objects and lights. Every instance of world automatically
 creates an instance of Portals for managing sectors and portals within
 this world and an instance of Lights for managing the light sources.
 Additionally, the TextureManager for this VM is known to the world.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>Disposes the world. This method should be called before the world goes
 out of scope. This frees some resources that may otherwise be locked.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockMatrices()"><!-- --></A><H3>
lockMatrices</H3>
<PRE>
public void <B>lockMatrices</B>()</PRE>
<DL>
<DD>The rotations and translations of 3D objects in jPCT are not thread-safe
 because of performance reasons (and because it is not required in most
 cases). However, if one wants to modify the corresponding matrices (by
 calling the translate()- or one of the rotate?()-methods of an object or
 the camera) inside a thread that runs in parallel with the thread
 executing the renderScene()-method, the rendering thread could try to use
 these matrices while the other thread is still working on them. This
 could be a problem if a bunch of transformations should be applied to the
 objects and no state in between should be accidently rendered. Therefor,
 jPCT can lock these matrices before using them for transformations and
 unlocks them right after that. This internal locking jPCT supports can be
 enabled by changing the configuration in Config. Any other thread that is
 modifying these matrices should call lockMatrices() before doing the
 actual modifications and unlock them right after. If lockMatrices() is
 called while another thread has already locked the matrices, the caller
 is waiting until the first thread unlocks them again. This way, locking
 the matrices ensures that every thread is working with the correct
 matrices.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#lockingTimer"><CODE>Config.lockingTimer</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#useLocking"><CODE>Config.useLocking</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#unlockMatrices()"><CODE>unlockMatrices()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#renderScene(com.threed.jpct.FrameBuffer)"><CODE>renderScene(com.threed.jpct.FrameBuffer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unlockMatrices()"><!-- --></A><H3>
unlockMatrices</H3>
<PRE>
public void <B>unlockMatrices</B>()</PRE>
<DL>
<DD>Unlocks the matrices so that another thread that is waiting to lock them
 may do so and continue with his normal operation. Unlocking the matrices
 without locking them before is an error.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#lockMatrices()"><CODE>lockMatrices()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLights()"><!-- --></A><H3>
getLights</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Lights.html" title="class in com.threed.jpct">Lights</A> <B>getLights</B>()</PRE>
<DL>
<DD>Returns the Lights instance used by this instance of World to illuminate
 the scene. The implementation for managing the lights in jPCT leaves much
 to be desired and it will change sometimes. Anyway, these methods should
 be still in then for compatibility with older sources. So use the current
 implementation without fear...:-)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the lights</DL>
</DD>
</DL>
<HR>

<A NAME="getSize()"><!-- --></A><H3>
getSize</H3>
<PRE>
public int <B>getSize</B>()</PRE>
<DL>
<DD>Returns the number of user defined objects in this World.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of objects</DL>
</DD>
</DL>
<HR>

<A NAME="setMainObjectID(int)"><!-- --></A><H3>
setMainObjectID</H3>
<PRE>
public void <B>setMainObjectID</B>(int&nbsp;objectID)</PRE>
<DL>
<DD>Sets the ID of the main object. The main object is a special object in
 jPCT when using portal rendering. The main object is the object that
 defines the sectors for portal rendering as there is no explicit
 definition of these sectors. For example: An object is created that
 consists of three rooms. Each one belongs to another sector. In this
 stage, the sector information is only present in the triangle definitions
 of this object. It will be derived from there when build() is called for
 this object but therefor it is important that jPCT knows that it should
 derive this information from this object. So before calling build() for
 such an object it is required to set it as main object. The main object
 is the only object in jPCT where object-space has to be equal to
 world-space. So one should never transform this object (albeit the
 current implementation would let one do so...). Important: One world can
 only have one main object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objectID</CODE> - the ID of the object obtained from addObject()<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>Object3D.build()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)"><CODE>addObject(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMainObjectID()"><!-- --></A><H3>
getMainObjectID</H3>
<PRE>
public int <B>getMainObjectID</B>()</PRE>
<DL>
<DD>Gets the ID of the main object or MAIN_OBJECT_NOT_SET, if it's not set.
 Remember that setting a main object is only required if portal rendering
 is used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the ID of the main Object3D<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#MAIN_OBJECT_NOT_SET"><CODE>MAIN_OBJECT_NOT_SET</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMainObject()"><!-- --></A><H3>
getMainObject</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>getMainObject</B>()</PRE>
<DL>
<DD>Gets the main object or null if none is set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the main object (or null)</DL>
</DD>
</DL>
<HR>

<A NAME="getCamera()"><!-- --></A><H3>
getCamera</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A> <B>getCamera</B>()</PRE>
<DL>
<DD>Gets the current camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current camera</DL>
</DD>
</DL>
<HR>

<A NAME="getPortals()"><!-- --></A><H3>
getPortals</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Portals.html" title="class in com.threed.jpct">Portals</A> <B>getPortals</B>()</PRE>
<DL>
<DD>Gets the Portals instance used by this world
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the portals</DL>
</DD>
</DL>
<HR>

<A NAME="getVisibilityList()"><!-- --></A><H3>
getVisibilityList</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/VisList.html" title="class in com.threed.jpct">VisList</A> <B>getVisibilityList</B>()</PRE>
<DL>
<DD>Gets the visibility list of the last rendered frame.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the visibility list</DL>
</DD>
</DL>
<HR>

<A NAME="decoupleVisibilityList()"><!-- --></A><H3>
decoupleVisibilityList</H3>
<PRE>
public void <B>decoupleVisibilityList</B>()</PRE>
<DL>
<DD>Creates a non-shared visibility list for this World even if
 Config.shareVisibilityList is set to true. This is required if a threaded
 renderer (AWTGLRenderer or the multi-threaded GLRenderer) is used to
 render multiple Worlds into one frame. Each World rendered into the frame
 has to have its own list in this case.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="newCamera()"><!-- --></A><H3>
newCamera</H3>
<PRE>
public void <B>newCamera</B>()</PRE>
<DL>
<DD>Resets the camera to origin looking along the z-axis. This is the
 position and orientation the camera has after creating a new "world". In
 fact, this method creates a new camera...hence the name.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCameraTo(com.threed.jpct.Camera)"><!-- --></A><H3>
setCameraTo</H3>
<PRE>
public void <B>setCameraTo</B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;cam)</PRE>
<DL>
<DD>Sets the camera to another one.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cam</CODE> - the camera to use</DL>
</DD>
</DL>
<HR>

<A NAME="invertCulling(boolean)"><!-- --></A><H3>
invertCulling</H3>
<PRE>
public void <B>invertCulling</B>(boolean&nbsp;inv)</PRE>
<DL>
<DD>Inverts culling for all objects in the world at once.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inv</CODE> - invert culling?</DL>
</DD>
</DL>
<HR>

<A NAME="getCameraSector()"><!-- --></A><H3>
getCameraSector</H3>
<PRE>
public int <B>getCameraSector</B>()</PRE>
<DL>
<DD>Returns the sector-number of the sector the current camera is in. Useful
 for portal rendering only
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sector-number</DL>
</DD>
</DL>
<HR>

<A NAME="removeObject(int)"><!-- --></A><H3>
removeObject</H3>
<PRE>
public void <B>removeObject</B>(int&nbsp;id)</PRE>
<DL>
<DD>Removes the object with the specified ID from the World's object
 collection. This method doesn't check for child/parent objects of the
 removed object, which will remain intact.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - the ID of the object to remove</DL>
</DD>
</DL>
<HR>

<A NAME="removeObject(com.threed.jpct.Object3D)"><!-- --></A><H3>
removeObject</H3>
<PRE>
public void <B>removeObject</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Removes the given object from the World's object collection. This method
 doesn't check for child/parent objects of the removed object, which will
 remain intact.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object to remove</DL>
</DD>
</DL>
<HR>

<A NAME="getObject(int)"><!-- --></A><H3>
getObject</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>getObject</B>(int&nbsp;id)</PRE>
<DL>
<DD>Returns the object with the given ID from the World's object collection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - the ID of the object
<DT><B>Returns:</B><DD>the object or null if it doesn't exist</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectByName(java.lang.String)"><!-- --></A><H3>
getObjectByName</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>getObjectByName</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Returns the object named "name" from the World's object collection. This
 is an alternative albeit slower way to retrieve objects from the World. A
 better idea would be not ot lose them anyway...:-)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - the name of the object
<DT><B>Returns:</B><DD>the object or null if it doesn't exist</DL>
</DD>
</DL>
<HR>

<A NAME="addObject(com.threed.jpct.Object3D)"><!-- --></A><H3>
addObject</H3>
<PRE>
public int <B>addObject</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Adds an object to the World's object collection. The object will be
 referenced in this collection by its ID. The ID of the object in the
 collection is the same as the object's own ID. addObject() also returns
 this ID due to "historical reasons". So id=addObject(obj) is basically
 the same as id=obj.getID(); addObject(obj); Note: Current implementation
 limits the object-World bindings in a way that an object can only be
 added to one world at a time. This method doesn't check if the object has
 been added multiple times. This may change later.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object to be added
<DT><B>Returns:</B><DD>the ID of the object in this World's collection<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#getID()"><CODE>Object3D.getID()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addObjects(com.threed.jpct.Object3D[])"><!-- --></A><H3>
addObjects</H3>
<PRE>
public void <B>addObjects</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</PRE>
<DL>
<DD>Adds all objects from the given array to the world. This can be useful,
 if one wants to add a Object3Ds loaded by the 3DS/OBJ loaders to a world
 at once.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objs</CODE> - the objects</DL>
</DD>
</DL>
<HR>

<A NAME="addLight(com.threed.jpct.SimpleVector, float, float, float)"><!-- --></A><H3>
addLight</H3>
<PRE>
public int <B>addLight</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos,
                    float&nbsp;r,
                    float&nbsp;g,
                    float&nbsp;b)</PRE>
<DL>
<DD>Adds a light source to the World. This method allows for overbright
 lighting and fractional light intensities. The OpenGL renderer doesn't
 support overbright lighting in the rasterization stage (because hardware
 usually doesn't), so if one wants to look OpenGL und software renderer
 output to look similar, overbright lighting shouldn't be used. The
 intensity will be multiplied by the value of Config.lightMul.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lightPos</CODE> - the light's position in worldspace<DD><CODE>r</CODE> - the red component of light's color<DD><CODE>g</CODE> - the green component of light's color<DD><CODE>b</CODE> - the blue component of light's color
<DT><B>Returns:</B><DD>the number of the light source within the light source
         collection. Used for further references because single light
         sources are not single Objects but all light sources are part of
         a Lights Object. This may change some day as mentioned in the
         description for getLights().<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#getLights()"><CODE>getLights()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#lightMul"><CODE>Config.lightMul</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addLight(com.threed.jpct.SimpleVector, java.awt.Color)"><!-- --></A><H3>
addLight</H3>
<PRE>
public int <B>addLight</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos,
                    java.awt.Color&nbsp;col)</PRE>
<DL>
<DD>Adds a light source to the World. The intensity (=color) will be
 multiplied by the value of Config.lightMul.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lightPos</CODE> - the light's position in worldspace<DD><CODE>col</CODE> - the Color of the light source. jPCT supports overbright
            lighting (light values higher than 255 per color). and
            fractional light intensities (like 10.5f). If you want to use
            these features, add the light source using addLight(pos,r,g,b)
            instead
<DT><B>Returns:</B><DD>the number of the light source within the light source
         collection. Used for further references.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#addLight(com.threed.jpct.SimpleVector, float, float, float)"><CODE>addLight(com.threed.jpct.SimpleVector,float,float,float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#lightMul"><CODE>Config.lightMul</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeLight(int)"><!-- --></A><H3>
removeLight</H3>
<PRE>
public void <B>removeLight</B>(int&nbsp;number)</PRE>
<DL>
<DD>Removes a light from the world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source ro remove (as returned by
            addLight())</DL>
</DD>
</DL>
<HR>

<A NAME="setLightRotation(int, com.threed.jpct.SimpleVector, float, float, float)"><!-- --></A><H3>
setLightRotation</H3>
<PRE>
public void <B>setLightRotation</B>(int&nbsp;number,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;rotPos,
                             float&nbsp;rx,
                             float&nbsp;ry,
                             float&nbsp;rz)</PRE>
<DL>
<DD>Sets the current rotation behaviour of the light source with this number.
 The rotation will be applied to the light source every frame (a behaviour
 which is different from what rotations mean for object). So if you want
 to stop a light source from rotating, set rx, ry and rz to 0f.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>rotPos</CODE> - the position of the rotation center of this light source<DD><CODE>rx</CODE> - the angle around which the light source will be rotated around
            the x-axis every frame<DD><CODE>ry</CODE> - the angle around which the light source will be rotated around
            the y-axis every frame<DD><CODE>rz</CODE> - the angle around which the light source will be rotated around
            the z-axis every frame</DL>
</DD>
</DL>
<HR>

<A NAME="setLightRotation(int, float, float, float)"><!-- --></A><H3>
setLightRotation</H3>
<PRE>
public void <B>setLightRotation</B>(int&nbsp;number,
                             float&nbsp;rx,
                             float&nbsp;ry,
                             float&nbsp;rz)</PRE>
<DL>
<DD>Sets the current rotation behaviour of the light source with this number.
 The rotation will be applied to the light source every frame (a behaviour
 which is different from what rotations mean for object). So if you want
 to stop a light source from rotating, set rx, ry and rz to 0f. The
 rotation center of this light source won't be touched by this methods.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>rx</CODE> - the angle around which the light source will be rotated around
            the x-axis every frame<DD><CODE>ry</CODE> - the angle around which the light source will be rotated around
            the y-axis every frame<DD><CODE>rz</CODE> - the angle around which the light source will be rotated around
            the z-axis every frame</DL>
</DD>
</DL>
<HR>

<A NAME="setLightPosition(int, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setLightPosition</H3>
<PRE>
public void <B>setLightPosition</B>(int&nbsp;number,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;lightPos)</PRE>
<DL>
<DD>Moves a light source to a new position in worldspace.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>lightPos</CODE> - the position of the light source</DL>
</DD>
</DL>
<HR>

<A NAME="setLightVisibility(int, boolean)"><!-- --></A><H3>
setLightVisibility</H3>
<PRE>
public void <B>setLightVisibility</B>(int&nbsp;number,
                               boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the light to be visible (default) or invisible.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>mode</CODE> - the visibility mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Lights.html#LIGHT_VISIBLE"><CODE>Lights.LIGHT_VISIBLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Lights.html#LIGHT_INVISIBLE"><CODE>Lights.LIGHT_INVISIBLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLightDiscardDistance(int, float)"><!-- --></A><H3>
setLightDiscardDistance</H3>
<PRE>
public void <B>setLightDiscardDistance</B>(int&nbsp;number,
                                    float&nbsp;distance)</PRE>
<DL>
<DD>Overrides the setting from Config.discardDistance for the given light
 number.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>distance</CODE> - the discard distance, i.e. the distance where the light will
            be "cut off" at latest. -1 means never.</DL>
</DD>
</DL>
<HR>

<A NAME="setLightDistanceOverride(int, float)"><!-- --></A><H3>
setLightDistanceOverride</H3>
<PRE>
public void <B>setLightDistanceOverride</B>(int&nbsp;number,
                                     float&nbsp;distance)</PRE>
<DL>
<DD>Overrides the distance that is usually calculated by taking the distance
 between the light source and an object. With this, it's possible to let a
 light source have an effect on an object even if it's very far away and
 many other lights are actually closer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>distance</CODE> - the new distance</DL>
</DD>
</DL>
<HR>

<A NAME="getLightDistanceOverride(int)"><!-- --></A><H3>
getLightDistanceOverride</H3>
<PRE>
public float <B>getLightDistanceOverride</B>(int&nbsp;number)</PRE>
<DL>
<DD>Returns the overriden distance. If none is set, -1 will be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())
<DT><B>Returns:</B><DD>the overriden distance or -1</DL>
</DD>
</DL>
<HR>

<A NAME="setLightAttenuation(int, float)"><!-- --></A><H3>
setLightAttenuation</H3>
<PRE>
public void <B>setLightAttenuation</B>(int&nbsp;number,
                                float&nbsp;at)</PRE>
<DL>
<DD>Overrides the setting from Config.linearDiv and Config.fadeoutLight for
 the given light.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>at</CODE> - the attenuation. The lower the value, the faster the light
            will fade. -1 means no fading at all.</DL>
</DD>
</DL>
<HR>

<A NAME="setLightIntensity(int, float, float, float)"><!-- --></A><H3>
setLightIntensity</H3>
<PRE>
public void <B>setLightIntensity</B>(int&nbsp;number,
                              float&nbsp;r,
                              float&nbsp;g,
                              float&nbsp;b)</PRE>
<DL>
<DD>Sets the intensity for a light source (the "color" of the light source).
 The intensity will be multiplied by the value of Config.lightMul.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())<DD><CODE>r</CODE> - the red component of the intensity<DD><CODE>g</CODE> - the green component of the intensity<DD><CODE>b</CODE> - the blue component of the intensity<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#lightMul"><CODE>Config.lightMul</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLightAttenuation(int)"><!-- --></A><H3>
getLightAttenuation</H3>
<PRE>
public float <B>getLightAttenuation</B>(int&nbsp;number)</PRE>
<DL>
<DD>Gets the attenuation of a light source, if it has be set before. If it
 hasn't, the result of this call in undefined (but lower than -1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source
<DT><B>Returns:</B><DD>float the attenuation (is previously set, otherwise something
         below -1)</DL>
</DD>
</DL>
<HR>

<A NAME="getLightDiscardDistance(int)"><!-- --></A><H3>
getLightDiscardDistance</H3>
<PRE>
public float <B>getLightDiscardDistance</B>(int&nbsp;number)</PRE>
<DL>
<DD>Gets the discard distance of a light source, if it has be set before. If
 it hasn't, the result of this call in undefined (but lower than -1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source
<DT><B>Returns:</B><DD>float the discard distance (is previously set, otherwise
         something below -1)</DL>
</DD>
</DL>
<HR>

<A NAME="getLightPosition(int)"><!-- --></A><H3>
getLightPosition</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getLightPosition</B>(int&nbsp;number)</PRE>
<DL>
<DD>Gets the position of a light source in world space.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())
<DT><B>Returns:</B><DD>SimpleVector the position</DL>
</DD>
</DL>
<HR>

<A NAME="getLightIntensity(int)"><!-- --></A><H3>
getLightIntensity</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getLightIntensity</B>(int&nbsp;number)</PRE>
<DL>
<DD>Returns the intensity of a light source.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>number</CODE> - the number of the light source (as returned by addLight())
<DT><B>Returns:</B><DD>a SimpleVector containing the light's intensities in in rbg
         format in the x,y,z-components of the vector.</DL>
</DD>
</DL>
<HR>

<A NAME="setWorldProcessor(com.threed.jpct.WorldProcessor)"><!-- --></A><H3>
setWorldProcessor</H3>
<PRE>
public void <B>setWorldProcessor</B>(<A HREF="../../../com/threed/jpct/WorldProcessor.html" title="class in com.threed.jpct">WorldProcessor</A>&nbsp;proc)</PRE>
<DL>
<DD>Sets a new world processor. If none is set, jPCT will create a single
 threaded one by itself. You can use this, to distribute object processing
 to multiple cores. This is useful for scenes with a high object count
 only.<br/>
 Setting a new processor automatically disposes the old one.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAmbientLight(int, int, int)"><!-- --></A><H3>
setAmbientLight</H3>
<PRE>
public void <B>setAmbientLight</B>(int&nbsp;r,
                            int&nbsp;g,
                            int&nbsp;b)</PRE>
<DL>
<DD>Sets the light intensity for the ambient light source.<br>
 Setting this is negative values will darken the whole scene while
 positive ones will light up everything.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - the red component (100 is default)<DD><CODE>g</CODE> - the red component (100 is default)<DD><CODE>b</CODE> - the red component (100 is default)</DL>
</DD>
</DL>
<HR>

<A NAME="getAmbientLight()"><!-- --></A><H3>
getAmbientLight</H3>
<PRE>
public int[] <B>getAmbientLight</B>()</PRE>
<DL>
<DD>Returns the ambient light's intensities in an int[]-array in r,g,b order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the light's intensities</DL>
</DD>
</DL>
<HR>

<A NAME="setFogging(int)"><!-- --></A><H3>
setFogging</H3>
<PRE>
public void <B>setFogging</B>(int&nbsp;fog)</PRE>
<DL>
<DD>Enables/Disables linear distance-fogging
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fog</CODE> - fogging enabled or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#FOGGING_ENABLED"><CODE>FOGGING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#FOGGING_DISABLED"><CODE>FOGGING_DISABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#setFogParameters(float, float, float, float)"><CODE>setFogParameters(float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFoggingMode(int)"><!-- --></A><H3>
setFoggingMode</H3>
<PRE>
public void <B>setFoggingMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the fogging mode (per pixel or per polygon). Per pixel is slower
 when using software rendering but much more flexible.<br>
 If per pixel fog should be used in combination with the OpenGL-renderer,
 it's advised to (re-)call this method after changing the renderer to
 OpenGL, because the renderer may not be aware of the current setting
 otherwise. This is caused by a flaw in jPCT's design...;-)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the fogging mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_VERTEX"><CODE>FOGGING_PER_VERTEX</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_PIXEL"><CODE>FOGGING_PER_PIXEL</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#setFogParameters(float, float, float, float)"><CODE>setFogParameters(float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFogging()"><!-- --></A><H3>
getFogging</H3>
<PRE>
public int <B>getFogging</B>()</PRE>
<DL>
<DD>Returns if fogging is being used or not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>fogging usage<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#FOGGING_ENABLED"><CODE>FOGGING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#FOGGING_DISABLED"><CODE>FOGGING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFoggingMode()"><!-- --></A><H3>
getFoggingMode</H3>
<PRE>
public int <B>getFoggingMode</B>()</PRE>
<DL>
<DD>Returns the current fogging mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the fogging mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_VERTEX"><CODE>FOGGING_PER_VERTEX</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#FOGGING_PER_PIXEL"><CODE>FOGGING_PER_PIXEL</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFogParameters(float, float, float, float)"><!-- --></A><H3>
setFogParameters</H3>
<PRE>
public void <B>setFogParameters</B>(float&nbsp;distance,
                             float&nbsp;red,
                             float&nbsp;green,
                             float&nbsp;blue)</PRE>
<DL>
<DD>Sets the parameters for the linear distance fog (if enabled). For the
 legacy software renderer, the resulting color of a pixel if calculated as
 col=texelColor+ambient+(fogColor*d)+(lightColors*(1-d)), where d is 0 at
 z=0 and 1 at z=dist (or higher).<br>
 An example: setFogParameters(200,255,-255,-255) will result in a red fog
 reaching its maximum density at a depth of 200. -255 for both green and
 blue is required to get a red fog without any traces of green and/or
 blue. The color components are NOT limited to a range of 0..255 in this
 case.<br>
 However, in OpenGL modes (software and hardware), the colors will be
 clamped at 0 and 255. There are two modes: per pixel and per vertex. Per
 pixel allows for a target color, while per vertex doesn't.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the distance in camera-space coordinates at which the fog
            reaches its maximum density (150 is default, 1 is minimum)<DD><CODE>red</CODE> - the red component of the fog ([0..255] for OpenGL modes, 0 is
            default)<DD><CODE>green</CODE> - the green component of the fog ([0..255] for OpenGL modes, 0
            is default)<DD><CODE>blue</CODE> - the blue component of the fog ([0..255] for OpenGL modes, 0 is
            default)</DL>
</DD>
</DL>
<HR>

<A NAME="setFogParameters(float, float, float, float, float)"><!-- --></A><H3>
setFogParameters</H3>
<PRE>
public void <B>setFogParameters</B>(float&nbsp;start,
                             float&nbsp;distance,
                             float&nbsp;red,
                             float&nbsp;green,
                             float&nbsp;blue)</PRE>
<DL>
<DD>Sets the parameters for the linear distance fog (if enabled). For the
 legacy software renderer, the resulting color of a pixel if calculated as
 col=texelColor+ambient+(fogColor*d)+(lightColors*(1-d)), where d is 0 at
 z=0 and 1 at z=dist (or higher).<br>
 An example: setFogParameters(200,255,-255,-255) will result in a red fog
 reaching its maximum density at a depth of 200. -255 for both green and
 blue is required to get a red fog without any traces of green and/or
 blue. The color components are NOT limited to a range of 0..255 in this
 case.<br>
 However, in OpenGL modes (software and hardware), the colors will be
 clamped at 0 and 255. There are two modes: per pixel and per vertex. Per
 pixel allows for a target color, while per vertex doesn't.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>start</CODE> - where the fog actually starts. This setting is currently
            ignored by the software renderers<DD><CODE>distance</CODE> - the distance in camera-space coordinates at which the fog
            reaches its maximum density (150 is default, 1 is minimum)<DD><CODE>red</CODE> - the red component of the fog ([0..255] for OpenGL modes, 0 is
            default)<DD><CODE>green</CODE> - the green component of the fog ([0..255] for OpenGL modes, 0
            is default)<DD><CODE>blue</CODE> - the blue component of the fog ([0..255] for OpenGL modes, 0 is
            default)</DL>
</DD>
</DL>
<HR>

<A NAME="setClippingPlanes(float, float)"><!-- --></A><H3>
setClippingPlanes</H3>
<PRE>
public void <B>setClippingPlanes</B>(float&nbsp;near,
                              float&nbsp;far)</PRE>
<DL>
<DD>If set, this overrides the settings in Config for the near and the far
 clipping plane for this world. If you don't touch this method, the
 settings in Config will be taken instead.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>near</CODE> - the near plane<DD><CODE>far</CODE> - the far plane<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#farPlane"><CODE>Config.farPlane</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#nearPlane"><CODE>Config.nearPlane</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCollision(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkCollision</H3>
<PRE>
public int <B>checkCollision</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                          <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                          float&nbsp;step)</PRE>
<DL>
<DD>Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. The method can be used to implement various kinds of collision
 detection/response and uses a ray-polygon collision detection. All
 objects should have been set to an appropiate collision mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of "something"<DD><CODE>dr</CODE> - the direction vector of "something" (a unit vector)<DD><CODE>step</CODE> - the length of the casted ray (a collision will only be
            detected of it takes place within this range)
<DT><B>Returns:</B><DD>the ID of the Object3D if there is a collision, otherwise
         NO_OBJECT<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#getID()"><CODE>Object3D.getID()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#NO_OBJECT"><CODE>Object3D.NO_OBJECT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCollisionSpherical(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkCollisionSpherical</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkCollisionSpherical</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                            float&nbsp;radius)</PRE>
<DL>
<DD>Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. The method can be used to implement various kinds of collision
 detection/response and uses a sphere-polygon collision detection. All
 objects should have been set to an appropiate collision mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of "something"<DD><CODE>translation</CODE> - that should be applied to "something" (Note that this method
            just checks this translation...it doesn't apply it)<DD><CODE>radius</CODE> - the radius of the sphere (a collision will only be detected of
            it takes place within this radius)
<DT><B>Returns:</B><DD>a SimpleVector containing the corrected translation (i.e. the
         translation that should be used to avoid a collision) or, if no
         collision takes place, the translation from the call (i.e. no
         collision means returned SimpleVector.equals(translation)).</DL>
</DD>
</DL>
<HR>

<A NAME="checkCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)"><!-- --></A><H3>
checkCollisionEllipsoid</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkCollisionEllipsoid</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                                            int&nbsp;recursionDepth)</PRE>
<DL>
<DD>Checks if a collision between "something" and an object would take place
 if this "something" would move step units from its position into a given
 direction. The method can be used to implement various kinds of collision
 detection/response and uses a (swept)ellipsoid-polygon collision
 detection. All objects should have been set to an appropiate collision
 mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of "something"<DD><CODE>translation</CODE> - that should be applied to "something" (Note that this method
            just checks this translation...it doesn't apply it)<DD><CODE>ellipsoid</CODE> - the radius of the epplisoid in x,y and z direction<DD><CODE>recursionDepth</CODE> - the max. recursion depth of the collision detection. A higher
            value will improve the accuracy of the collision detection but
            reduce performance. Reasonable values lie between 1 and 5.
<DT><B>Returns:</B><DD>a SimpleVector containing the corrected translation (i.e. the
         translation that should be used to avoid a collision) or, if no
         collision takes place, the translation from the call (i.e. no
         collision means returned SimpleVector.equals(translation)).</DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollision(int, float)"><!-- --></A><H3>
checkCameraCollision</H3>
<PRE>
public boolean <B>checkCameraCollision</B>(int&nbsp;mode,
                                    float&nbsp;moveSpeed)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. If
 not, the camera will "slide" in the remaining directions. Uses a
 ray-polygon collision detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the direction (relative to its orientation)<DD><CODE>moveSpeed</CODE> - the number of units the camera should move
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEDOWN"><CODE>Camera.CAMERA_MOVEDOWN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEUP"><CODE>Camera.CAMERA_MOVEUP</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEIN"><CODE>Camera.CAMERA_MOVEIN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEOUT"><CODE>Camera.CAMERA_MOVEOUT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVELEFT"><CODE>Camera.CAMERA_MOVELEFT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVERIGHT"><CODE>Camera.CAMERA_MOVERIGHT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollision(int, float, boolean)"><!-- --></A><H3>
checkCameraCollision</H3>
<PRE>
public boolean <B>checkCameraCollision</B>(int&nbsp;mode,
                                    float&nbsp;moveSpeed,
                                    boolean&nbsp;slideMode)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. Uses
 a ray-polygon collision detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the direction (relative to its orientation)<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>slideMode</CODE> - indicates if the camera should slide or just stand still in
            case of collision
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEDOWN"><CODE>Camera.CAMERA_MOVEDOWN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEUP"><CODE>Camera.CAMERA_MOVEUP</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEIN"><CODE>Camera.CAMERA_MOVEIN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEOUT"><CODE>Camera.CAMERA_MOVEOUT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVELEFT"><CODE>Camera.CAMERA_MOVELEFT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVERIGHT"><CODE>Camera.CAMERA_MOVERIGHT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#SLIDE"><CODE>Camera.SLIDE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#DONT_SLIDE"><CODE>Camera.DONT_SLIDE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollision(int, float, float, boolean)"><!-- --></A><H3>
checkCameraCollision</H3>
<PRE>
public boolean <B>checkCameraCollision</B>(int&nbsp;mode,
                                    float&nbsp;moveSpeed,
                                    float&nbsp;distance,
                                    boolean&nbsp;slideMode)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. Uses
 a ray-polygon collision detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the direction (relative to its orientation)<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>distance</CODE> - the maximum distance the position vector can have from the
            polygon before a collision is detected.<DD><CODE>slideMode</CODE> - indicates if the camera should slide or just stand still in
            case of collision
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEDOWN"><CODE>Camera.CAMERA_MOVEDOWN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEUP"><CODE>Camera.CAMERA_MOVEUP</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEIN"><CODE>Camera.CAMERA_MOVEIN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEOUT"><CODE>Camera.CAMERA_MOVEOUT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVELEFT"><CODE>Camera.CAMERA_MOVELEFT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVERIGHT"><CODE>Camera.CAMERA_MOVERIGHT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#SLIDE"><CODE>Camera.SLIDE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#DONT_SLIDE"><CODE>Camera.DONT_SLIDE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollision(com.threed.jpct.SimpleVector, float, float, boolean)"><!-- --></A><H3>
checkCameraCollision</H3>
<PRE>
public boolean <B>checkCameraCollision</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                                    float&nbsp;moveSpeed,
                                    float&nbsp;distance,
                                    boolean&nbsp;slideMode)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. Uses a ray-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - the direction (should be a normalized vector (i.e. a length of
            1))<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>distance</CODE> - the maximum distance the position vector can have from the
            polygon before a collision is detected.<DD><CODE>slideMode</CODE> - indicates if the camera should slide or just stand still in
            case of collision
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#SLIDE"><CODE>Camera.SLIDE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#DONT_SLIDE"><CODE>Camera.DONT_SLIDE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistanceAndObject3D(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
calcMinDistanceAndObject3D</H3>
<PRE>
public java.lang.Object[] <B>calcMinDistanceAndObject3D</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;orig,
                                                     <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                                                     float&nbsp;ignoreIfLarger)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the world's objects (have
 to be colliders) from a particular position vector looking into a
 specific direction. It only takes polygons into consideration that have
 at least one vertex that is closer than ignoreIfLarger units to the
 position vector and whose bounding box/octree-node is closer than that
 value too.<br>
 In addition to calcMinDistance(), this method returns the object to which
 the polygon belongs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>orig</CODE> - a SimpleVector containing the x,y,z-coordinates of the
            position vector<DD><CODE>dir</CODE> - a SimpleVector array containing the x,y,z-coordinates of the
            direction vector (a unit vector)<DD><CODE>ignoreIfLarger</CODE> - only polygons/bounding boxes/octree-nodes within this range
            will be taken into account
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit) and the object to
         which this polygon belongs in an Object[] containing a Float at
         position 0 and an Object3D on position 1. If there is no such
         polygon, the array will contain [COLLISION_NONE, null].<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>Object3D.COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
calcMinDistance</H3>
<PRE>
public float <B>calcMinDistance</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;orig,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                             float&nbsp;ignoreIfLarger)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the world's objects (have
 to be colliders) from a particular position vector looking into a
 specific direction. It only takes polygons into consideration that have
 at least one vertex that is closer than ignoreIfLarger units to the
 position vector and whose bounding box/octree-node is closer than that
 value too.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>orig</CODE> - a SimpleVector containing the x,y,z-coordinates of the
            position vector<DD><CODE>dir</CODE> - a SimpleVector array containing the x,y,z-coordinates of the
            direction vector (a unit vector)<DD><CODE>ignoreIfLarger</CODE> - only polygons/bounding boxes/octree-nodes within this range
            will be taken into account
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit). If there is no such
         polygon, COLLISION_NONE will be returned.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>Object3D.COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollisionSpherical(int, float, float, boolean)"><!-- --></A><H3>
checkCameraCollisionSpherical</H3>
<PRE>
public boolean <B>checkCameraCollisionSpherical</B>(int&nbsp;mode,
                                             float&nbsp;radius,
                                             float&nbsp;moveSpeed,
                                             boolean&nbsp;slideMode)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position and regarding
 its current orientation into "mode" direction, if this is possible. Uses
 a sphere-polygon collision detection. This method can be used in
 CAMERA_DONT_MOVE-mode too, where the camera will only be adjusted
 automatically if anything that is a collider has moved in its way.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the direction (relative to its orientation)<DD><CODE>radius</CODE> - the radius of the sphere. A collision will only be detected
            within this radius.<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>slideMode</CODE> - indicates if the camera should slide or just stand still in
            case of collision
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEDOWN"><CODE>Camera.CAMERA_MOVEDOWN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEUP"><CODE>Camera.CAMERA_MOVEUP</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEIN"><CODE>Camera.CAMERA_MOVEIN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEOUT"><CODE>Camera.CAMERA_MOVEOUT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVELEFT"><CODE>Camera.CAMERA_MOVELEFT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVERIGHT"><CODE>Camera.CAMERA_MOVERIGHT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_DONT_MOVE"><CODE>Camera.CAMERA_DONT_MOVE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#SLIDE"><CODE>Camera.SLIDE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#DONT_SLIDE"><CODE>Camera.DONT_SLIDE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollisionSpherical(com.threed.jpct.SimpleVector, float, float, boolean)"><!-- --></A><H3>
checkCameraCollisionSpherical</H3>
<PRE>
public boolean <B>checkCameraCollisionSpherical</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                                             float&nbsp;radius,
                                             float&nbsp;moveSpeed,
                                             boolean&nbsp;slideMode)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. Uses a sphere-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - the direction (should be a normalized vector (i.e. a length of
            1))<DD><CODE>radius</CODE> - the radius of the sphere. A collision will only be detected
            within this radius.<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>slideMode</CODE> - indicates if the camera should slide or just stand still in
            case of collision
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#SLIDE"><CODE>Camera.SLIDE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#DONT_SLIDE"><CODE>Camera.DONT_SLIDE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollisionEllipsoid(int, com.threed.jpct.SimpleVector, float, int)"><!-- --></A><H3>
checkCameraCollisionEllipsoid</H3>
<PRE>
public boolean <B>checkCameraCollisionEllipsoid</B>(int&nbsp;mode,
                                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                                             float&nbsp;moveSpeed,
                                             int&nbsp;recursionDepth)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. Uses a (swept)ellipsoid-polygon
 collision detection. This method will always use sliding.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the direction (relative to its orientation)<DD><CODE>ellipsoid</CODE> - the radius of the epplisoid in x,y and z direction<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>recursionDepth</CODE> - the max. recursion depth of the collision detection. A higher
            value will improve the accuracy of the collision detection but
            reduce performance. Reasonable values lie between 1 and 5.
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEDOWN"><CODE>Camera.CAMERA_MOVEDOWN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEUP"><CODE>Camera.CAMERA_MOVEUP</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEIN"><CODE>Camera.CAMERA_MOVEIN</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVEOUT"><CODE>Camera.CAMERA_MOVEOUT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVELEFT"><CODE>Camera.CAMERA_MOVELEFT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_MOVERIGHT"><CODE>Camera.CAMERA_MOVERIGHT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Camera.html#CAMERA_DONT_MOVE"><CODE>Camera.CAMERA_DONT_MOVE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkCameraCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float, int)"><!-- --></A><H3>
checkCameraCollisionEllipsoid</H3>
<PRE>
public boolean <B>checkCameraCollisionEllipsoid</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;direction,
                                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                                             float&nbsp;moveSpeed,
                                             int&nbsp;recursionDepth)</PRE>
<DL>
<DD>Moves the camera moveSpeed units from its current position into an
 arbitrary direction, if this is possible. Uses a (swept)ellipsoid-polygon
 collision detection. This method will always use sliding.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - the direction (should be a normalized vector (i.e. a length of
            1))<DD><CODE>ellipsoid</CODE> - the radius of the epplisoid in x,y and z direction<DD><CODE>moveSpeed</CODE> - the number of units the camera should move<DD><CODE>recursionDepth</CODE> - the max. recursion depth of the collision detection. A higher
            value will improve the accuracy of the collision detection but
            reduce performance. Reasonable values lie between 1 and 5.
<DT><B>Returns:</B><DD>true if the camera collided with something, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="buildAllObjects()"><!-- --></A><H3>
buildAllObjects</H3>
<PRE>
public void <B>buildAllObjects</B>()</PRE>
<DL>
<DD>Calls build() for every object in the world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>Object3D.build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createTriangleStrips()"><!-- --></A><H3>
createTriangleStrips</H3>
<PRE>
public void <B>createTriangleStrips</B>()</PRE>
<DL>
<DD>Tries to rebuild all objects of this world in a way that they can be
 rendered by using triangle strips in the most optimal way. This may be
 useful when using the OpenGL renderer to increase performance for complex
 objects. The software renderer doesn't use this information (but it
 shouldn't hurt either). This calculation may take some time on complex
 objects.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips()"><CODE>Object3D.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glTriangleStrips"><CODE>Config.glTriangleStrips</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#useMultipassStriping"><CODE>Config.useMultipassStriping</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="renderScene(com.threed.jpct.FrameBuffer)"><!-- --></A><H3>
renderScene</H3>
<PRE>
public void <B>renderScene</B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Transforms and lights all the polygons. This method does everything
 required to start drawing the current scene. It just doesn't scanconvert
 the results. This is done by the draw()-method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the framebuffer that should be used for rendering<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#draw(com.threed.jpct.FrameBuffer)"><CODE>draw(com.threed.jpct.FrameBuffer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="draw(com.threed.jpct.FrameBuffer)"><!-- --></A><H3>
draw</H3>
<PRE>
public void <B>draw</B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Draws the current scene that has been generated geometry wise by
 renderScene(). Usually, renderScene() and draw() are used one right after
 the other (with draw being the last).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the framebuffer that should be used for rendering<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#renderScene(com.threed.jpct.FrameBuffer)"><CODE>renderScene(com.threed.jpct.FrameBuffer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="draw(com.threed.jpct.FrameBuffer, int, int)"><!-- --></A><H3>
draw</H3>
<PRE>
public void <B>draw</B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer,
                 int&nbsp;start,
                 int&nbsp;end)</PRE>
<DL>
<DD>Draws the current scene that has been generated geometry wise by
 renderScene(). Usually, renderScene() and draw() are used one right after
 the other (with draw being the last).<br>
 This is a special purpose version of draw() that allows for giving a
 starting and ending index to limit drawing to a certain part of the
 VisList. Maybe helpful for special effects of some kind, but usually not
 needed. Keep in mind that when using a threaded renderer (AWTGL or GL in
 multi threading mode), the actual drawing doesn't happen when calling
 this method, so it's not possible to do something between drawing two
 parts of the VisList by using this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the framebuffer that should be used for rendering<DD><CODE>start</CODE> - the index of the first polygon to draw (in the VisList)<DD><CODE>end</CODE> - the index of the last polygon to draw (in the VisList)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#renderScene(com.threed.jpct.FrameBuffer)"><CODE>renderScene(com.threed.jpct.FrameBuffer)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawWireframe(com.threed.jpct.FrameBuffer, java.awt.Color)"><!-- --></A><H3>
drawWireframe</H3>
<PRE>
public void <B>drawWireframe</B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer,
                          java.awt.Color&nbsp;color)</PRE>
<DL>
<DD>Draws the current scene as a single-colored wireframe. This is done using
 the same buffer draw() draws into. drawWireframe() can be called instead
 of draw() to get the wireframe only as well as right after draw() to
 combine the two renderings for some special effects. Calling
 drawWireframe() before draw() doesn't make much sense.<br>
 jPCT's wireframe mode is not as optimized as the texturemapped mode is
 (yet) but it should be "fast enough".
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the framebuffer that should be used for rendering<DD><CODE>color</CODE> - the wireframe's color</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameCounter()"><!-- --></A><H3>
getFrameCounter</H3>
<PRE>
public long <B>getFrameCounter</B>()</PRE>
<DL>
<DD>Returns the number of frames rendered since startup.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of frames (to be precise: how often draw() has been
         called)</DL>
</DD>
</DL>
<HR>

<A NAME="getObjects()"><!-- --></A><H3>
getObjects</H3>
<PRE>
public java.util.Enumeration <B>getObjects</B>()</PRE>
<DL>
<DD>Returns an Enumeration of all user defined objects in this world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the objects (instances of Object3D)</DL>
</DD>
</DL>
<HR>

<A NAME="setObjectsVisibility(boolean)"><!-- --></A><H3>
setObjectsVisibility</H3>
<PRE>
public void <B>setObjectsVisibility</B>(boolean&nbsp;visible)</PRE>
<DL>
<DD>Sets the visibility for objects that belong to a world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visible</CODE> - visible or not?</DL>
</DD>
</DL>
<HR>

<A NAME="removeAll()"><!-- --></A><H3>
removeAll</H3>
<PRE>
public void <B>removeAll</B>()</PRE>
<DL>
<DD>Removes all lights and objects from the world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllObjects()"><!-- --></A><H3>
removeAllObjects</H3>
<PRE>
public void <B>removeAllObjects</B>()</PRE>
<DL>
<DD>Removes all but the internal objects from the world. The world is empty
 after calling this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllLights()"><!-- --></A><H3>
removeAllLights</H3>
<PRE>
public void <B>removeAllLights</B>()</PRE>
<DL>
<DD>Removes all lights from the world. The scene will be lit by ambient
 lighting only after calling this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="addPolyline(com.threed.jpct.Polyline)"><!-- --></A><H3>
addPolyline</H3>
<PRE>
public void <B>addPolyline</B>(<A HREF="../../../com/threed/jpct/Polyline.html" title="class in com.threed.jpct">Polyline</A>&nbsp;line)</PRE>
<DL>
<DD>Adds a new Polyline to the world. A Polyline is a line strip with a color
 that will be drawn into the scene after all other objects has been drawn.
 A Polyline's coordinates are to be given in world space. You can add
 multiple Polylines to a world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>line</CODE> - the Polyline</DL>
</DD>
</DL>
<HR>

<A NAME="removePolyline(com.threed.jpct.Polyline)"><!-- --></A><H3>
removePolyline</H3>
<PRE>
public void <B>removePolyline</B>(<A HREF="../../../com/threed/jpct/Polyline.html" title="class in com.threed.jpct">Polyline</A>&nbsp;line)</PRE>
<DL>
<DD>Removes a Polyline from a world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>line</CODE> - the line</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllPolylines()"><!-- --></A><H3>
removeAllPolylines</H3>
<PRE>
public void <B>removeAllPolylines</B>()</PRE>
<DL>
<DD>Removes all Polylines.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultThread(java.lang.Thread)"><!-- --></A><H3>
setDefaultThread</H3>
<PRE>
public static void <B>setDefaultThread</B>(java.lang.Thread&nbsp;def)</PRE>
<DL>
<DD>jPCT's methods can be called from within different threads. However, it's
 very likely that one thread will do most of the work while others may run
 less often or doing less work. With this method, it's possible to tell
 jPCT which is the "default" thread, i.e. the thread that does most of the
 work. If jPCT knows this, some optimizations for this thread can be
 performed. Note that this value isn't serialized if World is.<br/>
 If you don't set this value, jPCT will auto-detect the default thread.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>def</CODE> - the "default" thread</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultThread()"><!-- --></A><H3>
getDefaultThread</H3>
<PRE>
public static java.lang.Thread <B>getDefaultThread</B>()</PRE>
<DL>
<DD>Returns the default thread or null if none has been set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the thread or null</DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalShader(com.threed.jpct.GLSLShader)"><!-- --></A><H3>
setGlobalShader</H3>
<PRE>
public void <B>setGlobalShader</B>(<A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A>&nbsp;globalShader)</PRE>
<DL>
<DD>Sets a global shader. If set, this shader will be applied to all objects
 that have no own shader assigned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>globalShader</CODE> - the global shader</DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalShader()"><!-- --></A><H3>
getGlobalShader</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/GLSLShader.html" title="class in com.threed.jpct">GLSLShader</A> <B>getGlobalShader</B>()</PRE>
<DL>
<DD>Returns the global shader or null if none has been set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the global shader</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds(boolean)"><!-- --></A><H3>
getBounds</H3>
<PRE>
public float[] <B>getBounds</B>(boolean&nbsp;visibleOnly)</PRE>
<DL>
<DD>Returns the world space bounds of all (optional only the visible) objects
 that belong to this world. Or in other words: All vertices of all objects
 in this world will be located inside the returned bounding box. Format of
 the return array is minX, maxX, minY, maxY, minZ, maxZ.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>visibleOnly</CODE> - if true, only visible objects will be taken into account. If
            false, all objects will.
<DT><B>Returns:</B><DD>the bounding box</DL>
</DD>
</DL>
<HR>

<A NAME="toXML()"><!-- --></A><H3>
toXML</H3>
<PRE>
public java.lang.String <B>toXML</B>()</PRE>
<DL>
<DD>Serializes the world to XML. Not all of the world's and objects'
 attributes are serialized. Have a look at the DTD for jPCT's XML-format
 for more details. The resulting XML can be quite huge.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the XML</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/WaterTextureEffect.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/WorldProcessor.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="World.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
