<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Mon Nov 03 19:17:41 GMT 2014 -->
<TITLE>
Object3D
</TITLE>

<META NAME="keywords" CONTENT="com.threed.jpct.Object3D class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Object3D";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Object3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.threed.jpct</FONT>
<BR>
Class Object3D</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>com.threed.jpct.Object3D</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT>public class <B>Object3D</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>

<P>
Object3D is a class for 3-dimensional objects. Don't let yourself fool by the
 similarity of the name to java.lang.Object. A 3-dimensional object as
 constructed by this class is usually added to an instance of World for
 rendering. One object should be added to only one instance of World at a
 time. Objects may be connected by defining them as childs/parents to build
 hierarchies among them. Dummy objects are also possible. They are usually not
 added to a World instance but binded to other objects (dummy or none-dummy).
 Some methods in this class require the instance to be added to an instance of
 World (using World.addObject()).
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html" title="class in com.threed.jpct"><CODE>World</CODE></A>, 
<A HREF="../../../serialized-form.html#com.threed.jpct.Object3D">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_DISABLED">BILLBOARDING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object won't use billboarding (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_ENABLED">BILLBOARDING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object will use billboarding (i.e. it always faces the camera)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BLENDING_DISABLED">BLENDING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blending (bumpmapping+texturemapping) is not used</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BLENDING_ENABLED">BLENDING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Blending (bumpmapping+texturemapping) is used</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_DISABLED">BUMPMAPPING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bumpmapping is not used</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_ENABLED">BUMPMAPPING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bumpmapping is used</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_NONE">COLLISION_CHECK_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Don't perform any kind of collision detection for this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_OTHERS">COLLISION_CHECK_OTHERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other Object3Ds/rays/spheres/ellipsoids may collide with this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_SELF">COLLISION_CHECK_SELF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This Object3D may collide with other objects</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_NOT_OPTIMIZED">COLLISION_DETECTION_NOT_OPTIMIZED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables (default) an automated optimization for collision detection in
 case of problems with this optimization.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_OPTIMIZED">COLLISION_DETECTION_OPTIMIZED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables an automated optimization for speeding up collision detection in
 some case. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE">COLLISION_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signals that no collision has been detected for this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED">CULLING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backface culling won't be applied to this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED">CULLING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backface culling will be applied to this object before rendering</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED">ELLIPSOID_ALIGNED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object's ellipsoid won't be transformed when performing collision
 detection (default).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED">ELLIPSOID_TRANSFORMED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object's ellipsoid will be transformed when performing collision
 detection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_CAMERASPACE">ENVMAP_CAMERASPACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping takes place in cameraspace</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED">ENVMAP_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping is disabled</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED">ENVMAP_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping is enabled</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_WORLDSPACE">ENVMAP_WORLDSPACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Environment mapping takes place in worldspace</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_XY">ENVMAP_XY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Direction' of spherical environment mapping is XY (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_XZ">ENVMAP_XZ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Direction' of spherical environment mapping is XZ</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_YZ">ENVMAP_YZ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Direction' of spherical environment mapping is YZ</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FILTERING_DISABLED">FILTERING_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtering is not used on this object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FILTERING_ENABLED">FILTERING_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtering is used on this object (where needed)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_DEFAULT">FINALIZE_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default mode for sector processing</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTX">FINALIZE_PRESORTX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative mode for sector processing (not very useful at all)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTY">FINALIZE_PRESORTY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative mode for sector processing (not very useful at all)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTZ">FINALIZE_PRESORTZ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative mode for sector processing (not very useful at all)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED">LIGHTING_ALL_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that all kinds of light (lightsources, ambient and additional
 color) will be used on this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS">LIGHTING_NO_LIGHTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that no lightsources will be taken into account to calculate an
 object's lighting. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_SELECTABLE">MOUSE_SELECTABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This object will be processed by the methods of Interact2D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_UNSELECTABLE">MOUSE_UNSELECTABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This object won't be processed by the methods of Interact2D</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#NO_OBJECT">NO_OBJECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The "ID" of an Object3D that doesn't exist. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE">OBJ_INVISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is invisible and won't be processed, rendered...nothing...</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE">OBJ_VISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is visible</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX">RAY_MISSES_BOX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signals that a ray/box-intersection test has failed (the ray doesn't
 intersect with the box)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SECTOR_AUTODETECT">SECTOR_AUTODETECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use autodetection of the covered sectors (for example for animated
 objects)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SECTOR_PRECALCULATED">SECTOR_PRECALCULATED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use static sector information</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_FAKED_FLAT">SHADING_FAKED_FLAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that (faked) flat shading should be used. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_GOURAUD">SHADING_GOURAUD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates that gouraud shading should be used (default)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_DISABLED">SPECULAR_DISABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specular highLights won't be calculated</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_ENABLED">SPECULAR_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specular highLights will be calculated</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD">TRANSPARENCY_MODE_ADD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An alternative transparency mode for additive blending. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT">TRANSPARENCY_MODE_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default transparency mode and the only one that the legacy software
 renderer supports.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#UNKNOWN_OBJECTSIZE">UNKNOWN_OBJECTSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object is empty</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(float[], float[], int[], int)">Object3D</A></B>(float[]&nbsp;coordinates,
         float[]&nbsp;uvs,
         int[]&nbsp;indices,
         int&nbsp;textureId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor for creating an Object3D out of indexed geometry in bulk
 form. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(int)">Object3D</A></B>(int&nbsp;maxTriangles)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new instance of Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(com.threed.jpct.Object3D)">Object3D</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#Object3D(com.threed.jpct.Object3D, boolean)">Object3D</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj,
         boolean&nbsp;reuseMesh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addChild(com.threed.jpct.Object3D)">addChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines an object as a child of this. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addCollisionListener(com.threed.jpct.CollisionListener)">addCollisionListener</A></B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a collision listener to this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addParent(com.threed.jpct.Object3D)">addParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Defines an object as a parent of this. this will inherit all
 transformations and no other attributes from its parent. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3,
            int&nbsp;textureID)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, int)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3,
            int&nbsp;textureID,
            int&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, com.threed.jpct.SimpleVector)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            float&nbsp;u,
            float&nbsp;v,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            float&nbsp;u2,
            float&nbsp;v2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            float&nbsp;u3,
            float&nbsp;v3,
            int&nbsp;textureID,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vertexAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo, int)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf,
            int&nbsp;sec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo, com.threed.jpct.SimpleVector)">addTriangle</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
            <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf,
            <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vertexAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a triangle to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#align(com.threed.jpct.Camera)">align</A></B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;camera)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aligns this object with a Camera using the camera's backbuffer matrix.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#align(com.threed.jpct.Object3D)">align</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aligns this object with another Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#animate(float)">animate</A></B>(float&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a new mesh for this object based on the keyframes of its
 animation sequence and "index". index is a value between 0 and 1 where 0
 is the first keyframe and 1 the last. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#animate(float, int)">animate</A></B>(float&nbsp;index,
        int&nbsp;seq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates a new mesh for this object based on the keyframes of its
 animation sub-sequence and "index". index is a value between 0 and 1
 where 0 is the first keyframe and 1 the last (of the sub-sequence). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#build()">build</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes some basic object properties that are needed for almost all
 further processing. build() should be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set...).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()">calcBoundingBox</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates an AABB (Axis Aligned Bounding Box) for this object in
 object-space. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcCenter()">calcCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to calculate the center of the object using its mesh data. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">calcMinDistance</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)">calcMinDistance</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                float&nbsp;ignoreIfLarger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcNormals()">calcNormals</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculates the object's vertex normals by calculating the face normals of
 the adjacent polygons of each vertex and averaging them. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTangentVectors()">calcTangentVectors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tangent vectors are needed for some calculation in shaders. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrap()">calcTextureWrap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Wraps" a texture around the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrapSpherical()">calcTextureWrapSpherical</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Wraps" a texture around the object in a spherical way. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollision(com.threed.jpct.SimpleVector, float)">checkForCollision</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dirVec,
                  float&nbsp;step)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)">checkForCollisionEllipsoid</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                           <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                           int&nbsp;recursionDepth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#checkForCollisionSpherical(com.threed.jpct.SimpleVector, float)">checkForCollisionSpherical</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                           float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if the current object collides with something when moving into a
 particular direction. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearAdditionalColor()">clearAdditionalColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes additional color information form the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearAnimation()">clearAnimation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the animation for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearObject()">clearObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the object by removing all vertex/mesh information from it. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearRotation()">clearRotation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the current rotation to the initial value, i.e. no rotation at
 all. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#clearTranslation()">clearTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the current translation to the initial value, i.e. no translation
 at all.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()">cloneObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones the current object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compile()">compile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiles an Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compile(boolean)">compile</A></B>(boolean&nbsp;dynamic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiles an Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compile(boolean, boolean, boolean, boolean, int)">compile</A></B>(boolean&nbsp;dynamic,
        boolean&nbsp;staticUV,
        boolean&nbsp;preferDisplayListsOrVBO,
        boolean&nbsp;indexed,
        int&nbsp;batchSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiles an Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#compileAndStrip()">compileAndStrip</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compiles and strips an Object3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#createDummyObj()">createDummyObj</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that creates a dummy Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips()">createTriangleStrips</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to rebuild the object in a way that it can be rendered by using
 triangle strips in the most optimal way. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#createTriangleStrips(int)">createTriangleStrips</A></B>(int&nbsp;maxPasses)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tries to rebuild the object in a way that it can be rendered by using
 triangle strips in the most optimal way. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#cullingIsInverted()">cullingIsInverted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if inverted culling is used on this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#decompile(com.threed.jpct.FrameBuffer)">decompile</A></B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decompiles an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#decoupleMesh()">decoupleMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decouples the current mesh from the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableCollisionListeners()">disableCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables all collision listeners of this object, so that none of them
 will be notified in case of a collision.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableLazyTransformations()">disableLazyTransformations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables "lazy transformations". </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#disableVertexSharing()">disableVertexSharing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables the automatic vertex sharing that jPCT does for triangles added
 by addTriangle. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#ellipsoidIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">ellipsoidIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                        <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ellipsoid intersects the axis aligned bounding box (in
 object-space) of this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#enableCollisionListeners()">enableCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Re-)enables all collision listerner of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#enableLazyTransformations()">enableLazyTransformations</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables "lazy transformations". </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#forceGeometryIndices(boolean)">forceGeometryIndices</A></B>(boolean&nbsp;dnc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does nothing in jPCT. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Color</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getAdditionalColor()">getAdditionalColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the additional color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getAnimationSequence()">getAnimationSequence</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the animation sequence.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getBlending()">getBlending</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if blending is enable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCenter()">getCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object (in object-space, i.e. unaffected by any
 transformation).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Enumeration</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCollisionListeners()">getCollisionListeners</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the collision listeners of this object as an enumeration. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getCulling()">getCulling</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current culling mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getEllipsoidMode()">getEllipsoidMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current ellipsoid mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getEnvmapMode()">getEnvmapMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently used mode for environment mapping (worldspace or
 cameraspace).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getID()">getID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's ID. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getInverseWorldTransformation()">getInverseWorldTransformation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the inverse of the transformation matrix from object into world
 space.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getInverseWorldTransformation(com.threed.jpct.Matrix)">getInverseWorldTransformation</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the inverse of the transformation matrix from object into world
 space and fills the result in the given matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getLightCount()">getLightCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of lights that have an influence on this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getLighting()">getLighting</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the lighting mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getMaxLights()">getMaxLights</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum number of lights that should have an influence on
 this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getMesh()">getMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current mesh of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getName()">getName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getNextID()">getNextID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that returns the ID the next object will get. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOcTree()">getOcTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the OcTree assigned to this object or null, if none has been
 assigned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOrigin()">getOrigin</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the origin of the object (as set by setOrigin()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getOriginMatrix()">getOriginMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's origin-translation matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getParents()">getParents</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns all parents of this Object3D in an array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/PolygonManager.html" title="class in com.threed.jpct">PolygonManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getPolygonManager()">getPolygonManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the PolygonManager for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getRenderHook()">getRenderHook</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the render hook or null, if none has been set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getRotationMatrix()">getRotationMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's current rotation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getRotationPivot()">getRotationPivot</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the rotation pivot of the object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getScale()">getScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the cumulated scale value for this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getSpecularLighting()">getSpecularLighting</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the state of specular lighting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTextureMatrix()">getTextureMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current texture matrix of null if none is set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransformedCenter()">getTransformedCenter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransformedCenter(com.threed.jpct.SimpleVector)">getTransformedCenter</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslation()">getTranslation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the translation of the object (from its origin to its current
 position)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslation(com.threed.jpct.SimpleVector)">getTranslation</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the translation of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTranslationMatrix()">getTranslationMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the object's current translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransparency()">getTransparency</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current tranparency setting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getTransparencyMode()">getTransparencyMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current transparency mode. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getUserObject()">getUserObject</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the user defined object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getVisibility()">getVisibility</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current visibility state of the object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getWorldTransformation()">getWorldTransformation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the transformation matrix used to transform the object from
 objectspace into worldspace. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getWorldTransformation(com.threed.jpct.Matrix)">getWorldTransformation</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variant of getWorldTransformation() to avoid the creation of an
 additional matrix where not needed. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getWorldTransformationTweaked(com.threed.jpct.Matrix)">getWorldTransformationTweaked</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getXAxis()">getXAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getXAxis(com.threed.jpct.SimpleVector)">getXAxis</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getYAxis()">getYAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getYAxis(com.threed.jpct.SimpleVector)">getYAxis</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getZAxis()">getZAxis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the z-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#getZAxis(com.threed.jpct.SimpleVector)">getZAxis</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the z-axis of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasChild(com.threed.jpct.Object3D)">hasChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests an object for being a child object of the current object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasParent(com.threed.jpct.Object3D)">hasParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests an object for being a parent object of the current object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#hasVertexAlpha()">hasVertexAlpha</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true, if this object uses vertex alpha values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#invert()">invert</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Physically "inverts" the object, which means that the backface culling
 works the other way round. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#invertCulling(boolean)">invertCulling</A></B>(boolean&nbsp;inv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts culling order if set to true. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#invertTextureCoords(boolean, boolean)">invertTextureCoords</A></B>(boolean&nbsp;invertU,
                    boolean&nbsp;invertV)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts the texture coordinates assuming that they are in the range of
 0..1. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isBumpmapped()">isBumpmapped</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if bumpmapping is used or not. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isCompiled()">isCompiled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the object is compiled. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isEnvmapped()">isEnvmapped</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if environment mapping is used or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isSelectable()">isSelectable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current "selectable"-state of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#isTransparent()">isTransparent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the object is transparent of not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#mergeAll(com.threed.jpct.Object3D[])">mergeAll</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges all objects in the array into one large object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#mergeObjects(com.threed.jpct.Object3D, com.threed.jpct.Object3D)">mergeObjects</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;first,
             <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;second)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static method that merges two objects into a third one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">rayIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                  <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, boolean)">rayIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                  <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                  boolean&nbsp;isNormalized)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rebuild()">rebuild</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The same as build().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#recreateTextureCoords()">recreateTextureCoords</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rebuilds the actual texture coordinates for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeChild(com.threed.jpct.Object3D)">removeChild</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an object from the child-collection of this. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeCollisionListener(com.threed.jpct.CollisionListener)">removeCollisionListener</A></B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a collision listener from the list of listeners.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeMultiTexturing()">removeMultiTexturing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all multi texturing information from this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#removeParent(com.threed.jpct.Object3D)">removeParent</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes an object from the parent-collection of this. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#reorderSectors(int)">reorderSectors</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reorders the object's meshdata by grouping it according to the sectors.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#resetCollisionStatus()">resetCollisionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the indicator that the object was a target of the last collision
 detection to false, i.e. the object won't be recognized any longer as
 part of the collision. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#resetNextID()">resetNextID</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resets the internal object-counter. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateAxis(com.threed.jpct.SimpleVector, float)">rotateAxis</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;axis,
           float&nbsp;angle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around an arbitrary axis. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateMesh()">rotateMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the raw mesh data using the rotation matrix specified for this
 object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateX(float)">rotateX</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the x-axis by the given angle
 w (radian, counter clockwise for positive values). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateY(float)">rotateY</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the y-axis by the given angle
 w (radian, clockwise for positive values). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#rotateZ(float)">rotateZ</A></B>(float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rotates the object's rotation matrix around the z-axis by the given angle
 w (radian, counter clockwise for positive values). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#scale(float)">scale</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scales the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAdditionalColor(java.awt.Color)">setAdditionalColor</A></B>(java.awt.Color&nbsp;col)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the additional color for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAdditionalColor(int, int, int)">setAdditionalColor</A></B>(int&nbsp;red,
                   int&nbsp;green,
                   int&nbsp;blue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the additional color for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAllTextures(java.lang.String, java.lang.String)">setAllTextures</A></B>(java.lang.String&nbsp;texname,
               java.lang.String&nbsp;bumpname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the textures for an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAllTextures(java.lang.String, java.lang.String, java.lang.String)">setAllTextures</A></B>(java.lang.String&nbsp;basename,
               java.lang.String&nbsp;texname,
               java.lang.String&nbsp;bumpname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the textures for an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAnimationSequence(com.threed.jpct.Animation)">setAnimationSequence</A></B>(<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A>&nbsp;anim)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the keyframe animation sequence that should be used for this object.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setAsMultiSectored()">setAsMultiSectored</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tells jPCT that this object is a multi-sectored one (for portal
 rendering). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBaseTexture(java.lang.String)">setBaseTexture</A></B>(java.lang.String&nbsp;texname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the base texture for the whole object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBillboarding(boolean)">setBillboarding</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/disables billboarding for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBlending(boolean)">setBlending</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables blending for the current object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBoundingBox(float, float, float, float, float, float)">setBoundingBox</A></B>(float&nbsp;minx,
               float&nbsp;maxx,
               float&nbsp;miny,
               float&nbsp;maxy,
               float&nbsp;minz,
               float&nbsp;maxz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new AABB for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBumpmapped(boolean)">setBumpmapped</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables enviroment bumpmapping for this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setBumpmapTexture(java.lang.String)">setBumpmapTexture</A></B>(java.lang.String&nbsp;texname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the bumpmap of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)">setCenter</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;center)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the center of the object (in object-space). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)">setCollisionMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets if and how the object will respond to collisions. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCollisionOptimization(boolean)">setCollisionOptimization</A></B>(boolean&nbsp;optimized)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an optimization for collision detection to be used/not used. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setCulling(boolean)">setCulling</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables backface culling for the current object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setDepthBufferWrites(boolean)">setDepthBufferWrites</A></B>(boolean&nbsp;write)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is only important when using the software renderer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEllipsoidMode(int)">setEllipsoidMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When doing ellipsoid collision detection with this object, the ellipsoid
 can be transformed according to the objects's transformation and in the
 source's object space or it remains static in the target's object space
 (i.e. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEnvmapDirection(int)">setEnvmapDirection</A></B>(int&nbsp;dir)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the pair of coordinates from (x,y,z) that will be used for
 calculating the environment mapping.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEnvmapMode(boolean)">setEnvmapMode</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mode for environment mapping. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setEnvmapped(boolean)">setEnvmapped</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables environment mapping for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setFiltering(boolean)">setFiltering</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables filtering on a per texel basis. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setLighting(int)">setLighting</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the lighting mode. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setMatrixCacheUsage(boolean)">setMatrixCacheUsage</A></B>(boolean&nbsp;useIt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables the matrix cache. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setMaxLights(int)">setMaxLights</A></B>(int&nbsp;lightCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the maximum number of lights that should have an influence on this
 object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setMesh(com.threed.jpct.Mesh)">setMesh</A></B>(<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A>&nbsp;mesh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an object's mesh to another one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setName(java.lang.String)">setName</A></B>(java.lang.String&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the name of the object to a name other than the default one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setNextID(int)">setNextID</A></B>(int&nbsp;next)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the ID the next object will get. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOcTree(com.threed.jpct.OcTree)">setOcTree</A></B>(<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A>&nbsp;ocTree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assigns an octree to the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOrientation(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)">setOrientation</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;up)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the orientation of this object by giving a direction and an
 up-vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setOrigin(com.threed.jpct.SimpleVector)">setOrigin</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;origin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the origin of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRenderHook(com.threed.jpct.IRenderHook)">setRenderHook</A></B>(<A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A>&nbsp;hook)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a new hook into the rendering pipeline. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setReNormalization(boolean)">setReNormalization</A></B>(boolean&nbsp;reNormalize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables re-normalization of transformed normal vectors. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRotationMatrix(com.threed.jpct.Matrix)">setRotationMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rotation matrix for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setRotationPivot(com.threed.jpct.SimpleVector)">setRotationPivot</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;pivot)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rotation pivot of the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setScale(float)">setScale</A></B>(float&nbsp;absScale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets an absolute value for the object's scaling. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSector(int)">setSector</A></B>(int&nbsp;sector)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Places the object into a specific sector. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSectorDetectionMode(boolean)">setSectorDetectionMode</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the method used for sector detection. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSelectable(boolean)">setSelectable</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object as selectable/unselectable. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setShadingMode(int)">setShadingMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jPCT always uses gouraud shading and that can't be disabled. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSortOffset(float)">setSortOffset</A></B>(float&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets on offset for the z-Sorting. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setSpecularLighting(boolean)">setSpecularLighting</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables/Disables specular lighting for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTexture(java.lang.String)">setTexture</A></B>(java.lang.String&nbsp;texname)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the texture for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTexture(com.threed.jpct.TextureInfo)">setTexture</A></B>(<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the texture for the object via an instance of TextureInfo.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTextureMatrix(com.threed.jpct.Matrix)">setTextureMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a matrix that is applied to transform the texture in stage 0. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTranslationMatrix(com.threed.jpct.Matrix)">setTranslationMatrix</A></B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the translation matrix for the object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTransparency(int)">setTransparency</A></B>(int&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object to be transparent using the given level of transparency.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setTransparencyMode(int)">setTransparencyMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transparency (blending) mode. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></B>(java.lang.Object&nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is a "workaround" in case you want to give additional
 information to an Object3D but don't want to (or can't) extend Object3D
 itself.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#setVisibility(boolean)">setVisibility</A></B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the object to visible/invisible. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#shareCompiledData(com.threed.jpct.Object3D)">shareCompiledData</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;withObj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a compiled object to share data with another compiled one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#shareTextureData(com.threed.jpct.Object3D)">shareTextureData</A></B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In addition to sharing the actual mesh data, you can also make objects
 share the same texturing information (the actual textures, not the
 uv-coordinates). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#sphereIntersectsAABB(com.threed.jpct.SimpleVector, float)">sphereIntersectsAABB</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                     float&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks if a given sphere intersects the axis aligned bounding box (in
 object-space) of this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#strip()">strip</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Strips an Object3D. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#touch()">touch</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Touches an object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)">translate</A></B>(float&nbsp;x,
          float&nbsp;y,
          float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates ("moves") the object in worldspace by modifying the
 translation matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translate(com.threed.jpct.SimpleVector)">translate</A></B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trans)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates ("moves") the object in worldspace by modifying the
 translation matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#translateMesh()">translateMesh</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates the raw mesh data using the translation and the origin matrix
 of this object. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#unbuild()">unbuild</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Unbuilds" an object, i.e. it takes back some of the changes that build()
 does to the object, so that new triangles can be added again to this
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#wasTargetOfLastCollision()">wasTargetOfLastCollision</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True, if this object was a target of the last collision detection that
 took place (regardless of what kind it was). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../com/threed/jpct/Object3D.html#wasVisible()">wasVisible</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the object was visible (or at least supposed to be) in the
 last frame. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ENVMAP_WORLDSPACE"><!-- --></A><H3>
ENVMAP_WORLDSPACE</H3>
<PRE>
public static final boolean <B>ENVMAP_WORLDSPACE</B></PRE>
<DL>
<DD>Environment mapping takes place in worldspace
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_WORLDSPACE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_CAMERASPACE"><!-- --></A><H3>
ENVMAP_CAMERASPACE</H3>
<PRE>
public static final boolean <B>ENVMAP_CAMERASPACE</B></PRE>
<DL>
<DD>Environment mapping takes place in cameraspace
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_CAMERASPACE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_ENABLED"><!-- --></A><H3>
ENVMAP_ENABLED</H3>
<PRE>
public static final boolean <B>ENVMAP_ENABLED</B></PRE>
<DL>
<DD>Environment mapping is enabled
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_DISABLED"><!-- --></A><H3>
ENVMAP_DISABLED</H3>
<PRE>
public static final boolean <B>ENVMAP_DISABLED</B></PRE>
<DL>
<DD>Environment mapping is disabled
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUMPMAPPING_ENABLED"><!-- --></A><H3>
BUMPMAPPING_ENABLED</H3>
<PRE>
public static final boolean <B>BUMPMAPPING_ENABLED</B></PRE>
<DL>
<DD>Bumpmapping is used
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BUMPMAPPING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BUMPMAPPING_DISABLED"><!-- --></A><H3>
BUMPMAPPING_DISABLED</H3>
<PRE>
public static final boolean <B>BUMPMAPPING_DISABLED</B></PRE>
<DL>
<DD>Bumpmapping is not used
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BUMPMAPPING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BLENDING_ENABLED"><!-- --></A><H3>
BLENDING_ENABLED</H3>
<PRE>
public static final boolean <B>BLENDING_ENABLED</B></PRE>
<DL>
<DD>Blending (bumpmapping+texturemapping) is used
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BLENDING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BLENDING_DISABLED"><!-- --></A><H3>
BLENDING_DISABLED</H3>
<PRE>
public static final boolean <B>BLENDING_DISABLED</B></PRE>
<DL>
<DD>Blending (bumpmapping+texturemapping) is not used
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BLENDING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_MODE_DEFAULT"><!-- --></A><H3>
TRANSPARENCY_MODE_DEFAULT</H3>
<PRE>
public static final int <B>TRANSPARENCY_MODE_DEFAULT</B></PRE>
<DL>
<DD>The default transparency mode and the only one that the legacy software
 renderer supports.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.TRANSPARENCY_MODE_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_MODE_ADD"><!-- --></A><H3>
TRANSPARENCY_MODE_ADD</H3>
<PRE>
public static final int <B>TRANSPARENCY_MODE_ADD</B></PRE>
<DL>
<DD>An alternative transparency mode for additive blending. Supported by the
 OpenGL renderers and the Opengl-alike software renderer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.TRANSPARENCY_MODE_ADD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BILLBOARDING_ENABLED"><!-- --></A><H3>
BILLBOARDING_ENABLED</H3>
<PRE>
public static final boolean <B>BILLBOARDING_ENABLED</B></PRE>
<DL>
<DD>The object will use billboarding (i.e. it always faces the camera)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BILLBOARDING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BILLBOARDING_DISABLED"><!-- --></A><H3>
BILLBOARDING_DISABLED</H3>
<PRE>
public static final boolean <B>BILLBOARDING_DISABLED</B></PRE>
<DL>
<DD>The object won't use billboarding (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.BILLBOARDING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MOUSE_SELECTABLE"><!-- --></A><H3>
MOUSE_SELECTABLE</H3>
<PRE>
public static final boolean <B>MOUSE_SELECTABLE</B></PRE>
<DL>
<DD>This object will be processed by the methods of Interact2D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.MOUSE_SELECTABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MOUSE_UNSELECTABLE"><!-- --></A><H3>
MOUSE_UNSELECTABLE</H3>
<PRE>
public static final boolean <B>MOUSE_UNSELECTABLE</B></PRE>
<DL>
<DD>This object won't be processed by the methods of Interact2D
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.MOUSE_UNSELECTABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FILTERING_ENABLED"><!-- --></A><H3>
FILTERING_ENABLED</H3>
<PRE>
public static final boolean <B>FILTERING_ENABLED</B></PRE>
<DL>
<DD>Filtering is used on this object (where needed)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FILTERING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FILTERING_DISABLED"><!-- --></A><H3>
FILTERING_DISABLED</H3>
<PRE>
public static final boolean <B>FILTERING_DISABLED</B></PRE>
<DL>
<DD>Filtering is not used on this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FILTERING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CULLING_ENABLED"><!-- --></A><H3>
CULLING_ENABLED</H3>
<PRE>
public static final boolean <B>CULLING_ENABLED</B></PRE>
<DL>
<DD>Backface culling will be applied to this object before rendering
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.CULLING_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CULLING_DISABLED"><!-- --></A><H3>
CULLING_DISABLED</H3>
<PRE>
public static final boolean <B>CULLING_DISABLED</B></PRE>
<DL>
<DD>Backface culling won't be applied to this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.CULLING_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SPECULAR_ENABLED"><!-- --></A><H3>
SPECULAR_ENABLED</H3>
<PRE>
public static final boolean <B>SPECULAR_ENABLED</B></PRE>
<DL>
<DD>Specular highLights will be calculated
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SPECULAR_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SPECULAR_DISABLED"><!-- --></A><H3>
SPECULAR_DISABLED</H3>
<PRE>
public static final boolean <B>SPECULAR_DISABLED</B></PRE>
<DL>
<DD>Specular highLights won't be calculated
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SPECULAR_DISABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FINALIZE_DEFAULT"><!-- --></A><H3>
FINALIZE_DEFAULT</H3>
<PRE>
public static final int <B>FINALIZE_DEFAULT</B></PRE>
<DL>
<DD>Default mode for sector processing
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FINALIZE_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FINALIZE_PRESORTZ"><!-- --></A><H3>
FINALIZE_PRESORTZ</H3>
<PRE>
public static final int <B>FINALIZE_PRESORTZ</B></PRE>
<DL>
<DD>Alternative mode for sector processing (not very useful at all)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FINALIZE_PRESORTZ">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FINALIZE_PRESORTY"><!-- --></A><H3>
FINALIZE_PRESORTY</H3>
<PRE>
public static final int <B>FINALIZE_PRESORTY</B></PRE>
<DL>
<DD>Alternative mode for sector processing (not very useful at all)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FINALIZE_PRESORTY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FINALIZE_PRESORTX"><!-- --></A><H3>
FINALIZE_PRESORTX</H3>
<PRE>
public static final int <B>FINALIZE_PRESORTX</B></PRE>
<DL>
<DD>Alternative mode for sector processing (not very useful at all)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.FINALIZE_PRESORTX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_XY"><!-- --></A><H3>
ENVMAP_XY</H3>
<PRE>
public static final int <B>ENVMAP_XY</B></PRE>
<DL>
<DD>'Direction' of spherical environment mapping is XY (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_XY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_XZ"><!-- --></A><H3>
ENVMAP_XZ</H3>
<PRE>
public static final int <B>ENVMAP_XZ</B></PRE>
<DL>
<DD>'Direction' of spherical environment mapping is XZ
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_XZ">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ENVMAP_YZ"><!-- --></A><H3>
ENVMAP_YZ</H3>
<PRE>
public static final int <B>ENVMAP_YZ</B></PRE>
<DL>
<DD>'Direction' of spherical environment mapping is YZ
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ENVMAP_YZ">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OBJ_VISIBLE"><!-- --></A><H3>
OBJ_VISIBLE</H3>
<PRE>
public static final boolean <B>OBJ_VISIBLE</B></PRE>
<DL>
<DD>The object is visible
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.OBJ_VISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OBJ_INVISIBLE"><!-- --></A><H3>
OBJ_INVISIBLE</H3>
<PRE>
public static final boolean <B>OBJ_INVISIBLE</B></PRE>
<DL>
<DD>The object is invisible and won't be processed, rendered...nothing...
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.OBJ_INVISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SECTOR_AUTODETECT"><!-- --></A><H3>
SECTOR_AUTODETECT</H3>
<PRE>
public static final boolean <B>SECTOR_AUTODETECT</B></PRE>
<DL>
<DD>Use autodetection of the covered sectors (for example for animated
 objects)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SECTOR_AUTODETECT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SECTOR_PRECALCULATED"><!-- --></A><H3>
SECTOR_PRECALCULATED</H3>
<PRE>
public static final boolean <B>SECTOR_PRECALCULATED</B></PRE>
<DL>
<DD>Use static sector information
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SECTOR_PRECALCULATED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_NONE"><!-- --></A><H3>
COLLISION_CHECK_NONE</H3>
<PRE>
public static final int <B>COLLISION_CHECK_NONE</B></PRE>
<DL>
<DD>Don't perform any kind of collision detection for this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_OTHERS"><!-- --></A><H3>
COLLISION_CHECK_OTHERS</H3>
<PRE>
public static final int <B>COLLISION_CHECK_OTHERS</B></PRE>
<DL>
<DD>Other Object3Ds/rays/spheres/ellipsoids may collide with this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_OTHERS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_CHECK_SELF"><!-- --></A><H3>
COLLISION_CHECK_SELF</H3>
<PRE>
public static final int <B>COLLISION_CHECK_SELF</B></PRE>
<DL>
<DD>This Object3D may collide with other objects
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_CHECK_SELF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_NONE"><!-- --></A><H3>
COLLISION_NONE</H3>
<PRE>
public static final float <B>COLLISION_NONE</B></PRE>
<DL>
<DD>Signals that no collision has been detected for this object
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RAY_MISSES_BOX"><!-- --></A><H3>
RAY_MISSES_BOX</H3>
<PRE>
public static final float <B>RAY_MISSES_BOX</B></PRE>
<DL>
<DD>Signals that a ray/box-intersection test has failed (the ray doesn't
 intersect with the box)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.RAY_MISSES_BOX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_DETECTION_OPTIMIZED"><!-- --></A><H3>
COLLISION_DETECTION_OPTIMIZED</H3>
<PRE>
public static final boolean <B>COLLISION_DETECTION_OPTIMIZED</B></PRE>
<DL>
<DD>Enables an automated optimization for speeding up collision detection in
 some case. May cause problems on dynamically changing geometry.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_DETECTION_OPTIMIZED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="COLLISION_DETECTION_NOT_OPTIMIZED"><!-- --></A><H3>
COLLISION_DETECTION_NOT_OPTIMIZED</H3>
<PRE>
public static final boolean <B>COLLISION_DETECTION_NOT_OPTIMIZED</B></PRE>
<DL>
<DD>Disables (default) an automated optimization for collision detection in
 case of problems with this optimization.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.COLLISION_DETECTION_NOT_OPTIMIZED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SHADING_GOURAUD"><!-- --></A><H3>
SHADING_GOURAUD</H3>
<PRE>
public static final int <B>SHADING_GOURAUD</B></PRE>
<DL>
<DD>Indicates that gouraud shading should be used (default)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SHADING_GOURAUD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SHADING_FAKED_FLAT"><!-- --></A><H3>
SHADING_FAKED_FLAT</H3>
<PRE>
public static final int <B>SHADING_FAKED_FLAT</B></PRE>
<DL>
<DD>Indicates that (faked) flat shading should be used. Faked, because it
 sits on top of gouraud, i.e. it's not faster than using gouraud shading.
 In fact it may be slower because it hinders the usage of triangle strips.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.SHADING_FAKED_FLAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LIGHTING_ALL_ENABLED"><!-- --></A><H3>
LIGHTING_ALL_ENABLED</H3>
<PRE>
public static final int <B>LIGHTING_ALL_ENABLED</B></PRE>
<DL>
<DD>Indicates that all kinds of light (lightsources, ambient and additional
 color) will be used on this object. This is default.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.LIGHTING_ALL_ENABLED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LIGHTING_NO_LIGHTS"><!-- --></A><H3>
LIGHTING_NO_LIGHTS</H3>
<PRE>
public static final int <B>LIGHTING_NO_LIGHTS</B></PRE>
<DL>
<DD>Indicates that no lightsources will be taken into account to calculate an
 object's lighting. Ambient light and the additional color will be used.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.LIGHTING_NO_LIGHTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ELLIPSOID_ALIGNED"><!-- --></A><H3>
ELLIPSOID_ALIGNED</H3>
<PRE>
public static final int <B>ELLIPSOID_ALIGNED</B></PRE>
<DL>
<DD>The object's ellipsoid won't be transformed when performing collision
 detection (default).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ELLIPSOID_ALIGNED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ELLIPSOID_TRANSFORMED"><!-- --></A><H3>
ELLIPSOID_TRANSFORMED</H3>
<PRE>
public static final int <B>ELLIPSOID_TRANSFORMED</B></PRE>
<DL>
<DD>The object's ellipsoid will be transformed when performing collision
 detection.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.ELLIPSOID_TRANSFORMED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="UNKNOWN_OBJECTSIZE"><!-- --></A><H3>
UNKNOWN_OBJECTSIZE</H3>
<PRE>
public static final int <B>UNKNOWN_OBJECTSIZE</B></PRE>
<DL>
<DD>The object is empty
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.UNKNOWN_OBJECTSIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NO_OBJECT"><!-- --></A><H3>
NO_OBJECT</H3>
<PRE>
public static final int <B>NO_OBJECT</B></PRE>
<DL>
<DD>The "ID" of an Object3D that doesn't exist. If a method that usually
 returns an Object-ID returns this value, no appropiate Object3D has been
 found.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#com.threed.jpct.Object3D.NO_OBJECT">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Object3D(int)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(int&nbsp;maxTriangles)</PRE>
<DL>
<DD>Creates a new instance of Object3D. Usually, an object is created to be
 added to some instance of World. You may also create dummy objects, that
 are just "lending" there transformations to their child-objects, but this
 should be done by using createDummyObj().
<P>
<DT><B>Parameters:</B><DD><CODE>maxTriangles</CODE> - the maximum number of triangles for this object.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#createDummyObj()"><CODE>createDummyObj()</CODE></A></DL>
<HR>

<A NAME="Object3D(com.threed.jpct.Object3D)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 Consider this to be a kind of "workaround" for the fact that you can't
 extend a loaded (by Loader) or created (by Primitives) Object3D directly.
<P>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to construct this Object3D from</DL>
<HR>

<A NAME="Object3D(com.threed.jpct.Object3D, boolean)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj,
                boolean&nbsp;reuseMesh)</PRE>
<DL>
<DD>This constructor works similar to cloneObject() but it allows to extend
 Object3D and still use the static methods from Loader/Primitives by
 adding a call to super(Object3D) in the constructor of your class.
 Consider this to be a kind of "workaround" for the fact that you can't
 extend a loaded (by Loader) or created (by Primitives) Object3D directly.
<P>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to construct this Object3D from<DD><CODE>reuseMesh</CODE> - if true, the new object will use the same mesh</DL>
<HR>

<A NAME="Object3D(float[], float[], int[], int)"><!-- --></A><H3>
Object3D</H3>
<PRE>
public <B>Object3D</B>(float[]&nbsp;coordinates,
                float[]&nbsp;uvs,
                int[]&nbsp;indices,
                int&nbsp;textureId)</PRE>
<DL>
<DD>Constructor for creating an Object3D out of indexed geometry in bulk
 form. This can be useful to create an Object3D at once from data loaded
 by one's own file loader.
<P>
<DT><B>Parameters:</B><DD><CODE>coordinates</CODE> - the coordinates [x1,y1,z1,x2,y2,z2,...]<DD><CODE>uvs</CODE> - the texture coordinates [u1,v1,u2,v2,...]<DD><CODE>indices</CODE> - the indices indexing the tuples/triples in the coordinate
            arrays<DD><CODE>textureId</CODE> - the texture id. If not known, just use
            TextureManager.TEXTURE_NOTFOUND</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="createDummyObj()"><!-- --></A><H3>
createDummyObj</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>createDummyObj</B>()</PRE>
<DL>
<DD>Static method that creates a dummy Object3D. This dummy object is
 basically a normal but empty object. This method should be used to create
 an object that won't be added to the world but linked to another object
 as a child object. This could be useful to enhance the flexiblity of the
 object bindings (like a moon spinning around a planet...it may be useful
 to link the moon to the planet via a dummy object placed in the planet's
 center. This enables the moon not only to inherit the transformations of
 the planet but also the transformations of the dummy object). There is no
 need nor any sense in adding a dummy object directly to the world.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a dummy Object3D<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)"><CODE>World.addObject(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setUserObject(java.lang.Object)"><!-- --></A><H3>
setUserObject</H3>
<PRE>
public void <B>setUserObject</B>(java.lang.Object&nbsp;obj)</PRE>
<DL>
<DD>This method is a "workaround" in case you want to give additional
 information to an Object3D but don't want to (or can't) extend Object3D
 itself.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - Object whatever you like...</DL>
</DD>
</DL>
<HR>

<A NAME="getUserObject()"><!-- --></A><H3>
getUserObject</H3>
<PRE>
public java.lang.Object <B>getUserObject</B>()</PRE>
<DL>
<DD>Return the user defined object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Object the Object</DL>
</DD>
</DL>
<HR>

<A NAME="setSortOffset(float)"><!-- --></A><H3>
setSortOffset</H3>
<PRE>
public void <B>setSortOffset</B>(float&nbsp;offset)</PRE>
<DL>
<DD>Sets on offset for the z-Sorting. Usually this is not needed, but it
 could be helpful for transparent objects that are sorted incorrectly
 otherwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - the offset</DL>
</DD>
</DL>
<HR>

<A NAME="mergeObjects(com.threed.jpct.Object3D, com.threed.jpct.Object3D)"><!-- --></A><H3>
mergeObjects</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>mergeObjects</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;first,
                                    <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;second)</PRE>
<DL>
<DD>Static method that merges two objects into a third one. This should be
 done before calling build() on any of these objects and it does not copy
 other properties of the object (like rendering modes etc...).<br>
 Merging objects is quite expensive in terms of memory usage. Merged
 objects are not compressed by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>first</CODE> - the first object to merge<DD><CODE>second</CODE> - the second object to merge
<DT><B>Returns:</B><DD>the merged object</DL>
</DD>
</DL>
<HR>

<A NAME="mergeAll(com.threed.jpct.Object3D[])"><!-- --></A><H3>
mergeAll</H3>
<PRE>
public static <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>mergeAll</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[]&nbsp;objs)</PRE>
<DL>
<DD>Merges all objects in the array into one large object. The array will be
 empty afterwards.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objs</CODE> - the objects
<DT><B>Returns:</B><DD>the merged result</DL>
</DD>
</DL>
<HR>

<A NAME="resetNextID()"><!-- --></A><H3>
resetNextID</H3>
<PRE>
public static void <B>resetNextID</B>()</PRE>
<DL>
<DD>Resets the internal object-counter. This could be useful in applets,
 where the static class members are not reinitialized when reloading the
 applet.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNextID()"><!-- --></A><H3>
getNextID</H3>
<PRE>
public static int <B>getNextID</B>()</PRE>
<DL>
<DD>Static method that returns the ID the next object will get. This is
 useful to know if (and only if) you want to serialize your world, because
 this value isn't serialized by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the ID</DL>
</DD>
</DL>
<HR>

<A NAME="setNextID(int)"><!-- --></A><H3>
setNextID</H3>
<PRE>
public static void <B>setNextID</B>(int&nbsp;next)</PRE>
<DL>
<DD>Sets the ID the next object will get. It has to be higher than the
 current one. This method can be used to deserialize a world. Be careful
 when using this method, because screwing up the IDs will most likely
 screw up everything else.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>next</CODE> - the next ID</DL>
</DD>
</DL>
<HR>

<A NAME="compile()"><!-- --></A><H3>
compile</H3>
<PRE>
public void <B>compile</B>()</PRE>
<DL>
<DD>Compiles an Object3D. Don't confuse this with build(), which does
 something completely different. A compiled object can be rendered faster
 when using the hardware renderer but has some shortcomings: The object's
 number of texture layers will be limited to the number that the current
 hardware actually support. Everything higher will simply be ignored. You
 can't add polygons to a compiled object and changing textures of single
 polygons isn't possible. The lighting is always calculated with an
 implicit lightMul of 1, so it's advised to change Config.lightMul to 1
 when mixing compiled with uncompiled objects (this method already does
 this for you).<br>
 This method compiles the object to a static object. You can't change
 vertices and/or uv-coordinates on this object afterwards, but it gives
 you the best performance. <br>
 Compiling only affects the hardware renderer, but you can't render an
 object compiled by the hardware renderer once with the software renderer.
 However, you may call compile() on any object as long as you are using
 the software renderer only...it won't show any effect.<br>
 A compiled object can only be rendered correctly with vertex arrays
 enabled in Config (which is default), which is why this methods enables
 them if needed.<br>
 The compiled part of the object won't be serialized.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#lightMul"><CODE>Config.lightMul</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="compileAndStrip()"><!-- --></A><H3>
compileAndStrip</H3>
<PRE>
public void <B>compileAndStrip</B>()</PRE>
<DL>
<DD>Compiles and strips an Object3D.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#compile()"><CODE>compile()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#strip()"><CODE>strip()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="compile(boolean)"><!-- --></A><H3>
compile</H3>
<PRE>
public void <B>compile</B>(boolean&nbsp;dynamic)</PRE>
<DL>
<DD>Compiles an Object3D. Unlike compile(), this method allows to compile the
 object to a dynamic one. This can be used on animated objects, but the
 result will be slower than with a static object. Objects compiled with
 this method don't handle modified u/v-coordinates, just modified
 vertices.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dynamic</CODE> - if true, the object will be compiled to a dynamic object,
            otherwise to a static one.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#compile()"><CODE>compile()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="compile(boolean, boolean, boolean, boolean, int)"><!-- --></A><H3>
compile</H3>
<PRE>
public void <B>compile</B>(boolean&nbsp;dynamic,
                    boolean&nbsp;staticUV,
                    boolean&nbsp;preferDisplayListsOrVBO,
                    boolean&nbsp;indexed,
                    int&nbsp;batchSize)</PRE>
<DL>
<DD>Compiles an Object3D. This is the most flexible compile()-method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dynamic</CODE> - if true, the object will be compiled to a dynamic object,
            otherwise to a static one.<DD><CODE>staticUV</CODE> - if true, uv changes are not supported. If false, they are
            (this is slower!)<DD><CODE>preferDisplayListsOrVBO</CODE> - if true, objects will be compiled to display lists or VBOs
            (depending on Config.glUseVBO) if possible. This is faster
            than not to.<DD><CODE>indexed</CODE> - if true, indexed geometry will be used. It's advised to do
            this on static objects while it can be slow on dynamic ones.<DD><CODE>batchSize</CODE> - the batch size for OpenGL. It's hard to find a good balance
            here. Very high values may lead to crashes in the driver or
            missing polygons.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Config.html#glBatchSize"><CODE>Config.glBatchSize</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="forceGeometryIndices(boolean)"><!-- --></A><H3>
forceGeometryIndices</H3>
<PRE>
public void <B>forceGeometryIndices</B>(boolean&nbsp;dnc)</PRE>
<DL>
<DD>Does nothing in jPCT. It's in here just for compatibility reasons with
 jPCT-AE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dnc</CODE> - doesn't matter</DL>
</DD>
</DL>
<HR>

<A NAME="isCompiled()"><!-- --></A><H3>
isCompiled</H3>
<PRE>
public boolean <B>isCompiled</B>()</PRE>
<DL>
<DD>Returns if the object is compiled. Please note, that this method doesn't
 return true right after calling compile() on an object, because
 compilation happens later in the pipeline.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>has it been compiled?</DL>
</DD>
</DL>
<HR>

<A NAME="shareCompiledData(com.threed.jpct.Object3D)"><!-- --></A><H3>
shareCompiledData</H3>
<PRE>
public void <B>shareCompiledData</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;withObj)</PRE>
<DL>
<DD>Enables a compiled object to share data with another compiled one. This
 helps to save system or GPU memory, depending on the used mode for
 compilation.<br/>
 To share data, some preconditions have to be met. The object you would
 like to share data with must not share data itself with some other, it
 has to be a compiled object and must not use an octree. Furthermore, both
 objects have to use the same mesh (not just the same data but the exact
 same instance) and this object must not share data with some other.<br/>
 This object will inherit all texture coordinates and vertex alpha values
 from the source object no matter what may have been assigned to it.<br/>
 Please note that you still have to call compile() on this object.
 However, any parameters given to the compile method will be ignored.<br/>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>withObj</CODE> - the object to share data with</DL>
</DD>
</DL>
<HR>

<A NAME="decompile(com.threed.jpct.FrameBuffer)"><!-- --></A><H3>
decompile</H3>
<PRE>
public void <B>decompile</B>(<A HREF="../../../com/threed/jpct/FrameBuffer.html" title="class in com.threed.jpct">FrameBuffer</A>&nbsp;buffer)</PRE>
<DL>
<DD>Decompiles an object. A decompiled object will be rendered using the
 normal rendering pipeline again. Stripped objects can't be decompiled.
 While compiling an object isn't a cheap operation, decompiling is.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the frame buffer. Because display lists are bound to the
            OpenGL context, it's needed here. It may be null if the object
            hasn't been send to the graphics card yet (i.e. if
            isCompiled() returns null).</DL>
</DD>
</DL>
<HR>

<A NAME="touch()"><!-- --></A><H3>
touch</H3>
<PRE>
public void <B>touch</B>()</PRE>
<DL>
<DD>Touches an object. This has a meaning for dynamically compiled objects
 and for objects that use lazy transformations. If touched, changes in
 vertices (and u/v-coordinates if supported) will be retransfered to the
 graphics card and the transformation matrices of objects using lazy
 transformations will be recalculated.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="strip()"><!-- --></A><H3>
strip</H3>
<PRE>
public void <B>strip</B>()</PRE>
<DL>
<DD>Strips an Object3D. This is only possible on compiled objects. It frees
 some memory that isn't needed anymore by a compiled object. It's NOT
 possible to decompile a stripped object anymore!<br>
 Be careful when objects are sharing meshes, because this method strips an
 object's mesh in a certain way too. This can only be done, if the mesh
 isn't used by no other uncompiled object anymore...the method tries to
 handle this, but it may fail if meshes are used across worlds.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAnimationSequence(com.threed.jpct.Animation)"><!-- --></A><H3>
setAnimationSequence</H3>
<PRE>
public void <B>setAnimationSequence</B>(<A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A>&nbsp;anim)</PRE>
<DL>
<DD>Sets the keyframe animation sequence that should be used for this object.
 It is required that the object is already initialized with a frame
 (usually the first) of the animation including texture-coords, -data and
 mesh information. The keyframes of an animation only contain the raw mesh
 data (like getMesh() would return it). Everything else needs to be taken
 from the object itself.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>anim</CODE> - the animation sequence<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct"><CODE>Animation</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#getMesh()"><CODE>getMesh()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clearAnimation()"><!-- --></A><H3>
clearAnimation</H3>
<PRE>
public void <B>clearAnimation</B>()</PRE>
<DL>
<DD>Clears the animation for this object. The object ist no longer animated.
 Its mesh data will be that of the last frame interpolation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAnimationSequence()"><!-- --></A><H3>
getAnimationSequence</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct">Animation</A> <B>getAnimationSequence</B>()</PRE>
<DL>
<DD>Returns the animation sequence.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the Animation sequence or null if none has been defined</DL>
</DD>
</DL>
<HR>

<A NAME="animate(float, int)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(float&nbsp;index,
                    int&nbsp;seq)</PRE>
<DL>
<DD>Calculates a new mesh for this object based on the keyframes of its
 animation sub-sequence and "index". index is a value between 0 and 1
 where 0 is the first keyframe and 1 the last (of the sub-sequence). If
 seq is zero, the whole animation will be treated as a sub-sequence.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the "time-index" into the sub-sequence of the animation<DD><CODE>seq</CODE> - the number of the sub.sequence (sub-sequence start at 1, 0
            stands for the animation as a whole)</DL>
</DD>
</DL>
<HR>

<A NAME="animate(float)"><!-- --></A><H3>
animate</H3>
<PRE>
public void <B>animate</B>(float&nbsp;index)</PRE>
<DL>
<DD>Calculates a new mesh for this object based on the keyframes of its
 animation sequence and "index". index is a value between 0 and 1 where 0
 is the first keyframe and 1 the last. Because no sub-sequence is
 indicated, the complete animation will be used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the "time-index" into the animation</DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionMode(int)"><!-- --></A><H3>
setCollisionMode</H3>
<PRE>
public void <B>setCollisionMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets if and how the object will respond to collisions. Setting mode to
 COLLISION_CHECK_NONE (which is default) means, that the object can't be
 partner in a collision with other objects. Setting it to
 COLLISION_CHECK_OTHERS means that other objects may collide with this
 object and setting it to COLLISION_CHECK_SELF means, that the object
 itself may collide with other objects. The modes may be combined by using
 the or-operator | .
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - The desired mode (COLLISION_CHECK_NONE,
            COLLISION_CHECK_OTHERS, COLLISION_CHECK_SELF or combinations)<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_NONE"><CODE>COLLISION_CHECK_NONE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_OTHERS"><CODE>COLLISION_CHECK_OTHERS</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_CHECK_SELF"><CODE>COLLISION_CHECK_SELF</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCollisionOptimization(boolean)"><!-- --></A><H3>
setCollisionOptimization</H3>
<PRE>
public void <B>setCollisionOptimization</B>(boolean&nbsp;optimized)</PRE>
<DL>
<DD>Sets an optimization for collision detection to be used/not used. This
 optimization may cause problems on dynamically updated geometry from an
 animation or an IVertexController. Therefor, it's disabled by default.
 Couldn't hurt to try it anyway...:-)<br>
 This optimization affects collisions WITH this object, not OF this
 object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>optimized</CODE> - should the collision detection be optimized or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_OPTIMIZED"><CODE>COLLISION_DETECTION_OPTIMIZED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_DETECTION_NOT_OPTIMIZED"><CODE>COLLISION_DETECTION_NOT_OPTIMIZED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setVisibility(boolean)"><!-- --></A><H3>
setVisibility</H3>
<PRE>
public void <B>setVisibility</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the object to visible/invisible. Invisible objects won't be
 processed/rendered at all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - visible or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE"><CODE>OBJ_VISIBLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE"><CODE>OBJ_INVISIBLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVisibility()"><!-- --></A><H3>
getVisibility</H3>
<PRE>
public boolean <B>getVisibility</B>()</PRE>
<DL>
<DD>Returns the current visibility state of the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>object is visible/invisible<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#OBJ_VISIBLE"><CODE>OBJ_VISIBLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#OBJ_INVISIBLE"><CODE>OBJ_INVISIBLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcBoundingBox()"><!-- --></A><H3>
calcBoundingBox</H3>
<PRE>
public void <B>calcBoundingBox</B>()</PRE>
<DL>
<DD>Calculates an AABB (Axis Aligned Bounding Box) for this object in
 object-space. The box will then be transformed together with the object
 so that it becomes an OBB (oriented bounding box) when the object will be
 transformed. Normally, there is no need to call this method directly,
 because it will already be called from the build() method. Exceptions
 could be the use of objects meshes for animation and similar tasks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createTriangleStrips()"><!-- --></A><H3>
createTriangleStrips</H3>
<PRE>
public void <B>createTriangleStrips</B>()</PRE>
<DL>
<DD>Tries to rebuild the object in a way that it can be rendered by using
 triangle strips in the most optimal way. This may be useful when using
 the OpenGL renderer to increase performance for complex objects. The
 software renderer doesn't use this information (but it shouldn't hurt
 either). This calculation may take a lot of time on complex objects. <br>
 The current implementation is not very clever...there is room for
 improvement in later versions. In case multipass striping is used, this
 method uses a maximum number of 50 passes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#createTriangleStrips()"><CODE>World.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glTriangleStrips"><CODE>Config.glTriangleStrips</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#useMultipassStriping"><CODE>Config.useMultipassStriping</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="createTriangleStrips(int)"><!-- --></A><H3>
createTriangleStrips</H3>
<PRE>
public void <B>createTriangleStrips</B>(int&nbsp;maxPasses)</PRE>
<DL>
<DD>Tries to rebuild the object in a way that it can be rendered by using
 triangle strips in the most optimal way. This may be useful when using
 the OpenGL renderer to increase performance for complex objects. The
 software renderer doesn't use this information (but it shouldn't hurt
 either). This calculation may take a lot of time on complex objects. <br>
 The current implementation is not very clever...there is room for
 improvement in later versions.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxPasses</CODE> - the maximum number of passes in case multipass striping is
            used<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#createTriangleStrips()"><CODE>World.createTriangleStrips()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#glTriangleStrips"><CODE>Config.glTriangleStrips</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#useMultipassStriping"><CODE>Config.useMultipassStriping</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rebuild()"><!-- --></A><H3>
rebuild</H3>
<PRE>
public void <B>rebuild</B>()</PRE>
<DL>
<DD>The same as build().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="build()"><!-- --></A><H3>
build</H3>
<PRE>
public void <B>build</B>()</PRE>
<DL>
<DD>Initializes some basic object properties that are needed for almost all
 further processing. build() should be called if the object is
 "ready to render" (loaded, Textures assigned, placed, rendering modes
 set...).<br>
 Adding new triangles to an object after calling build() may work but
 doesn't have to. If you want to do this, call unbuild() before. <br>
 There is no need to call build() for every object if buildAllObjects() is
 used. There is also no need to call build() for dummy objects. For any
 other object, build() should be called. "Building" the object is a costly
 operation, so it shouldn't be called without need.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#buildAllObjects()"><CODE>World.buildAllObjects()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="unbuild()"><!-- --></A><H3>
unbuild</H3>
<PRE>
public void <B>unbuild</B>()</PRE>
<DL>
<DD>"Unbuilds" an object, i.e. it takes back some of the changes that build()
 does to the object, so that new triangles can be added again to this
 object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="disableVertexSharing()"><!-- --></A><H3>
disableVertexSharing</H3>
<PRE>
public void <B>disableVertexSharing</B>()</PRE>
<DL>
<DD>Disables the automatic vertex sharing that jPCT does for triangles added
 by addTriangle. This can be useful if single polygons of the object are
 supposed to change their positions independantly from the others (by
 using an IVertexController for example). It will hurt performance though.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="reorderSectors(int)"><!-- --></A><H3>
reorderSectors</H3>
<PRE>
public void <B>reorderSectors</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Reorders the object's meshdata by grouping it according to the sectors.
 reorderSectors() should be used on objects that are used together with
 portal rendering. Normally, this method is already called by the
 build()-method for objects that require it. mode can be FINALIZE_DEFAULT
 (which is how build() calls this method) or FINALIZE_PRESORTX/Y/Z.
 Everything other than FINALIZE_DEFAULT is more or less in for future
 usage. Albeit it does indeed change the reorder-behaviour, it isn't
 useful at all. Stay with FINALIZE_DEFAULT if you have to use this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - How to sort<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_DEFAULT"><CODE>FINALIZE_DEFAULT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTX"><CODE>FINALIZE_PRESORTX</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTY"><CODE>FINALIZE_PRESORTY</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#FINALIZE_PRESORTZ"><CODE>FINALIZE_PRESORTZ</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSectorDetectionMode(boolean)"><!-- --></A><H3>
setSectorDetectionMode</H3>
<PRE>
public void <B>setSectorDetectionMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the method used for sector detection. When using portal rendering,
 it is important to determine in which sector an Object3D is placed. To do
 so, two different kinds of detection are available: static
 (precalculated) and dynamic (autodetect). Static detection should be used
 for objects which are placed into one (and exactly one) sector and which
 won't move (or at least which won't leave the sector). To use static
 detection, the object has to be assigned to a sector by calling the
 setSector()-method. Dynamic detection should be used for objects that are
 covering more than one sector or that (may) move between sectors. Dynamic
 detection is a bit more expensive than static. The main object (that is
 the object which defines the sectors, usually the "map") has to be static
 (it can't move anyway). A third method is to set the detection mode to
 static but to place the object into an undefined sector. This way, the
 object will always be processed which could be handy for small, short
 living objects like particles or projectiles.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - which method to use<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SECTOR_AUTODETECT"><CODE>SECTOR_AUTODETECT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SECTOR_PRECALCULATED"><CODE>SECTOR_PRECALCULATED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setSector(int)"><CODE>setSector(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
hasChild</H3>
<PRE>
public boolean <B>hasChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Tests an object for being a child object of the current object. A child
 object inherits all the transformations of its parent.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should be tested for being a child of this
<DT><B>Returns:</B><DD>true, if obj is a child. Otherwise false.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#hasParent(com.threed.jpct.Object3D)"><CODE>hasParent(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
hasParent</H3>
<PRE>
public boolean <B>hasParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Tests an object for being a parent object of the current object. The
 object inherits all the transformations from its parent object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should be tested for being a parent of this
<DT><B>Returns:</B><DD>true, if obj is a parent. Otherwise false.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#hasChild(com.threed.jpct.Object3D)"><CODE>hasChild(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
addChild</H3>
<PRE>
public void <B>addChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Defines an object as a child of this. A child object will inherit all
 transformations but no other attributes of this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should become a child of this.</DL>
</DD>
</DL>
<HR>

<A NAME="removeChild(com.threed.jpct.Object3D)"><!-- --></A><H3>
removeChild</H3>
<PRE>
public void <B>removeChild</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Removes an object from the child-collection of this. The object itself
 won't be removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to remove</DL>
</DD>
</DL>
<HR>

<A NAME="removeParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
removeParent</H3>
<PRE>
public void <B>removeParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Removes an object from the parent-collection of this. The object itself
 won't be removed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the Object3D to remove</DL>
</DD>
</DL>
<HR>

<A NAME="addParent(com.threed.jpct.Object3D)"><!-- --></A><H3>
addParent</H3>
<PRE>
public void <B>addParent</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;obj)</PRE>
<DL>
<DD>Defines an object as a parent of this. this will inherit all
 transformations and no other attributes from its parent. Defining child
 and parent object is basically the same. Child object of A will
 internally be stored by assigning A as their parent. It's a matter of
 taste which kind of logic one may use. Therefor, both are supported but
 the parent-logic is closer to the implementation...then again: Who cares?
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>obj</CODE> - the object that should become a parent of this.</DL>
</DD>
</DL>
<HR>

<A NAME="getParents()"><!-- --></A><H3>
getParents</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>[] <B>getParents</B>()</PRE>
<DL>
<DD>Returns all parents of this Object3D in an array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>all parents</DL>
</DD>
</DL>
<HR>

<A NAME="getID()"><!-- --></A><H3>
getID</H3>
<PRE>
public int <B>getID</B>()</PRE>
<DL>
<DD>Returns the object's ID. The ID is automatically generated and set in the
 constructor. This ID is used to manage the object once it has been added
 to an instance of World. In some cases, it could be necessary to reset
 the ID.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the internal ID of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#resetNextID()"><CODE>resetNextID()</CODE></A>, 
<A HREF="../../../com/threed/jpct/World.html#addObject(com.threed.jpct.Object3D)"><CODE>World.addObject(com.threed.jpct.Object3D)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A><H3>
getName</H3>
<PRE>
public java.lang.String <B>getName</B>()</PRE>
<DL>
<DD>Returns the name of the object. By default, this is set to "object" plus
 the object's internal ID. It may be overwritten using setName().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the name of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setName(java.lang.String)"><CODE>setName(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A><H3>
setName</H3>
<PRE>
public void <B>setName</B>(java.lang.String&nbsp;n)</PRE>
<DL>
<DD>Sets the name of the object to a name other than the default one. The
 name may be used to identify the object in the world's collection of
 objects. Therefore, the name has to be unique.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the new name of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/World.html#getObjectByName(java.lang.String)"><CODE>World.getObjectByName(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setSelectable(boolean)"><!-- --></A><H3>
setSelectable</H3>
<PRE>
public void <B>setSelectable</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the object as selectable/unselectable. An object that is set to be
 unselectable won't be processed by the pickPolygon() method in
 Interact2D. Default is MOUSE_SELECTABLE.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - MOUSE_SELECTABLE/MOUSE_UNSELECTABLE<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_SELECTABLE"><CODE>MOUSE_SELECTABLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_UNSELECTABLE"><CODE>MOUSE_UNSELECTABLE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSelectable()"><!-- --></A><H3>
isSelectable</H3>
<PRE>
public boolean <B>isSelectable</B>()</PRE>
<DL>
<DD>Returns the current "selectable"-state of the object. On compiled
 objects, this will always return false.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>selectable or not<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_SELECTABLE"><CODE>MOUSE_SELECTABLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#MOUSE_UNSELECTABLE"><CODE>MOUSE_UNSELECTABLE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setSelectable(boolean)"><CODE>setSelectable(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wasVisible()"><!-- --></A><H3>
wasVisible</H3>
<PRE>
public boolean <B>wasVisible</B>()</PRE>
<DL>
<DD>Returns if the object was visible (or at least supposed to be) in the
 last frame. This can be useful for some rough optimizations on the
 application level, but beware of assuming too much frame coherence. The
 method doesn't take overdraw into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if it was visible</DL>
</DD>
</DL>
<HR>

<A NAME="setCulling(boolean)"><!-- --></A><H3>
setCulling</H3>
<PRE>
public void <B>setCulling</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables backface culling for the current object. Backface
 culling is applied to all objects by default. Anyway, some objects may
 require it to be disabled because of the way they are build. Disabling
 backface culling for any object usually double the amount of rendered
 polygons for this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the culling mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED"><CODE>CULLING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED"><CODE>CULLING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCulling()"><!-- --></A><H3>
getCulling</H3>
<PRE>
public boolean <B>getCulling</B>()</PRE>
<DL>
<DD>Returns the current culling mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>boolean<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#CULLING_ENABLED"><CODE>CULLING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#CULLING_DISABLED"><CODE>CULLING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setShadingMode(int)"><!-- --></A><H3>
setShadingMode</H3>
<PRE>
public void <B>setShadingMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>jPCT always uses gouraud shading and that can't be disabled. Anyway, with
 this method it's possible to enable a kind of faked flat shading. It will
 look like flat shading, but it isn't any faster than gouraud. It may even
 be slower, because triangle strips and some other optimizations jPCT can
 apply are disabled when using faked flat shading.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the shading mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SHADING_GOURAUD"><CODE>SHADING_GOURAUD</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SHADING_FAKED_FLAT"><CODE>SHADING_FAKED_FLAT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLighting(int)"><!-- --></A><H3>
setLighting</H3>
<PRE>
public void <B>setLighting</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the lighting mode. Default is, that all kinds of light jPCT knows of
 will influence the final lighting of the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the lighting mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED"><CODE>LIGHTING_ALL_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS"><CODE>LIGHTING_NO_LIGHTS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLighting()"><!-- --></A><H3>
getLighting</H3>
<PRE>
public int <B>getLighting</B>()</PRE>
<DL>
<DD>Gets the lighting mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_ALL_ENABLED"><CODE>LIGHTING_ALL_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#LIGHTING_NO_LIGHTS"><CODE>LIGHTING_NO_LIGHTS</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMaxLights(int)"><!-- --></A><H3>
setMaxLights</H3>
<PRE>
public void <B>setMaxLights</B>(int&nbsp;lightCount)</PRE>
<DL>
<DD>Sets the maximum number of lights that should have an influence on this
 object. This value affects compiled objects only. Default and global max.
 value is 8.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lightCount</CODE> - a value between 0 and 8</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxLights()"><!-- --></A><H3>
getMaxLights</H3>
<PRE>
public int <B>getMaxLights</B>()</PRE>
<DL>
<DD>Returns the maximum number of lights that should have an influence on
 this object. Default is 8.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of lights</DL>
</DD>
</DL>
<HR>

<A NAME="setSpecularLighting(boolean)"><!-- --></A><H3>
setSpecularLighting</H3>
<PRE>
public void <B>setSpecularLighting</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables specular lighting for the object. The specular lighting
 pass is applied in addition to ambient and diffuse lighting. Specular
 lighting may cause objects to look more reflective and realistic. It
 requires some extra processing but usually it's just a matter of taste if
 it will be used on a particular object or not. Specular lighting is
 disabled by default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the specular mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_ENABLED"><CODE>SPECULAR_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_DISABLED"><CODE>SPECULAR_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSpecularLighting()"><!-- --></A><H3>
getSpecularLighting</H3>
<PRE>
public boolean <B>getSpecularLighting</B>()</PRE>
<DL>
<DD>Returns the state of specular lighting.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the specular mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_ENABLED"><CODE>SPECULAR_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#SPECULAR_DISABLED"><CODE>SPECULAR_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFiltering(boolean)"><!-- --></A><H3>
setFiltering</H3>
<PRE>
public void <B>setFiltering</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables filtering on a per texel basis. This filtering helps to
 avoid the blocky look of pick-nearest-filtering but it's not as slow as
 real bilinear filtering. However, it does decrease performance a little
 bit and may introduce rendering artifacts in some situations. Setting
 this to enabled will cause the object to be filtered regardless of what
 the filtering heuristic of the engine says. If it's disabled, jPCT tries
 to determine if a texel needs to be filtered or not (if filtering is
 enabled at all using the Config.texelFilter setting). This setting
 doesn't affect the OpenGL renderer. Disabled is default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the filtering mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#FILTERING_ENABLED"><CODE>FILTERING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#FILTERING_DISABLED"><CODE>FILTERING_DISABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#texelFilter"><CODE>Config.texelFilter</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setTransparency(int)"><!-- --></A><H3>
setTransparency</H3>
<PRE>
public void <B>setTransparency</B>(int&nbsp;trans)</PRE>
<DL>
<DD>Sets the object to be transparent using the given level of transparency.
 Transparency can't be combined with any form of bumpmapping at the
 moment. In addition to the global transparency of the whole object, every
 pixel with a color of #000000 will be completely transparent (if you
 don't supply an alpha channel with the texture). Note: The current
 implementation doesn't use #000000 but #0f0f0f due to accuracy issues
 with JPEG-compression.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trans</CODE> - the tranparency level. 0 is the highest possible transparency,
            a value below 0 will disable tranparency for this object</DL>
</DD>
</DL>
<HR>

<A NAME="getTransparency()"><!-- --></A><H3>
getTransparency</H3>
<PRE>
public int <B>getTransparency</B>()</PRE>
<DL>
<DD>Returns the current tranparency setting.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int the transparency level</DL>
</DD>
</DL>
<HR>

<A NAME="isTransparent()"><!-- --></A><H3>
isTransparent</H3>
<PRE>
public boolean <B>isTransparent</B>()</PRE>
<DL>
<DD>Returns if the object is transparent of not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>is it?</DL>
</DD>
</DL>
<HR>

<A NAME="setTransparencyMode(int)"><!-- --></A><H3>
setTransparencyMode</H3>
<PRE>
public void <B>setTransparencyMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the transparency (blending) mode. This setting isn't supported by
 the legacy renderer and behaviour differs slightly between software and
 hardware renderer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT"><CODE>TRANSPARENCY_MODE_DEFAULT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD"><CODE>TRANSPARENCY_MODE_ADD</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTransparencyMode()"><!-- --></A><H3>
getTransparencyMode</H3>
<PRE>
public int <B>getTransparencyMode</B>()</PRE>
<DL>
<DD>Returns the current transparency mode. This setting is supported by the
 OpenGL renderers only.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_DEFAULT"><CODE>TRANSPARENCY_MODE_DEFAULT</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#TRANSPARENCY_MODE_ADD"><CODE>TRANSPARENCY_MODE_ADD</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasVertexAlpha()"><!-- --></A><H3>
hasVertexAlpha</H3>
<PRE>
public boolean <B>hasVertexAlpha</B>()</PRE>
<DL>
<DD>Returns true, if this object uses vertex alpha values. False, if it
 doesn't, which is default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>does it?</DL>
</DD>
</DL>
<HR>

<A NAME="setAdditionalColor(java.awt.Color)"><!-- --></A><H3>
setAdditionalColor</H3>
<PRE>
public void <B>setAdditionalColor</B>(java.awt.Color&nbsp;col)</PRE>
<DL>
<DD>Sets the additional color for this object. This color will be added to
 the regular color of each vertex (given by ambient, diffuse and specular
 lighting). This can be used to highlight particular objects on purpose.
 The limitation to the range of the AWT's Color doesn't matter here,
 because adding a color brighter than (255,255,255) (jPCT supports this
 overbright lighting) can be useful for lightsources but not for setting a
 color value that isn't processed any further. It simply doesn't get
 whiter than white...:-)<br/>
 When using the ShadowHelper, this can affect the shadow appearance in a
 way that the shadow isn't visible. The ShadowHelper has a method to
 disable the additional color for these cases.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col</CODE> - the color</DL>
</DD>
</DL>
<HR>

<A NAME="setAdditionalColor(int, int, int)"><!-- --></A><H3>
setAdditionalColor</H3>
<PRE>
public void <B>setAdditionalColor</B>(int&nbsp;red,
                               int&nbsp;green,
                               int&nbsp;blue)</PRE>
<DL>
<DD>Sets the additional color for this object. This color will be added to
 the regular color of each vertex (given by ambient, diffuse and specular
 lighting). This can be used to highlight particular objects on purpose.<br/>
 When using the ShadowHelper, this can affect the shadow appearance in a
 way that the shadow isn't visible. The ShadowHelper has a method to
 disable the additional color for these cases.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - the red component (0..255)<DD><CODE>green</CODE> - the green component (0..255)<DD><CODE>blue</CODE> - the blue component (0..255)</DL>
</DD>
</DL>
<HR>

<A NAME="getAdditionalColor()"><!-- --></A><H3>
getAdditionalColor</H3>
<PRE>
public java.awt.Color <B>getAdditionalColor</B>()</PRE>
<DL>
<DD>Returns the additional color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the color</DL>
</DD>
</DL>
<HR>

<A NAME="clearAdditionalColor()"><!-- --></A><H3>
clearAdditionalColor</H3>
<PRE>
public void <B>clearAdditionalColor</B>()</PRE>
<DL>
<DD>Removes additional color information form the object. Calling this method
 is equal to call setAdditionalColor(Color.black).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearObject()"><!-- --></A><H3>
clearObject</H3>
<PRE>
public void <B>clearObject</B>()</PRE>
<DL>
<DD>Clears the object by removing all vertex/mesh information from it. This
 also affects objects that have been cloned from this object, because they
 will lose their mesh-data too. Every other property of the object stays
 intact.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()"><CODE>cloneObject()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#decoupleMesh()"><CODE>decoupleMesh()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMatrixCacheUsage(boolean)"><!-- --></A><H3>
setMatrixCacheUsage</H3>
<PRE>
public void <B>setMatrixCacheUsage</B>(boolean&nbsp;useIt)</PRE>
<DL>
<DD>Enables/Disables the matrix cache. This cache won't improve performance
 but reduces creation of short lived matrix instances. It's enabled by
 default.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>useIt</CODE> - use the cache or don't</DL>
</DD>
</DL>
<HR>

<A NAME="setReNormalization(boolean)"><!-- --></A><H3>
setReNormalization</H3>
<PRE>
public void <B>setReNormalization</B>(boolean&nbsp;reNormalize)</PRE>
<DL>
<DD>Enables re-normalization of transformed normal vectors. Usually, this
 isn't needed as long as you don't set your own rotation matrix, which has
 a non-uniform scaling or some other fancy transformation applied that
 jPCT doesn't know of.<br/>
 This will reduce performance of the vertex transformations and shouldn't
 be enabled without need. In fact, it's a kind of workaround for a problem
 with lighting that will otherwise occur if you use such matrices.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reNormalize</CODE> - do it?</DL>
</DD>
</DL>
<HR>

<A NAME="setDepthBufferWrites(boolean)"><!-- --></A><H3>
setDepthBufferWrites</H3>
<PRE>
public void <B>setDepthBufferWrites</B>(boolean&nbsp;write)</PRE>
<DL>
<DD>This is only important when using the software renderer. By default,
 transparent objects don't write into the zbuffer at all. For some fog
 effects, this may cause a problem. In that case, set this to true to make
 the object write into the zbuffer regardless of the transparency setting.
 Default is false.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>write</CODE> - write to the buffer or not</DL>
</DD>
</DL>
<HR>

<A NAME="decoupleMesh()"><!-- --></A><H3>
decoupleMesh</H3>
<PRE>
public void <B>decoupleMesh</B>()</PRE>
<DL>
<DD>Decouples the current mesh from the object. This may be useful to assign
 another mesh to the object without affecting cloned objects (from this
 object). Without the use of cloned objects, the results of clearObject()
 and decoupleMesh() are the same (= an empty object).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#cloneObject()"><CODE>cloneObject()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#clearObject()"><CODE>clearObject()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBlending(boolean)"><!-- --></A><H3>
setBlending</H3>
<PRE>
public void <B>setBlending</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables blending for the current object. The term blending in
 this context refers to the blending of an environment bumpmapped surface
 together with a normal textured one. This means that the object is
 textured not only by using bumpmapping or normal texture mapping, but by
 a combination of both. While this may look quite good, it is the most
 fillrate hungry kind of texturing offered. To use blending, the
 texturemap and the bumpmap need to be of the same size. Blending is not
 yet supported by the OpenGL renderer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the blending mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#BLENDING_ENABLED"><CODE>BLENDING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#BLENDING_DISABLED"><CODE>BLENDING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBlending()"><!-- --></A><H3>
getBlending</H3>
<PRE>
public boolean <B>getBlending</B>()</PRE>
<DL>
<DD>Returns true if blending is enable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>boolean is blending enabled?</DL>
</DD>
</DL>
<HR>

<A NAME="setBumpmapped(boolean)"><!-- --></A><H3>
setBumpmapped</H3>
<PRE>
public void <B>setBumpmapped</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables enviroment bumpmapping for this object. To use this, a
 bumpmap has to be assigned to the object. The object's texturemap will be
 used as an environment map and has to be 256*256 pixel in size (albeit it
 may work with other formats but it's not advised to use them and a
 warning will be printed out if you do). This is supported only by the
 software renderer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the bumpmapping mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_ENABLED"><CODE>BUMPMAPPING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_DISABLED"><CODE>BUMPMAPPING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBillboarding(boolean)"><!-- --></A><H3>
setBillboarding</H3>
<PRE>
public void <B>setBillboarding</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/disables billboarding for this object. A billboarded object will
 ingore its own rotation matrix and will always face the camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the billboarding mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_ENABLED"><CODE>BILLBOARDING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#BILLBOARDING_DISABLED"><CODE>BILLBOARDING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isBumpmapped()"><!-- --></A><H3>
isBumpmapped</H3>
<PRE>
public boolean <B>isBumpmapped</B>()</PRE>
<DL>
<DD>Returns if bumpmapping is used or not. Bumpmapping is not yet supported
 by the OpenGL renderer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>used...or not...<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_ENABLED"><CODE>BUMPMAPPING_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#BUMPMAPPING_DISABLED"><CODE>BUMPMAPPING_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isEnvmapped()"><!-- --></A><H3>
isEnvmapped</H3>
<PRE>
public boolean <B>isEnvmapped</B>()</PRE>
<DL>
<DD>Returns if environment mapping is used or not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>used...or not...<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED"><CODE>ENVMAP_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED"><CODE>ENVMAP_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEnvmapped(boolean)"><!-- --></A><H3>
setEnvmapped</H3>
<PRE>
public void <B>setEnvmapped</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Enables/Disables environment mapping for the object. If enabled, the
 texturemap assigned to the object will be used as a spherical environment
 map.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the environment mapping mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_ENABLED"><CODE>ENVMAP_ENABLED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_DISABLED"><CODE>ENVMAP_DISABLED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEnvmapMode(boolean)"><!-- --></A><H3>
setEnvmapMode</H3>
<PRE>
public void <B>setEnvmapMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>Sets the mode for environment mapping. Environment mapping can be applied
 using the objects worldspace coordinates or the objects cameraspace
 coordinates. The worldspace-based method is used by default and usually
 closer to reality, but the cameraspace-based approach may look better on
 rather static objects but with a moving camera.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the used mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_WORLDSPACE"><CODE>ENVMAP_WORLDSPACE</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_CAMERASPACE"><CODE>ENVMAP_CAMERASPACE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEnvmapDirection(int)"><!-- --></A><H3>
setEnvmapDirection</H3>
<PRE>
public void <B>setEnvmapDirection</B>(int&nbsp;dir)</PRE>
<DL>
<DD>Sets the pair of coordinates from (x,y,z) that will be used for
 calculating the environment mapping.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dir</CODE> - from which "direction" the environment mapping should be
            applied<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_XY"><CODE>ENVMAP_XY</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_YZ"><CODE>ENVMAP_YZ</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ENVMAP_XZ"><CODE>ENVMAP_XZ</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEnvmapMode()"><!-- --></A><H3>
getEnvmapMode</H3>
<PRE>
public boolean <B>getEnvmapMode</B>()</PRE>
<DL>
<DD>Returns the currently used mode for environment mapping (worldspace or
 cameraspace).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the used mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setEnvmapMode(boolean)"><CODE>setEnvmapMode(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rotateX(float)"><!-- --></A><H3>
rotateX</H3>
<PRE>
public void <B>rotateX</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the x-axis by the given angle
 w (radian, counter clockwise for positive values). This rotation is then
 applied to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateY(float)"><!-- --></A><H3>
rotateY</H3>
<PRE>
public void <B>rotateY</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the y-axis by the given angle
 w (radian, clockwise for positive values). This rotation is then applied
 to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateZ(float)"><!-- --></A><H3>
rotateZ</H3>
<PRE>
public void <B>rotateZ</B>(float&nbsp;w)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around the z-axis by the given angle
 w (radian, counter clockwise for positive values). This rotation is then
 applied to the object when it's rendered the next time.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>w</CODE> - the angle by which should be rotated</DL>
</DD>
</DL>
<HR>

<A NAME="rotateAxis(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
rotateAxis</H3>
<PRE>
public void <B>rotateAxis</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;axis,
                       float&nbsp;angle)</PRE>
<DL>
<DD>Rotates the object's rotation matrix around an arbitrary axis. The method
 is more powerful than the normal rotate-around-an-axis methods, but also
 a bit slower. The resulting matrix will be orthonormalized to ensure
 numerical stability.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>axis</CODE> - a direction-vector pointing into the axis direction with the
            object's rotation pivot as position vector<DD><CODE>angle</CODE> - the angle of the rotation</DL>
</DD>
</DL>
<HR>

<A NAME="translateMesh()"><!-- --></A><H3>
translateMesh</H3>
<PRE>
public void <B>translateMesh</B>()</PRE>
<DL>
<DD>Translates the raw mesh data using the translation and the origin matrix
 of this object. This translation is applied directly onto the mesh and
 therefor it's permanent. This could be useful for defining animation
 keyframes via object meshes or for altering objects in objectspace.
 Translating a mesh forces the object's bounding box to be recalculated
 afterwards (automatically done).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="translate(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trans)</PRE>
<DL>
<DD>Translates ("moves") the object in worldspace by modifying the
 translation matrix. The translation will be applied the next time the
 object is rendered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trans</CODE> - the translation vector</DL>
</DD>
</DL>
<HR>

<A NAME="translate(float, float, float)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(float&nbsp;x,
                      float&nbsp;y,
                      float&nbsp;z)</PRE>
<DL>
<DD>Translates ("moves") the object in worldspace by modifying the
 translation matrix. The translation will be applied the next time the
 object is rendered.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the number of units the object should be translated parallel
            to the x axis<DD><CODE>y</CODE> - the number of units the object should be translated parallel
            to the y axis<DD><CODE>z</CODE> - the number of units the object should be translated parallel
            to the z axis</DL>
</DD>
</DL>
<HR>

<A NAME="align(com.threed.jpct.Camera)"><!-- --></A><H3>
align</H3>
<PRE>
public void <B>align</B>(<A HREF="../../../com/threed/jpct/Camera.html" title="class in com.threed.jpct">Camera</A>&nbsp;camera)</PRE>
<DL>
<DD>Aligns this object with a Camera using the camera's backbuffer matrix.
 This means that the object (i.e. its positive z-axis) will face into the
 same direction as the camera does. Calling this method modifies the
 object's rotation matrix, but not its translation or origin matrix, i.e.
 the object is facing into the camera's direction but it's not
 automatically placed at the camera's position. This has to be done "by
 hand" if required. Keep in mind that the rotation pivot of this object
 influences the outcome too.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>camera</CODE> - the Camera the Object3D should be aligned with</DL>
</DD>
</DL>
<HR>

<A NAME="align(com.threed.jpct.Object3D)"><!-- --></A><H3>
align</H3>
<PRE>
public void <B>align</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;object)</PRE>
<DL>
<DD>Aligns this object with another Object3D. This basically means that both
 objects will face into the same direction after calling this method. Keep
 in mind that the rotation pivot influences the outcome too. This method
 works on the object's own rotation matrix only. It doesn't take
 transformations of parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - the object this object should be aligned with</DL>
</DD>
</DL>
<HR>

<A NAME="setOrientation(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setOrientation</H3>
<PRE>
public void <B>setOrientation</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dir,
                           <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;up)</PRE>
<DL>
<DD>Sets the orientation of this object by giving a direction and an
 up-vector.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dir</CODE> - the direction<DD><CODE>up</CODE> - the up-vector</DL>
</DD>
</DL>
<HR>

<A NAME="enableLazyTransformations()"><!-- --></A><H3>
enableLazyTransformations</H3>
<PRE>
public void <B>enableLazyTransformations</B>()</PRE>
<DL>
<DD>Enables "lazy transformations". When lazy transformations are being used,
 the world-transformation matrix (as well as its inverse if needed) is
 calculated only once and used from there on until lazy transformations
 are being disabled again. This helps to improve performance for static
 objects and it can be VERY helpful to speed-up collision detection with
 such objects. It may also be used on none-static objects if they aren't
 moving/rotating for some time (for example: if a lot of objects should be
 checked for collision, it could be helpful to enable lazy transformations
 before doing this and disabling it right after the tests).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#disableLazyTransformations()"><CODE>disableLazyTransformations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="disableLazyTransformations()"><!-- --></A><H3>
disableLazyTransformations</H3>
<PRE>
public void <B>disableLazyTransformations</B>()</PRE>
<DL>
<DD>Disables "lazy transformations". This is the default setting for every
 new object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#enableLazyTransformations()"><CODE>enableLazyTransformations()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="scale(float)"><!-- --></A><H3>
scale</H3>
<PRE>
public void <B>scale</B>(float&nbsp;scale)</PRE>
<DL>
<DD>Scales the object. A scale-value greater than 1 will result in the object
 to get bigger, while a value lower than 1 causes the object to shrink
 (when transformed...the Mesh won't be touched). Remember that the scales
 (as well as rotations and translations) are cumulative.<br/>
 Please note that setting or clearing the rotation matrix will reset this
 value. You are supposed to reset the scaling to 1 before doing so.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scale</CODE> - the new scale<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setScale(float)"><CODE>setScale(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setScale(float)"><!-- --></A><H3>
setScale</H3>
<PRE>
public void <B>setScale</B>(float&nbsp;absScale)</PRE>
<DL>
<DD>Sets an absolute value for the object's scaling. Useful, if the
 cumulative scaling of scale() isn't what one wants.<br/>
 Please note that setting or clearing the rotation matrix will reset this
 value. You are supposed to reset the scaling to 1 before doing so.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>absScale</CODE> - the new (absolute) scale<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#scale(float)"><CODE>scale(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getScale()"><!-- --></A><H3>
getScale</H3>
<PRE>
public float <B>getScale</B>()</PRE>
<DL>
<DD>Returns the cumulated scale value for this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the current scaling</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation()"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTranslation</B>()</PRE>
<DL>
<DD>Returns the translation of the object (from its origin to its current
 position)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslation(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getTranslation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTranslation</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;trns)</PRE>
<DL>
<DD>Returns the translation of the object. The returned SimpleVector is the
 same one as the one given as parameter. This is useful to save the
 creation of an additional object. If null is given, a new one will be
 created.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>trns</CODE> - the SimpleVector to fill and return
<DT><B>Returns:</B><DD>the translation</DL>
</DD>
</DL>
<HR>

<A NAME="getOrigin()"><!-- --></A><H3>
getOrigin</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getOrigin</B>()</PRE>
<DL>
<DD>Returns the origin of the object (as set by setOrigin()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the oring</DL>
</DD>
</DL>
<HR>

<A NAME="getXAxis()"><!-- --></A><H3>
getXAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getXAxis</B>()</PRE>
<DL>
<DD>Returns the x-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the x-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getYAxis()"><!-- --></A><H3>
getYAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getYAxis</B>()</PRE>
<DL>
<DD>Returns the y-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the y-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getZAxis()"><!-- --></A><H3>
getZAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getZAxis</B>()</PRE>
<DL>
<DD>Returns the z-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the z-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getXAxis(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getXAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getXAxis</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</PRE>
<DL>
<DD>Returns the x-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
 This method fills the given SimpleVector in addition to returning it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toFill</CODE> - the vector to fill
<DT><B>Returns:</B><DD>the x-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getYAxis(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getYAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getYAxis</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</PRE>
<DL>
<DD>Returns the y-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
 This method fills the given SimpleVector in addition to returning it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toFill</CODE> - the vector to fill
<DT><B>Returns:</B><DD>the y-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getZAxis(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getZAxis</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getZAxis</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</PRE>
<DL>
<DD>Returns the z-axis of the object. This is an imaginary axis useful for
 movement und rotations relative to the object. This is based on the
 rotation matrix only. It doesn't take any parent objects into account.
 This method fills the given SimpleVector in addition to returning it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>toFill</CODE> - the vector to fill
<DT><B>Returns:</B><DD>the z-axis</DL>
</DD>
</DL>
<HR>

<A NAME="getRotationMatrix()"><!-- --></A><H3>
getRotationMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getRotationMatrix</B>()</PRE>
<DL>
<DD>Returns the object's current rotation matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the rotation matrix of this object</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslationMatrix()"><!-- --></A><H3>
getTranslationMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getTranslationMatrix</B>()</PRE>
<DL>
<DD>Returns the object's current translation matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the translation matrix of this object</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginMatrix()"><!-- --></A><H3>
getOriginMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getOriginMatrix</B>()</PRE>
<DL>
<DD>Returns the object's origin-translation matrix. This matrix is a kind of
 static translation matrix for the object used to initially place the
 object into worldspace. Without using child/parent-objects, there is no
 difference between using the translation and the origin matrix, but only
 the former will be applied to child objects of this object. It is advised
 to use the origin matrix to place the object into worldspace once and to
 execute all further translations by using the translation matrix (or by
 using the translate()-method which already does this for you).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the origin-translation matrix of this object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float,float,float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setOrigin(com.threed.jpct.SimpleVector)"><CODE>setOrigin(com.threed.jpct.SimpleVector)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getLightCount()"><!-- --></A><H3>
getLightCount</H3>
<PRE>
public int <B>getLightCount</B>()</PRE>
<DL>
<DD>Returns the number of lights that have an influence on this object. This
 is only valid during rendering, i.e. only when called from within an
 IRenderHook.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the number of used lights</DL>
</DD>
</DL>
<HR>

<A NAME="setRotationMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setRotationMatrix</H3>
<PRE>
public void <B>setRotationMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets the rotation matrix for the object. Usually, this is not required as
 long as the rotateX/Y/Z() methods are satisfying your needs. If you do
 this, make sure to reset the scale by calling setScale(1f) is you have
 previously modified it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the new rotation matrix<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#rotateX(float)"><CODE>rotateX(float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#rotateY(float)"><CODE>rotateY(float)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#rotateZ(float)"><CODE>rotateZ(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setTextureMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setTextureMatrix</H3>
<PRE>
public void <B>setTextureMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets a matrix that is applied to transform the texture in stage 0. Only
 works realible on compiled objects. On none-compiled objects, it works
 for non-threaded renderers, but not on threaded ones. If no
 transformation is needed, null should be set instead of an empty matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the matrix</DL>
</DD>
</DL>
<HR>

<A NAME="getTextureMatrix()"><!-- --></A><H3>
getTextureMatrix</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getTextureMatrix</B>()</PRE>
<DL>
<DD>Returns the current texture matrix of null if none is set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="clearRotation()"><!-- --></A><H3>
clearRotation</H3>
<PRE>
public void <B>clearRotation</B>()</PRE>
<DL>
<DD>Resets the current rotation to the initial value, i.e. no rotation at
 all. This will also reset the scale.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearTranslation()"><!-- --></A><H3>
clearTranslation</H3>
<PRE>
public void <B>clearTranslation</B>()</PRE>
<DL>
<DD>Resets the current translation to the initial value, i.e. no translation
 at all.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rotateMesh()"><!-- --></A><H3>
rotateMesh</H3>
<PRE>
public void <B>rotateMesh</B>()</PRE>
<DL>
<DD>Rotates the raw mesh data using the rotation matrix specified for this
 object. This rotation is applied directly onto the mesh and therefor it's
 permanent. This could be useful for defining animation keyframes via
 object meshes or for altering objects in objectspace. Rotating a mesh
 forces the object's bounding box to be recalculated afterwards
 (automatically done). The rotation matrix of the object won't be reset by
 this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTranslationMatrix(com.threed.jpct.Matrix)"><!-- --></A><H3>
setTranslationMatrix</H3>
<PRE>
public void <B>setTranslationMatrix</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Sets the translation matrix for the object. Usually, this is not required
 as long as the translate() method is satisfying your needs.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the new translation matrix<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float,float,float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMesh(com.threed.jpct.Mesh)"><!-- --></A><H3>
setMesh</H3>
<PRE>
public void <B>setMesh</B>(<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A>&nbsp;mesh)</PRE>
<DL>
<DD>Sets an object's mesh to another one. Shouldn't be required in normal
 applications.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mesh</CODE> - the new mesh of the object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#getMesh()"><CODE>getMesh()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()"><CODE>calcBoundingBox()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMesh()"><!-- --></A><H3>
getMesh</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct">Mesh</A> <B>getMesh</B>()</PRE>
<DL>
<DD>Returns the current mesh of the object. This is useful for using an
 object's mesh data as keyframes for an animation. The returned mesh can
 also be added to another object by using setMesh(). If you do so, both
 objects will share the same instance of mesh. That isn't a problem as
 long as you don't want to modify the mesh of one object without changing
 the other's. In this case, you should better use a copy of the mesh
 obtained from Mesh.cloneMesh().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the object's mesh<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Animation.html" title="class in com.threed.jpct"><CODE>Animation</CODE></A>, 
<A HREF="../../../com/threed/jpct/Mesh.html#cloneMesh(boolean)"><CODE>Mesh.cloneMesh(boolean)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setMesh(com.threed.jpct.Mesh)"><CODE>setMesh(com.threed.jpct.Mesh)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getPolygonManager()"><!-- --></A><H3>
getPolygonManager</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/PolygonManager.html" title="class in com.threed.jpct">PolygonManager</A> <B>getPolygonManager</B>()</PRE>
<DL>
<DD>Returns the PolygonManager for this object. A PolygonManager can be used
 to access an object's polygons. While you can obtain a PolygonManager
 from a stripped object, you can't safely modify the object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the manager<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#strip()"><CODE>strip()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBoundingBox(float, float, float, float, float, float)"><!-- --></A><H3>
setBoundingBox</H3>
<PRE>
public void <B>setBoundingBox</B>(float&nbsp;minx,
                           float&nbsp;maxx,
                           float&nbsp;miny,
                           float&nbsp;maxy,
                           float&nbsp;minz,
                           float&nbsp;maxz)</PRE>
<DL>
<DD>Sets a new AABB for the object. Usually, this shouldn't be required as it
 is automatically done by the build()-method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minx</CODE> - the lowest x-value of the AABB<DD><CODE>maxx</CODE> - the highest x-value of the AABB<DD><CODE>miny</CODE> - the lowest y-value of the AABB<DD><CODE>maxy</CODE> - the highest y-value of the AABB<DD><CODE>minz</CODE> - the lowest z-value of the AABB<DD><CODE>maxz</CODE> - the highest z-value of the AABB<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcBoundingBox()"><CODE>calcBoundingBox()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="cloneObject()"><!-- --></A><H3>
cloneObject</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A> <B>cloneObject</B>()</PRE>
<DL>
<DD>Clones the current object. A cloned object A' of an object A is a copy of
 A at the point when the cloning takes places. This means that A' inherits
 all rotations, translations and rendering properties from A. However, A'
 and A are sharing the same mesh data (to save memory). This will cause A'
 to inherit all keyframe animations from A and vice versa. Keep this in
 mind when cloning animated objects. Cloning an object is a costly
 operation that should only be done when needed. If multiple copies of an
 object are required during runtime, it may be helpful to create them at
 startup. This method also copies properties like lazy transformation
 settings and similar, so take care to adjust afterwards on the cloned
 object if needed. Cloning doesn't clone collision modes.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the cloned object</DL>
</DD>
</DL>
<HR>

<A NAME="getWorldTransformation()"><!-- --></A><H3>
getWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getWorldTransformation</B>()</PRE>
<DL>
<DD>Returns the transformation matrix used to transform the object from
 objectspace into worldspace. Could be useful for debugging purposes, but
 usually this information shouldn't be needed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the transformation matrix</DL>
</DD>
</DL>
<HR>

<A NAME="getWorldTransformationTweaked(com.threed.jpct.Matrix)"><!-- --></A><H3>
getWorldTransformationTweaked</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getWorldTransformationTweaked</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getWorldTransformation(com.threed.jpct.Matrix)"><!-- --></A><H3>
getWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getWorldTransformation</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Variant of getWorldTransformation() to avoid the creation of an
 additional matrix where not needed. The given matrix will be filled with
 the returns and returned in addition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mat</CODE> - the matrix to be filled</DL>
</DD>
</DL>
<HR>

<A NAME="addCollisionListener(com.threed.jpct.CollisionListener)"><!-- --></A><H3>
addCollisionListener</H3>
<PRE>
public void <B>addCollisionListener</B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Adds a collision listener to this object. A collision listener gets
 notified in case of a collision with or caused by this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the listener<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct"><CODE>CollisionListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="removeCollisionListener(com.threed.jpct.CollisionListener)"><!-- --></A><H3>
removeCollisionListener</H3>
<PRE>
public void <B>removeCollisionListener</B>(<A HREF="../../../com/threed/jpct/CollisionListener.html" title="interface in com.threed.jpct">CollisionListener</A>&nbsp;listener)</PRE>
<DL>
<DD>Removes a collision listener from the list of listeners.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>listener</CODE> - the listener to remove</DL>
</DD>
</DL>
<HR>

<A NAME="disableCollisionListeners()"><!-- --></A><H3>
disableCollisionListeners</H3>
<PRE>
public void <B>disableCollisionListeners</B>()</PRE>
<DL>
<DD>Disables all collision listeners of this object, so that none of them
 will be notified in case of a collision.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="enableCollisionListeners()"><!-- --></A><H3>
enableCollisionListeners</H3>
<PRE>
public void <B>enableCollisionListeners</B>()</PRE>
<DL>
<DD>(Re-)enables all collision listerner of this object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCollisionListeners()"><!-- --></A><H3>
getCollisionListeners</H3>
<PRE>
public java.util.Enumeration <B>getCollisionListeners</B>()</PRE>
<DL>
<DD>Returns the collision listeners of this object as an enumeration. The
 enumeration is empty if no listeners have been assigned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the listeners</DL>
</DD>
</DL>
<HR>

<A NAME="setRenderHook(com.threed.jpct.IRenderHook)"><!-- --></A><H3>
setRenderHook</H3>
<PRE>
public void <B>setRenderHook</B>(<A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A>&nbsp;hook)</PRE>
<DL>
<DD>Sets a new hook into the rendering pipeline. This is only valid for
 compiled objects. Any other object will never access this hook. The hook
 won't be serialized if the Object3D is.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>hook</CODE> - the hook into the rendering pipeline<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct"><CODE>IRenderHook</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRenderHook()"><!-- --></A><H3>
getRenderHook</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/IRenderHook.html" title="interface in com.threed.jpct">IRenderHook</A> <B>getRenderHook</B>()</PRE>
<DL>
<DD>Returns the render hook or null, if none has been set.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the hook or null</DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollision(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkForCollision</H3>
<PRE>
public int <B>checkForCollision</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dirVec,
                             float&nbsp;step)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a ray-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dirVec</CODE> - the direction vector (a unit vector)<DD><CODE>step</CODE> - the length of the casted ray (a collision will only be
            detected of it takes place within this range)
<DT><B>Returns:</B><DD>the ID of the Object3D if there is a collision, otherwise
         NO_OBJECT<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#getID()"><CODE>getID()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#NO_OBJECT"><CODE>NO_OBJECT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollisionSpherical(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
checkForCollisionSpherical</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkForCollisionSpherical</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                               float&nbsp;radius)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a sphere-polygon collision
 detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>translation</CODE> - the translation the object should perform<DD><CODE>radius</CODE> - the radius of the sphere (a collision will only be detected of
            it takes place within this radius)
<DT><B>Returns:</B><DD>a SimpleVector containing a corrected translation vector. This
         vector represents the translation that should be applied to the
         object to avoid a collision. If no collision takes place, the
         translation won't be corrected though (i.e. no collision means
         returned SimpleVector.equals(translation))<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="checkForCollisionEllipsoid(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, int)"><!-- --></A><H3>
checkForCollisionEllipsoid</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>checkForCollisionEllipsoid</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;translation,
                                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid,
                                               int&nbsp;recursionDepth)</PRE>
<DL>
<DD>Checks if the current object collides with something when moving into a
 particular direction. This is just a check, so no translations are being
 performed. A collision can only be detected with objects that are set to
 COLLISION_CHECK_OTHERS. This method uses a (swept)ellipsoid-polygon
 collision detection.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>translation</CODE> - the translation the object should perform<DD><CODE>ellipsoid</CODE> - the radius of the epplisoid in x,y and z direction<DD><CODE>recursionDepth</CODE> - the max. recursion depth of the collision detection. A higher
            value will improve the accuracy of the collision detection but
            reduce performance. Reasonable values lie between 1 and 5.
<DT><B>Returns:</B><DD>a SimpleVector containing a corrected translation vector. This
         vector represents the translation that should be applied to the
         object to avoid a collision. If no collision takes place, the
         translation won't be corrected though (i.e. no collision means
         returned SimpleVector.equals(translation))<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setCollisionMode(int)"><CODE>setCollisionMode(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setEllipsoidMode(int)"><!-- --></A><H3>
setEllipsoidMode</H3>
<PRE>
public void <B>setEllipsoidMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>When doing ellipsoid collision detection with this object, the ellipsoid
 can be transformed according to the objects's transformation and in the
 source's object space or it remains static in the target's object space
 (i.e. "axis aligned"). <br>
 The later is faster, but not suitable for all kinds of ellipsoids.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - int the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED"><CODE>ELLIPSOID_ALIGNED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED"><CODE>ELLIPSOID_TRANSFORMED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getEllipsoidMode()"><!-- --></A><H3>
getEllipsoidMode</H3>
<PRE>
public int <B>getEllipsoidMode</B>()</PRE>
<DL>
<DD>Returns the current ellipsoid mode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the mode<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_ALIGNED"><CODE>ELLIPSOID_ALIGNED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#ELLIPSOID_TRANSFORMED"><CODE>ELLIPSOID_TRANSFORMED</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="wasTargetOfLastCollision()"><!-- --></A><H3>
wasTargetOfLastCollision</H3>
<PRE>
public boolean <B>wasTargetOfLastCollision</B>()</PRE>
<DL>
<DD>True, if this object was a target of the last collision detection that
 took place (regardless of what kind it was). Otherwise false. "A target"
 in this context means, that something has collided with this object, i.e.
 if one checks object A for collision with other objects and it collides
 with an object B, B is the target and A is the source. A collision is not
 automatically detected. One has to use one of the various ways jPCT
 offers for collision detection to detect it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>was this object a target of the last detected collision?<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#resetCollisionStatus()"><CODE>resetCollisionStatus()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="resetCollisionStatus()"><!-- --></A><H3>
resetCollisionStatus</H3>
<PRE>
public void <B>resetCollisionStatus</B>()</PRE>
<DL>
<DD>Sets the indicator that the object was a target of the last collision
 detection to false, i.e. the object won't be recognized any longer as
 part of the collision. This is done automatically the next time a
 collision detection method is being called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#wasTargetOfLastCollision()"><CODE>wasTargetOfLastCollision()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
calcMinDistance</H3>
<PRE>
public float <B>calcMinDistance</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - a SimpleVector containing the position vector<DD><CODE>dr</CODE> - a SimpleVector containing the direction vector
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit). If there is no such
         polygon, COLLISION_NONE will be returned.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcMinDistance(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
calcMinDistance</H3>
<PRE>
public float <B>calcMinDistance</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                             <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                             float&nbsp;ignoreIfLarger)</PRE>
<DL>
<DD>Returns the minimal distance to some polygon of the object from a
 particular position vector looking into a specific direction. This
 version is a special purpose version of calcMinDistance() which only
 takes polygons into consideration that have at least one vertex that is
 closer than ignoreIfLarger units to the position vector. Can be useful to
 optimize calculations in situations where it is known how far away the
 polygon with the minimal distance can be at max.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - a SimpleVector containing the position vector<DD><CODE>dr</CODE> - a SimpleVector containing the direction vector<DD><CODE>ignoreIfLarger</CODE> - only polygons within this range will be taken into account
<DT><B>Returns:</B><DD>the minimal distance to some polygon (= how far can one move into
         this direction until something will be hit). If there is no such
         polygon, COLLISION_NONE will be returned.<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#COLLISION_NONE"><CODE>COLLISION_NONE</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setCenter(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setCenter</H3>
<PRE>
public void <B>setCenter</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;center)</PRE>
<DL>
<DD>Sets the center of the object (in object-space). This "center" doesn't
 has to be the real center of the object but it's the point in objectspace
 which will be used for collision detection. This means that if one tests
 if the object may move A units into (x,y,z)-direction, actually it's
 tested if this point (transformed into world-space) may move A units into
 (x,y,z)-direction. Calling build() resets this value to a calculated
 center, so this method should be called after calling build().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>center</CODE> - the center<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getCenter()"><!-- --></A><H3>
getCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getCenter</B>()</PRE>
<DL>
<DD>Returns the center of the object (in object-space, i.e. unaffected by any
 transformation).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformedCenter()"><!-- --></A><H3>
getTransformedCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTransformedCenter</B>()</PRE>
<DL>
<DD>Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center transformed into worldspace</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformedCenter(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
getTransformedCenter</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getTransformedCenter</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;toFill)</PRE>
<DL>
<DD>Returns the center of the object in worldspace, i.e. after the object's
 current transformations have been applied to it. The returned
 SimpleVector is the same one as the one given as parameter. This is
 useful to save the creation of an additional object. If null is given, a
 new one will be created.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the center transformed into worldspace</DL>
</DD>
</DL>
<HR>

<A NAME="setRotationPivot(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setRotationPivot</H3>
<PRE>
public void <B>setRotationPivot</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;pivot)</PRE>
<DL>
<DD>Sets the rotation pivot of the object. The rotation pivot is the point in
 objectspace around which the object will be rotated using its rotation
 matrix. Calling build() resets this value to a calculated rotation pivot,
 so this method should be called after calling build().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pivot</CODE> - the rotation pivot<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRotationPivot()"><!-- --></A><H3>
getRotationPivot</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A> <B>getRotationPivot</B>()</PRE>
<DL>
<DD>Returns the rotation pivot of the object
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the rotation pivot</DL>
</DD>
</DL>
<HR>

<A NAME="calcCenter()"><!-- --></A><H3>
calcCenter</H3>
<PRE>
public void <B>calcCenter</B>()</PRE>
<DL>
<DD>Tries to calculate the center of the object using its mesh data. This is
 a very rough approach and while it works very well on most objects, it
 may fail on others. This method sets both the center and the rotation
 pivot. This method is called by the build() method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#setCenter(com.threed.jpct.SimpleVector)"><CODE>setCenter(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#setRotationPivot(com.threed.jpct.SimpleVector)"><CODE>setRotationPivot(com.threed.jpct.SimpleVector)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOcTree(com.threed.jpct.OcTree)"><!-- --></A><H3>
setOcTree</H3>
<PRE>
public void <B>setOcTree</B>(<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A>&nbsp;ocTree)</PRE>
<DL>
<DD>Assigns an octree to the object. An octree may help to increase
 performance for some kind of objects (like large landscapes). It's not
 possible to combine portals and octrees (at least not in jPCT), so
 setting the octree will be ignored if portal rendering is enabled. In
 every other case, the object will be rendered using the octree as soon as
 it's assigned to it.<br>
 Please keep in mind that calculating triangle strips has to be done
 before building/assigning the tree, because it will destroy the tree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ocTree</CODE> - the octree that subdivides this object<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><CODE>OcTree</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOcTree()"><!-- --></A><H3>
getOcTree</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct">OcTree</A> <B>getOcTree</B>()</PRE>
<DL>
<DD>Returns the OcTree assigned to this object or null, if none has been
 assigned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the OcTree (or null)</DL>
</DD>
</DL>
<HR>

<A NAME="setSector(int)"><!-- --></A><H3>
setSector</H3>
<PRE>
public void <B>setSector</B>(int&nbsp;sector)</PRE>
<DL>
<DD>Places the object into a specific sector. This is required for performing
 static sector detection on objects other than the main world (= the "map"
 or "level"). Sector detection is only required if portal rendering should
 be used. Objects using dynamic sector detection don't need to be bound to
 a specific sector. The sectors are being defined by the polygons of the
 main World (= the "map") and are constructed automatically when calling
 build() on the main world. setSector() should be called (only if needed
 of course) after the object has been added to an instance of World. Doing
 it the other way round is possible but not recommended.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sector</CODE> - the sector number in which the object is in<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAsMultiSectored()"><!-- --></A><H3>
setAsMultiSectored</H3>
<PRE>
public void <B>setAsMultiSectored</B>()</PRE>
<DL>
<DD>Tells jPCT that this object is a multi-sectored one (for portal
 rendering). Multi-sectored objects are supported but despite from the
 main world, which has to be multi-sectored, not recommended. Not because
 they won't work, but because they don't make much sense. If one still
 thinks that they do, this is the method to tell jPCT for any object other
 than the main world, that it is a multi-sectored one. To call
 reorderSectors() after creating such an object is absolutly required (as
 well as calcNormals())...build() doesn't make much sense with such
 objects (but it wouldn't hurt anyway). To keep this short. Support is
 there but if it's possible to avoid these kind of objects: do it!
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOrigin(com.threed.jpct.SimpleVector)"><!-- --></A><H3>
setOrigin</H3>
<PRE>
public void <B>setOrigin</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;origin)</PRE>
<DL>
<DD>Sets the origin of the object. The origin is a position in worldspace at
 which the object will be placed before performing any other translations.
 The difference between the origin and a normal translation is, that the
 normal translation affects the child objects (if any) while the
 translation to the origin doesn't.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>origin</CODE> - the origin<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#translate(float, float, float)"><CODE>translate(float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="invert()"><!-- --></A><H3>
invert</H3>
<PRE>
public void <B>invert</B>()</PRE>
<DL>
<DD>Physically "inverts" the object, which means that the backface culling
 works the other way round. This could be used for example on a cube that
 is usually viewed from outside to make it possible to view it from the
 inside (and still use backface culling on it). Inverting an object is a
 costly operation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="invertCulling(boolean)"><!-- --></A><H3>
invertCulling</H3>
<PRE>
public void <B>invertCulling</B>(boolean&nbsp;inv)</PRE>
<DL>
<DD>Inverts culling order if set to true. This affects culling only, not the
 mesh itself (unlike invert()).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>inv</CODE> - invert the culling?</DL>
</DD>
</DL>
<HR>

<A NAME="cullingIsInverted()"><!-- --></A><H3>
cullingIsInverted</H3>
<PRE>
public boolean <B>cullingIsInverted</B>()</PRE>
<DL>
<DD>Returns true, if inverted culling is used on this object. False
 otherwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>is it?</DL>
</DD>
</DL>
<HR>

<A NAME="calcNormals()"><!-- --></A><H3>
calcNormals</H3>
<PRE>
public void <B>calcNormals</B>()</PRE>
<DL>
<DD>Calculates the object's vertex normals by calculating the face normals of
 the adjacent polygons of each vertex and averaging them. The normals are
 required for lighting and mapping, so they need to be calculated for
 every object. Usually, this is already done by calling the object's
 build() method. (Respective by the loader for MD2-files). jPCT has two
 different methods for calculating the normals. One is faster for smaller
 objects while the other one is (much!) faster for more complex objects.
 jPCT automatically decides which method to use depending on the object
 and the value of optimizeNormalCalcTH in Config.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#build()"><CODE>build()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Config.html#optimizeNormalCalcTH"><CODE>Config.optimizeNormalCalcTH</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcTangentVectors()"><!-- --></A><H3>
calcTangentVectors</H3>
<PRE>
public void <B>calcTangentVectors</B>()</PRE>
<DL>
<DD>Tangent vectors are needed for some calculation in shaders. If you are
 using shaders and your shader needs these vectors and jPCT wasn't able to
 detect this (by searching for "attribute vec4 tangent" in the vertex
 shader, you might want to trigger this calculation manually. By default,
 the calculation happens automatically if the need has been detected.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="calcTextureWrap()"><!-- --></A><H3>
calcTextureWrap</H3>
<PRE>
public void <B>calcTextureWrap</B>()</PRE>
<DL>
<DD>"Wraps" a texture around the object. This may not look correct on every
 object, but it's a fast and easy way to assign texture coordinates to
 objects that didn't have any. This kind of wrapping is basically a kind
 of static environment mapping. It is advised to call
 recreateTextureCoords() after calling this method (if the object already
 has a texture).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#recreateTextureCoords()"><CODE>recreateTextureCoords()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrapSpherical()"><CODE>calcTextureWrapSpherical()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="calcTextureWrapSpherical()"><!-- --></A><H3>
calcTextureWrapSpherical</H3>
<PRE>
public void <B>calcTextureWrapSpherical</B>()</PRE>
<DL>
<DD>"Wraps" a texture around the object in a spherical way. Usually, this
 method produces better results than calcTextureWrap(), but it depends on
 the object. This method is well suited to assign texture-coordinates to
 objects that were generated using the Primitives class. It is advised to
 call recreateTextureCoords() after calling this method (if the object
 already has a texture). This method recalculates the center of the
 object, so any modification to the center or the rotation-pivot will be
 lost after calling this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#recreateTextureCoords()"><CODE>recreateTextureCoords()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrap()"><CODE>calcTextureWrap()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Primitives.html" title="class in com.threed.jpct"><CODE>Primitives</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="recreateTextureCoords()"><!-- --></A><H3>
recreateTextureCoords</H3>
<PRE>
public void <B>recreateTextureCoords</B>()</PRE>
<DL>
<DD>Rebuilds the actual texture coordinates for this object. This should be
 called after assigning another texture to an object or after calling
 calcTextureWrap...().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrap()"><CODE>calcTextureWrap()</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#calcTextureWrapSpherical()"><CODE>calcTextureWrapSpherical()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAllTextures(java.lang.String, java.lang.String)"><!-- --></A><H3>
setAllTextures</H3>
<PRE>
public void <B>setAllTextures</B>(java.lang.String&nbsp;texname,
                           java.lang.String&nbsp;bumpname)</PRE>
<DL>
<DD>Sets the textures for an object. The textures will be set for the whole
 object (= the same for all polygons). The object's basemap (used for
 blending) is set to it's texturemap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texname</CODE> - the name of the texture as set in the
            TextureManager.addTexture()-method<DD><CODE>bumpname</CODE> - the name of the bumpmap as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="setAllTextures(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
setAllTextures</H3>
<PRE>
public void <B>setAllTextures</B>(java.lang.String&nbsp;basename,
                           java.lang.String&nbsp;texname,
                           java.lang.String&nbsp;bumpname)</PRE>
<DL>
<DD>Sets the textures for an object. The textures will be set for the whole
 object (= the same for all polygons).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>basename</CODE> - the name of the base Texture (used for blending) as set in the
            TextureManager.addTexture()-method<DD><CODE>texname</CODE> - the name of the Texture as set in the
            TextureManager.addTexture()-method<DD><CODE>bumpname</CODE> - the name of the bumpmap as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="setBaseTexture(java.lang.String)"><!-- --></A><H3>
setBaseTexture</H3>
<PRE>
public void <B>setBaseTexture</B>(java.lang.String&nbsp;texname)</PRE>
<DL>
<DD>Sets the base texture for the whole object. The base texture is used for
 blending only. When using normal texture mapping, the normal texture is
 used for texturing the object. When using blending, three textures are
 used: A bumpmap (defined by the object's bumpmap), a normal texturemap
 (which is used as an environment map in this mode) and the basemap (which
 is blended together with the bumpmapped environment map...hence the name
 of the mode).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texname</CODE> - the name of the base texture as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="setTexture(java.lang.String)"><!-- --></A><H3>
setTexture</H3>
<PRE>
public void <B>setTexture</B>(java.lang.String&nbsp;texname)</PRE>
<DL>
<DD>Sets the texture for the object. When using normal texturemapping, this
 texture is the only one used. With environment mapping enabled, this
 texture is used as an environment map. With environment bumpmapping
 enabled (software renderer only), this texture is pertubed by the
 bumpmap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texname</CODE> - the name of the texture as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="shareTextureData(com.threed.jpct.Object3D)"><!-- --></A><H3>
shareTextureData</H3>
<PRE>
public void <B>shareTextureData</B>(<A HREF="../../../com/threed/jpct/Object3D.html" title="class in com.threed.jpct">Object3D</A>&nbsp;source)</PRE>
<DL>
<DD>In addition to sharing the actual mesh data, you can also make objects
 share the same texturing information (the actual textures, not the
 uv-coordinates). If you do this, changing the texture on one object will
 change it on all sharing objects too.<br/>
 This helps to save some memory.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - the source of the texturing information</DL>
</DD>
</DL>
<HR>

<A NAME="setTexture(com.threed.jpct.TextureInfo)"><!-- --></A><H3>
setTexture</H3>
<PRE>
public void <B>setTexture</B>(<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</PRE>
<DL>
<DD>Sets the texture for the object via an instance of TextureInfo.
 TextureInfo may contain multiple texture layers, but this is supported
 only by the OpenGL renderer. The software renderer will threat a multi
 layered TextureInfo as if it were a single layered one, i.e. it ignores
 the additional texture layers.<br>
 Texture coordinates for all layers are taken from the coordinates defined
 for the base layer of the Object3D, i.e. u/v coordinates given to this
 TextureInfo will be ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tInf</CODE> - the TextureInfo<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setBumpmapTexture(java.lang.String)"><!-- --></A><H3>
setBumpmapTexture</H3>
<PRE>
public void <B>setBumpmapTexture</B>(java.lang.String&nbsp;texname)</PRE>
<DL>
<DD>Sets the bumpmap of the object. When using normal texturemapping, this
 texture is not used. With environment bumpmapping enabled, this texture
 pertubes the environment map. Is this supported only by the software
 renderer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texname</CODE> - the name of the bumpmap as set in the
            TextureManager.addTexture()-method</DL>
</DD>
</DL>
<HR>

<A NAME="removeMultiTexturing()"><!-- --></A><H3>
removeMultiTexturing</H3>
<PRE>
public void <B>removeMultiTexturing</B>()</PRE>
<DL>
<DD>Removes all multi texturing information from this object. The object will
 use simple single texturing after calling this method and the removed
 information can't be restored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="invertTextureCoords(boolean, boolean)"><!-- --></A><H3>
invertTextureCoords</H3>
<PRE>
public void <B>invertTextureCoords</B>(boolean&nbsp;invertU,
                                boolean&nbsp;invertV)</PRE>
<DL>
<DD>Inverts the texture coordinates assuming that they are in the range of
 0..1. Inverting means 1-coord.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>invertU</CODE> - if true, u will be inverted<DD><CODE>invertV</CODE> - if true, v will be inverted</DL>
</DD>
</DL>
<HR>

<A NAME="rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, boolean)"><!-- --></A><H3>
rayIntersectsAABB</H3>
<PRE>
public float <B>rayIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr,
                               boolean&nbsp;isNormalized)</PRE>
<DL>
<DD>Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection. <br>
 If the object doesn't have a bounding box for whatever reason,
 RAY_MISSES_BOX will be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ray<DD><CODE>dr</CODE> - the direction vector of the ray<DD><CODE>isNormalized</CODE> - indicates, that dr is already normalized. So the method can
            spare another normalization.
<DT><B>Returns:</B><DD>the distance between the starting point of the ray and the
         nearest plane of the box. If the ray doesn't intersect the box,
         RAY_MISSES_BOX will be returned<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX"><CODE>RAY_MISSES_BOX</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="rayIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
rayIntersectsAABB</H3>
<PRE>
public float <B>rayIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                               <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;dr)</PRE>
<DL>
<DD>Checks if a given ray intersects with the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection. <br>
 If the object doesn't have a bounding box for whatever reason,
 RAY_MISSES_BOX will be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ray<DD><CODE>dr</CODE> - the direction vector of the ray
<DT><B>Returns:</B><DD>the distance between the starting point of the ray and the
         nearest plane of the box. If the ray doesn't intersect the box,
         RAY_MISSES_BOX will be returned<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Object3D.html#RAY_MISSES_BOX"><CODE>RAY_MISSES_BOX</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ellipsoidIntersectsAABB(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
ellipsoidIntersectsAABB</H3>
<PRE>
public boolean <B>ellipsoidIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;ellipsoid)</PRE>
<DL>
<DD>Checks if a given ellipsoid intersects the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection.
 "Intersection" means everything from touching it to being completely
 covered by it in this case. <br>
 If the object doesn't have a bounding box for whatever reason, false will
 be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the ellipsoid (the ellipsoid's center)<DD><CODE>ellipsoid</CODE> - the radius of the ellipsoid in x,y and z-direction as a
            SimpleVector
<DT><B>Returns:</B><DD>true if there is an intersection, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="sphereIntersectsAABB(com.threed.jpct.SimpleVector, float)"><!-- --></A><H3>
sphereIntersectsAABB</H3>
<PRE>
public boolean <B>sphereIntersectsAABB</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;org,
                                    float&nbsp;radius)</PRE>
<DL>
<DD>Checks if a given sphere intersects the axis aligned bounding box (in
 object-space) of this object. This can be useful to speed up some
 calculations. jPCT is using this method for faster collision detection.
 "Intersection" means everything from touching it to being completely
 covered by it in this case.<br>
 If the object doesn't have a bounding box for whatever reason, false will
 be returned.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>org</CODE> - the position vector of the sphere (the sphere's center)<DD><CODE>radius</CODE> - the radius of the sphere
<DT><B>Returns:</B><DD>true if there is an intersection, otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the texture of the
 object won't be set and the sector will be set to undefined. Texture
 coordinates won't be set (= set to (0,0) for all vertices). The vertices
 have to be defined counter-clockwise because jPCT backface culls them by
 default. One may also add them clockwise and call invert() afterwards to
 "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the texture of the
 object won't be set and the sector will be set to undefined. The vertices
 have to be defined counter-clockwise because jPCT backface culls them by
 default. One may also add them clockwise and call invert() afterwards to
 "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3,
                       int&nbsp;textureID)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the sector will be set
 to undefined. The vertices have to be defined counter-clockwise because
 jPCT backface culls them by default. One may also add them clockwise and
 call invert() afterwards to "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex<DD><CODE>textureID</CODE> - the ID of the texture as returned by
            TextureManager.getTextureID()
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3,
                       int&nbsp;textureID,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vertexAlpha)</PRE>
<DL>
<DD>Adds a triangle to the object. Using the method, the sector will be set
 to undefined. The vertices have to be defined counter-clockwise because
 jPCT backface culls them by default. One may also add them clockwise and
 call invert() afterwards to "invert" the order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex<DD><CODE>textureID</CODE> - the ID of the texture as returned by
            TextureManager.getTextureID()<DD><CODE>vertexAlpha</CODE> - the alpha values (0..1) of the three vertices stored in x,y
            and z. This isn't supported by the software renderer.
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, com.threed.jpct.SimpleVector, float, float, int, int)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       float&nbsp;u,
                       float&nbsp;v,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       float&nbsp;u2,
                       float&nbsp;v2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       float&nbsp;u3,
                       float&nbsp;v3,
                       int&nbsp;textureID,
                       int&nbsp;sec)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>u</CODE> - the u component of the texture position at the first vertex<DD><CODE>v</CODE> - the v component of the texture position at the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>u2</CODE> - the u component of the texture position at the second vertex<DD><CODE>v2</CODE> - the v component of the texture position at the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>u3</CODE> - the u component of the texture position at the third vertex<DD><CODE>v3</CODE> - the v component of the texture position at the third vertex<DD><CODE>textureID</CODE> - the ID of the texture as returned by
            TextureManager.getTextureID()<DD><CODE>sec</CODE> - the number of the sector to which the polygon belongs
            (important when using portal rendering with static sector
            detection for this object)
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo, com.threed.jpct.SimpleVector)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vertexAlpha)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.<br>
 This method takes a TextureInfo instead of the discrete u/v-coordinates
 and the textureID. With that, it's possible to use multi texturing in
 jPCT. But be aware that only the OpenGL renderer supports this feature.
 The software renderer will ignore the additional texture stages.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>tInf</CODE> - the TextureInfo<DD><CODE>vertexAlpha</CODE> - the alpha values (0..1) of the three vertices stored in x,y
            and z. This isn't supported by the software renderer.
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.<br>
 This method takes a TextureInfo instead of the discrete u/v-coordinates
 and the textureID. With that, it's possible to use multi texturing in
 jPCT. But be aware that only the OpenGL renderer supports this feature.
 The software renderer will ignore the additional texture stages.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>tInf</CODE> - the TextureInfo
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="addTriangle(com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.SimpleVector, com.threed.jpct.TextureInfo, int)"><!-- --></A><H3>
addTriangle</H3>
<PRE>
public int <B>addTriangle</B>(<A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert1,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert2,
                       <A HREF="../../../com/threed/jpct/SimpleVector.html" title="class in com.threed.jpct">SimpleVector</A>&nbsp;vert3,
                       <A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct">TextureInfo</A>&nbsp;tInf,
                       int&nbsp;sec)</PRE>
<DL>
<DD>Adds a triangle to the object. The vertices have to be defined
 counter-clockwise because jPCT backface culls them by default. One may
 also add them clockwise and call invert() afterwards to "invert" the
 order.<br>
 This method takes a TextureInfo instead of the discrete u/v-coordinates
 and the textureID. With that, it's possible to use multi texturing in
 jPCT. But be aware that only the OpenGL renderer supports this feature.
 The software renderer will ignore the additional texture stages.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vert1</CODE> - the first vertex<DD><CODE>vert2</CODE> - the second vertex<DD><CODE>vert3</CODE> - the third vertex<DD><CODE>tInf</CODE> - the TextureInfo<DD><CODE>sec</CODE> - the number of the sector to which the polygon belongs
            (important when using portal rendering with static sector
            detection for this object)
<DT><B>Returns:</B><DD>the number of the added triangle<DT><B>See Also:</B><DD><A HREF="../../../com/threed/jpct/Portals.html#SECTOR_UNDEFINED"><CODE>Portals.SECTOR_UNDEFINED</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureManager.html#getTextureID(java.lang.String)"><CODE>TextureManager.getTextureID(java.lang.String)</CODE></A>, 
<A HREF="../../../com/threed/jpct/TextureInfo.html" title="class in com.threed.jpct"><CODE>TextureInfo</CODE></A>, 
<A HREF="../../../com/threed/jpct/Object3D.html#invert()"><CODE>invert()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getInverseWorldTransformation()"><!-- --></A><H3>
getInverseWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getInverseWorldTransformation</B>()</PRE>
<DL>
<DD>Returns the inverse of the transformation matrix from object into world
 space.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the inverse</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseWorldTransformation(com.threed.jpct.Matrix)"><!-- --></A><H3>
getInverseWorldTransformation</H3>
<PRE>
public <A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A> <B>getInverseWorldTransformation</B>(<A HREF="../../../com/threed/jpct/Matrix.html" title="class in com.threed.jpct">Matrix</A>&nbsp;mat)</PRE>
<DL>
<DD>Returns the inverse of the transformation matrix from object into world
 space and fills the result in the given matrix.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the inverse (mat)</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../com/threed/jpct/Mesh.html" title="class in com.threed.jpct"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../com/threed/jpct/OcTree.html" title="class in com.threed.jpct"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Object3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
