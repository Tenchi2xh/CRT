# Language

So far, we can compose and render scenes directly by writing them in Java by instantiating `Scene` and `Entity` objects. But for the user to be able to *compose* his own scenes inside a design environment, we need to define a language: the **CRT scripting language**.

The CRT scripting language follows an *imperative* paradigm and aims to be simple yet permissive enough to enable creativity.

It features two block types for describing a scene and its settings, variables that can store entities, literal values, and point to other variables, parametric procedures (hereinafter referred to as "*macros*") with nested scopes but no return value, and entity modifiers for affine transformations.

Visually as well as syntactically, the language tries to be simple on the eyes, with no end-of-statement terminator. Here is a sample of what it looks like:

```{.haskell caption="Sample CRT script"}
--Entities-------------------------------------------------
sphere1 = Sphere {
    center -> vec3(0, 0.5, 0)
    radius -> 0.5
}

--Constants------------------------------------------------
n = 18
max = (3 * n) / 4 + 5

--Macros---------------------------------------------------
myMacro = Macro (arg1) {
    i = 0
    -- Draw sphere1 "max" times on the x axis
    while (i < max) {
        sphere1 <translate vec3(i*1.0, 0.0, 0.0)>
        i = i - 1
    }
}
```

## ANTLR

The language's grammar will be designed in a EBNF variant, the G4 syntax from **ANTLR**^[**AN**other **T**ool for **L**anguage **R**ecognition], a Java parser generator.

ANTLR will use that grammar specification to automatically generate the code of a lexer, a parser, and base classes useful for implementing tree traversal using design patterns such as *listeners* and *visitors*.

\customfig{uml/antlr.eps}{Family of classes generated by ANTLR4}{}{antlrclass}{}

ANTLR works by first lexing the code into *tokens*, defined by their types in the grammar (e.g. names, identifiers, symbols, etc.) then parsing those tokens using the grammar *rules*, producing a parse tree where all the leaf nodes are tokens. 

\customfig{img/antlr-process.png}{Language recognition process}{.}{antlrprocess}{ANTLR}

For our compiler, we will use the *visitor* pattern, which allows for more control over the tree traversal; the listener provided by ANTLR automatically traverses the tree whereas the visitor forces manual traversal implementation.

Using the generated lexer and parser, we can produce a parse tree (lines 3-6). Then, using custom-made visitors, we can visit each node of the tree to compile the code to a `Script` object (line 8):

```{.java caption="Generating a parse tree and compiling" }
String code = "..."

CRTLexer lexer = new CRTLexer(new ANTLRInputStream(code));
CommonTokenStream tokens = new CommonTokenStream(lexer);
CRTParser parser = new CRTParser(tokens);
ParseTree tree = parser.script();

Compiler compiler = new Compiler(code);
Script script = compiler.visit(tree);
```

## Grammar

The designed grammar is non-ambiguous (context-free), but uses **left-recursion**^[http://en.wikipedia.org/wiki/Left_recursion] for ease of writing *and* reading, which ANTLR supports since version 4.2.

Some parts were inspired from example grammars provided by the ANTLR team on GitHub, in particular the Java grammar^[http://github.com/antlr/grammars-v4/blob/master/java/Java.g4], from which much was learned about left-recursion and operator precedence. 

Furthermore, the "ANTLR 4 IDE" *Eclipse* plug-in^[http://github.com/jknack/antlr4ide] proved to be very useful during the development of the grammar. It provides useful tools for debugging such as syntax diagrams and a live parse tree visualisation --- just by selecting a grammar rule and typing in code, a corresponding parse tree is updated at every keystroke.<!-- Figure \ref{fig:parsetree} shows such a generated parse tree.

\customfig{img/parse-tree.png}{ANTLR 4 IDE's live parse tree}{, displaying a macro assignment}{parsetree}{} -->

A similar (and official) plug-in also exists for *NetBeans*, the main IDE used during the development of this project, however it was not compatible with the latest versions of NetBeans.

Because it is important to make a separation between parsing and compiling, the grammar contains no special verifications; they are done at compile time. This makes the grammar *much* more readable and easy to understand.

Also, ANTLR provides a feature for **labelling** the *alternatives* of a rule, which it will use for code generation where it will generate one visitor method per label (e.g. instead of having to implement a very extensive `visitExpression()` method, it will be broken down to all its alternatives `visitAddition()`, `visitMultiplication()` etc.).

### Rules

This section lists all the grammar rules defined in the `CRT.g4` file, in a **BNF** notation, followed by a quick overview of how they work.

Nonterminal names are enclosed within angled brackets\ ($\langle ... \rangle$). Names starting with a capital are rules, small letter are token types.

\begin{numberedgrammar}
<Script>        ::= <Statement>*

<Statement>     ::= (<Settings> | <Scene> | <Expr>)

<Settings>      ::= \sv{Settings} \sv{\{} <Attribute>* \sv{\}}

<Scene>         ::= \sv{Scene} \sv{\{} <Expr>* \sv{\}}

<Expr>          ::= <Primary>
               \alt <Object>
               \alt <Macro>
               \alt \sv{[} <ExpressionList>? \sv{]}
               \alt <Expr> \sv{[} <Expr> \sv{]}
               \alt <Expr> \sv{(} <ExprList>? \sv{)}
               \alt <Expr> \sv{\textless} <Modifier> (\sv{,} <Modifier>)* \sv{\textgreater}
               \alt (\sv{+} | \sv{-}) <Expr>
               \alt \sv{!} <Expr>
               \alt <Expr> (\sv{*} | \sv{/} | \sv{\%}) <Expr>
               \alt <Expr> (\sv{+} | \sv{-} | \sv{\textasciicircum}) <Expr>
               \alt <Expr> (\sv{\textless=} | \sv{\textgreater=} | \sv{\textless} | \sv{\textgreater} | \sv{==} | \sv{!=}) <Expr>
               \alt <Expr> \sv{\&\&} <Expr>
               \alt <Expr> \sv{||} <Expr>
               \alt <Expr> \sv{?} <Expr> \sv{:} <Expr>
               \alt <Expr> \sv{=} <Expr>

<ExprList>      ::= <Expr> (\sv{,} <Expr>)*

<Primary>       ::= \sv{(} <Expr> \sv{)}
               \alt <Literal>
               \alt <identifier>

<Object>        ::= <name> \sv{\{} <Attribute>* \sv{\}}

<Macro>         ::= \sv{Macro} \sv{(} <ParamList>? \sv{)} \sv{\{} <Expr>* \sv{\}}

<ParamList>     ::= <identifier> (\sv{,} <identifier>)*

<Literal>       ::= (<integer> | <float> | <string> | <boolean>)

<Attribute>     ::= <identifier> \sv{->} <Expr>

<Modifier>      ::= \sv{scale} <Expr>
               \alt \sv{translate} <Expr>
               \alt \sv{rotate} <Expr>
\end{numberedgrammar}

A **script**\ (1) is a set of **statements**\ (2), which can either be settings blocks, scene blocks, or expressions.

**Settings** and **scene** blocks\ (3, 4) are expressed using their names followed by braces containing either a number of attributes, or expressions --- this difference existing because settings have defined names to which we can assign values, and a scene renders all contained expressions that resolve to an entity (see section \ref{subsec:entities}).

An **expression** is either a primary type\ (5), an object\ (6), a macro\ (7), or one of the following:

(8)  List of *heterogeneous* expressions\ (21)
(9)  Access list element
(10) Macro call, which takes an optional list of expressions\ (21) as formal parameters
(11) Entity modified with an affine transformation
(12) Sign unary operators
(13) Negation boolean unary operator
(14) Multiplication, division and modulo operators
(15) Addition and subtraction operators. If both operands are entities, the operators are instead the CSG union (`+`), difference (`-`) and intersection (\texttt{\textasciicircum})
(16) Boolean comparison operators
(17) Boolean conjunction operator
(18) Boolean disjunction operator
(19) Ternary operator
(20) Assignment operator

A **primary** type is either a parenthesised expression (22), a literal type (23) or an identifier (24) --- a token made of alphabetical characters starting with a small letter.

An **object** (25) has a name --- a token made of alphabetical characters starting with a capital letter --- and is followed by a brace separated block of attributes.

A **macro** (26) starts with the word `Macro` and a list of formal parameters (27), followed by a brace separated block of expressions.

A **literal** type (28) can be one of four token types:

- A whole number
- A decimal number
- A string of characters inside straight double quotes
- A boolean value (the words `true` or `false`)

**Attributes** (29) are identifier tokens followed by an arrow (`->`) and an expression.

Finally, **modifiers** (which apply an affine transformation to an entity) can either be a scaling operation (30), a translation (31) or a rotation (32).

Without ANTLR's compatibility with left-recursion, most of the rules referencing expressions would have to be written in such a way that the grammar is only read from left to right, involving a *lot* more rules.

### Operators

Because we used *left-recursion* to write the grammar, the operator precedence is visually clear at first sight --- however, for the sake of completeness, table \ref{tab:operators} shows all operators, their level of precedence (lower level is higher precedence), and a short description.

\begin{table}[h]
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{rclc}
\toprule
Level              & Operator                       & Description                  & Associativity                  \\
1                  & \texttt{{[}{]}}                & List access                  & left-to-right                  \\
2                  & \texttt{()}                    & Macro call                   & left-to-right                  \\
3                  & \texttt{\textless\textgreater} & Entity modifier              & left-to-right                  \\\midrule
\multirow{2}{*}{4} & \texttt{+}                     & Unary plus                   & \multirow{2}{*}{right-to-left} \\
                   & \texttt{-}                     & Unary minus                  &                                \\\midrule
5                  & \texttt{!}                     & Boolean NOT                  & left-to-right                  \\\midrule
\multirow{3}{*}{6} & \texttt{*}                     & Multiplication               & \multirow{3}{*}{left-to-right} \\
                   & \texttt{/}                     & Division                     &                                \\
                   & \texttt{\%}                    & Modulo                       &                                \\\midrule
\multirow{3}{*}{7} & \texttt{+}                     & Addition / union         & \multirow{3}{*}{left-to-right} \\
                   & \texttt{-}                     & Subtraction / difference &                                \\
                   & \texttt{\textasciicircum }     & Intersection             &                                \\\midrule
\multirow{6}{*}{8} & \texttt{\textless=}            & Less than or equal           & \multirow{6}{*}{left-to-right} \\
                   & \texttt{\textgreater=}         & More than or equal           &                                \\
                   & \texttt{\textless}             & Less than                    &                                \\
                   & \texttt{\textgreater}          & More than                    &                                \\
                   & \texttt{==}                    & Equals                       &                                \\
                   & \texttt{!=}                    & Not equal                    &                                \\\midrule
9                  & \texttt{\&\&}                    & Boolean AND                  & left-to-right                \\
10                 & \texttt{||}                    & Boolean OR                   & left-to-right                  \\
11                 & \texttt{?:}                    & Ternary operator             & right-to-left                  \\
12                 & \texttt{=}                     & Assignment                   & right-to-left                  \\

\bottomrule
\end{tabular}
\caption{List of CRT operators}
\label{tab:operators}
\end{table}

## Compiling process

