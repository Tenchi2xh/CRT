# Language

So far, we can compose and render scenes by directly writing them in Java, instancing `Scene` and `Entity` objects. But for the user to *compose* his own scenes, we need to define a language: the CRT scripting language.

The CRT scripting language follows an *imperative* paradigm and aims to be simple yet permissive enough to enable creativity. It features two bloc types for describing a scene settings and its content, variables that can store entities and numeric values, parametric procedures with nested scopes (no functions), and entity modifiers for affine transformations.

## ANTLR

The language's grammar will be designed in EBNF using the G4 syntax from ANTLR^[**AN**other **T**ool for **L**anguage **R**ecognition], a Java parser generator. ANTLR will use that grammar specification file to automatically generate a lexer, a parser, and base classes for implementing tree traversal using design patterns such as *listeners* and *visitors*. 

\customfig{uml/antlr.eps}{Family of classes generated by ANTLR4}{}

Using the generated lexer and parser, we can produce a parse tree (lines 3-6). Then, using custom-made visitors, we can visit each node of the tree to compile the code to a `Scene` object (line 8):

```{.java caption="Generating a parse tree and compiling" }
String code = "..."

CRTLexer lexer = new CRTLexer(new ANTLRInputStream(code));
CommonTokenStream tokens = new CommonTokenStream(lexer);
CRTParser parser = new CRTParser(tokens);
ParseTree tree = parser.program();

Scene scene = new CompilerVisitor().visit(tree);
```

## Grammar

## Compiling process

